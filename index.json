[{"categories":["Ryu"],"content":"什么是集线器 集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。 ","date":"2022-01-09","objectID":"/simple_hub/:1:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"实现代码 # simple_hub.py from ryu.base import app_manager from ryu.controller import ofp_event from ryu.controller.handler import MAIN_DISPATCHER from ryu.controller.handler import set_ev_cls class L2Switch(app_manager.RyuApp): def __init__(self, *args, **kwargs): super(L2Switch, self).__init__(*args, **kwargs) @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def packet_in_handler(self, ev): msg = ev.msg datapath = msg.datapath ofp = datapath.ofproto ofp_parser = datapath.ofproto_parser actions = [ofp_parser.OFPActionOutput(ofp.OFPP_FLOOD)] out = ofp_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions) datapath.send_msg(out) ","date":"2022-01-09","objectID":"/simple_hub/:2:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"实现逻辑 当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。 ","date":"2022-01-09","objectID":"/simple_hub/:3:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"结束语 ","date":"2022-01-09","objectID":"/simple_hub/:4:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"参考文献 RYU入门教程 ","date":"2022-01-09","objectID":"/simple_hub/:4:1","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu","Source Code Read"],"content":"总览 文件位置：ryu/ryu/app/simple_switch.py simple_switch.py共110行 1-18：注释 21-29：引库 32-110：继承类RyuApp ","date":"2022-01-08","objectID":"/simple_switch_note/:1:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"32-37 继承类RyuApp，并调用构造函数 class SimpleSwitch(app_manager.RyuApp): OFP_VERSIONS = [ofproto_v1_0.OFP_VERSION] # 声明支持的Open Flow版本 # 继承，调用构造函数并添加一个新属性 mac_to_port def __init__(self, *args, **kwargs): super(SimpleSwitch, self).__init__(*args, **kwargs) self.mac_to_port = {} ","date":"2022-01-08","objectID":"/simple_switch_note/:2:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"39-51 实现一个添加流表的函数 # 函数：添加流表 def add_flow(self, datapath, in_port, dst, src, actions): ofproto = datapath.ofproto match = datapath.ofproto_parser.OFPMatch( in_port=in_port, dl_dst=haddr_to_bin(dst), dl_src=haddr_to_bin(src)# 源和目的mac地址 ) mod = datapath.ofproto_parser.OFPFlowMod( datapath=datapath, match=match, cookie=0, command=ofproto.OFPFC_ADD, # 命令：添加新流表 idle_timeout=0, hard_timeout=0, priority=ofproto.OFP_DEFAULT_PRIORITY, # 优先级：默认 flags=ofproto.OFPFF_SEND_FLOW_REM, actions=actions) datapath.send_msg(mod) #控制器下发消息 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"datapath 控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"协议细节 OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。 OFPMatch：流匹配规则。 flags：以下三个值之一 | OFPFF_SEND_FLOW_REM 当流过期或删除时，发送删除流消息。 | OFPFF_CHECK_OVERLAP 首先检查重叠的条目。 | OFPFF_EMERG 标记为紧急情况。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"53-94 PacketIn消息的处理逻辑： @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): # 解析数据包 msg = ev.msg datapath = msg.datapath ofproto = datapath.ofproto pkt = packet.Packet(msg.data) eth = pkt.get_protocol(ethernet.ethernet) if eth.ethertype == ether_types.ETH_TYPE_LLDP: # 忽略LLDP类型的包 return dst = eth.dst src = eth.src # 初始化mac_port对应规则 dpid = datapath.id self.mac_to_port.setdefault(dpid, {}) # 打印消息 self.logger.info(\"packet in %s%s%s%s\", dpid, src, dst, msg.in_port) # 记录此包对应的mac_port对应规则 self.mac_to_port[dpid][src] = msg.in_port # 如果目的IP的对应端口已经知道，就直接设置为输出端口，否则就洪泛 if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD # 封装一个OFPActionOutput类型动作：从out_port端口输出 actions = [datapath.ofproto_parser.OFPActionOutput(out_port)] # 如果已经明确了目的IP的输出端口，那么就下发一条流表 if out_port != ofproto.OFPP_FLOOD: self.add_flow(datapath, msg.in_port, dst, src, actions) # 如果交换机没有缓存该包，那么就把该包还回去 data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data # 发送PacketOut消息 out = datapath.ofproto_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions, data=data) datapath.send_msg(out) 细节分析： ","date":"2022-01-08","objectID":"/simple_switch_note/:4:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"LLDP ","date":"2022-01-08","objectID":"/simple_switch_note/:4:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"PacketIn与PacketOut 当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。 所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。 PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"处理逻辑 解析出数据包，根据数据包的IP和输入端口，绑定这个IP和交换机端口。 如果目的IP对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。 如果输出不是洪泛，那么就可以下发流表，绑定目的IP和源IP的转发关系。 封装PacketOut消息，下发。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:3","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"buffer_id与data 交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。 如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。 如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:4","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"96-110 如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息 @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER) def _port_status_handler(self, ev): # 解析消息 msg = ev.msg reason = msg.reason port_no = msg.desc.port_no # 打印 ofproto = msg.datapath.ofproto if reason == ofproto.OFPPR_ADD: self.logger.info(\"port added %s\", port_no) elif reason == ofproto.OFPPR_DELETE: self.logger.info(\"port deleted %s\", port_no) elif reason == ofproto.OFPPR_MODIFY: self.logger.info(\"port modified %s\", port_no) else: self.logger.info(\"Illeagal port state %s%s\", port_no, reason) ","date":"2022-01-08","objectID":"/simple_switch_note/:5:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"结束语 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"参考文献 RYU入门教程 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"备注 ryu官方：https://github.com/faucetsdn/ryu 本人注释版：https://github.com/leeshy-tech/ryu ","date":"2022-01-08","objectID":"/simple_switch_note/:6:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN","OVS"],"content":"导入 在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 OVS：OpenvSwitch的简称，他是一种支持OpenFlow协议的软交换机。 ryu：基于Python开发的SDN开源控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:1:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"准备工作 树莓派搭载linux操作系统，有无线网卡，利用ifconfig命令查得无线网卡名称。 树莓派之间先组成adhoc网络，参考文章：在树莓派上搭建ad-hoc网络教程 在两台树莓派上安装OVS，参考文章：Open vSwitch系列之二 安装指定版本ovs 在其中一台树莓派上安装ryu控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:2:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"组网步骤 假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"控制节点 IP = 10.0.0.1 开启控制器（进入ryu/ryu/app/文件夹执行）： ryu-manager simple_switch.py\rOVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.1\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"普通节点 IP = 10.0.0.2 OVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.2\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"关于网卡设置的解释 将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下： 无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。 对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。 创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令： 取消wlan0设置的IP地址：ifconfig wlan0 0 设置网卡s1的IP地址为原主机地址：ifconfig s1 10.0.0.1 开启网卡s1：ifconfig s1 up ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:3","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"测试 如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？ 注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。 查询两个交换机的流表信息： ovs-ofctl dump-flows s1 输出为空，此时交换机中没有流表。 在控制节点ping普通节点： ping 10.0.0.2 发现可以ping通，同时可以在控制器窗口看到PacketIn消息。 再次查询流表：ovs-ofctl dump-flows s1 发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:4:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"应用 模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序： 控制节点：python3 SDN_on_Raspberry_pi/client.py 普通节点：python3 SDN_on_Raspberry_pi/sever.py 从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:5:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"结束语 因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"参考文献 在树莓派上搭建ad-hoc网络教程 OVS初级教程：使用Open vSwitch构建虚拟网络 Open vSwitch系列之二 安装指定版本ovs ovs之组网实验 SDN系列学习课程-OpenFlow-Ryu-Mininet TCP/IP网络通信之Socket编程入门 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"备注 本文依赖代码文件：https://github.com/leeshy-tech/SDN_on_Raspberry_pi ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["Note","OVS"],"content":"查看信息 查看openvswitch的状态：ovs-vsctl show 查看openvswitch中的所有网桥：ovs-vsctl list-br 查看网桥的信息：ovs-ofctl show br0 查看网桥中的所有端口：ovs-vsctl list-ports br0 查看网桥各端口状态：ovs-ofctl dump-ports br0 查看网桥上的流表：ovs-ofctl dump-flows br0 查看网桥故障模式：ovs-vsctl get-fail-mode br0 查看网桥是否开启stp协议：ovs-vsctl get bridge br0 stp_enable 查看网桥所有配置信息：ovs-vsctl list bridge br0 查看端口所有特性信息：ovs-vsctl list port br0 port1 ","date":"2022-01-07","objectID":"/ovs_cli/:1:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"网桥操作 添加网桥：ovs-vsctl add-br br0 删除网桥：ovs-vsctl del-br br0 将网桥连接到控制器：ovs-vsctl set-controller br0 tcp:\u003ccontroller IP\u003e:\u003cport\u003e 设置网桥的故障模式：ovs-vsctl set-fail-mode br0 \u003csecure or standalone\u003e 给网桥开启stp协议：ovs-vsctl set bridge br0 stp_enable=true ","date":"2022-01-07","objectID":"/ovs_cli/:2:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"端口操作 增加端口：ovs-vsctl add-port br0 port1 删除端口：ovs-vsctl del-port br0 port1 设置端口号：ovs-vsctl set Interface port1 ofport_request=\u003cnumber\u003e 设置端口类型：ovs-vsctl set Interface p4 type=\u003ctype\u003e 端口类型 描述 Normal 普通端口 Internal 这个端口相当于一个虚拟网卡 Patch 用于连接两个网桥的端口 Tunne 隧道端口是一种虚拟端口，支持使用gre或vxlan等隧道技术与位于网络上其他位置的远程端口通讯。 ","date":"2022-01-07","objectID":"/ovs_cli/:3:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"网卡操作 将物理网卡挂接到网桥：ovs-vsctl add-port br0 eth0 列出所有挂接到网卡的网桥：ovs-vsctl port-to-br eth0 删除网桥上已经挂接的网卡：ovs-vsctl del-port br0 eth0 ","date":"2022-01-07","objectID":"/ovs_cli/:4:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"流表操作 添加流表：ovs-ofctl add-flow br0 \u003cmatch\u003e,\u003caction\u003e 删除流表：ovs-ofctl add-flow br0 \u003cmatch\u003e ","date":"2022-01-07","objectID":"/ovs_cli/:5:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"流表动作 action 从端口转发：actions=output:\u003cnumber\u003e 丢弃数据包：actions=drop 广播：actions=NORMAL ","date":"2022-01-07","objectID":"/ovs_cli/:5:1","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"匹配项 match 如有多个匹配项，之间用逗号隔开。 匹配项 描述 in_port=port 网桥端口号 dl_vlan=vlan 数据包的 VLAN Tag 值 dl_vlan_pcp=priority VLAN 优先级，改值取值区间为[0-7]。数字越大，优先级越高。 dl_src=,dl_dst= 匹配源或者目标的 MAC 地址 dl_type=ethertype 匹配以太网协议类型 ,IPv4:0x0800,IPv6:0x086dd,ARP:0x0806 nw_src=,nw_dst= 匹配源或目的IP，前提要设定dl_type table=number 指定流表编号 reg=value[/mask] 网桥中寄存器的值 tp_src=number,tp_dst=number TCP协议源或目的端口 ","date":"2022-01-07","objectID":"/ovs_cli/:5:2","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"参考文献 OpenvSwitch系列 ","date":"2022-01-07","objectID":"/ovs_cli/:6:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Electronic Design","Course"],"content":" 注：本项目来自BUPT课程《电子工艺实习》 ","date":"2022-01-04","objectID":"/electronic_dog/:0:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"导入 电子狗是声控、光控、磁控机电一体化电动玩具。主要工作原理：利用555构成的单稳态触发器，在三种不同的控制方法下，均给以低电平触发，促使电机转动，从而达到了机器狗停走的目的。即：拍手即走、光照即走、磁铁靠近即走，但都只是持续一段时间后就停会下，再满足其中一条件时将继续行走。 原理图如下： 整个系统可分为信号转化、单稳态触发器以及电机驱动三个部分。 ","date":"2022-01-04","objectID":"/electronic_dog/:1:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"单稳态触发器 这部分的功能是：将持续时间很短的低电平信号转换为固定时间间隔（1.1RC）的高电平信号以控制电子狗走路持续时间（控制R和C的数值）。 关于单稳态触发器的原理分析可参考以下文章： 555定时器 ","date":"2022-01-04","objectID":"/electronic_dog/:2:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"信号转换 这部分的功能是将磁、光、声信号转换为低电平电信号。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"磁信号 磁信号向电信号的转换通过干簧管传感器实现，干簧管的电路模型类似于一个磁控开关，外加磁场时开关闭合，常态开关断开（也有常态是闭合的干簧管），详细原理如下： 干簧片相当于一个磁通导体，在尚未操作时，两片簧片并未接触；在通过永久磁铁或电磁线圈产生的磁场时，外加的磁场使两片簧片端点位置附近产生不同的极性, 当磁力超过簧片本身的弹力时，这两片簧片会吸合导通电路；当磁场减弱或消失后,干簧片由于本身的弹性而释放，触面就会分开从而打开电路。 接上拉电阻即可实现常驻高电平，外加磁场时开关闭合输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"光信号 光信号向电信号的转变通过光敏三极管实现，电路模型相当于光控开关，光照相当于开关闭合，详细原理如下： 光敏三极管的发射极具有光敏特性。它的集电极则与普通晶体管一样，可以获得电流增益，基极一般没有引线。当受到光照时CE两极导通，相当于开关闭合。 同样使用上拉电阻，不再赘述。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"声信号 声信号向电信号的转变通过麦克风实现，目前常用的麦克风有驻极体电容麦克风（ECM）和微机电麦克风（MEMS Micphone）。在电子狗实验中使用的是ECM，声波压力推动极板后退使得电容两极电压升高，从而将声信号转换为了电压信号。 因需要对电压放大，驻极体麦克风内部有一个场效应管，正常工作需要加一个直流偏置，其驱动电路之一为： 电容的作用是隔直流。 应用于电子狗的电路设计如下： 左侧为驱动电路，中间加一级共射放大器，右侧是二极管反相器，当麦克风接收到声音信号时，产生交流电压，放大到二级管基极，二极管截止，输出接地，即输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"仿真 干簧管和光敏二极管的电路模型都很简单，没有仿真的必要，以电阻分压的瞬间变化模拟麦克风输出的交流电压，仿真电路如下： 仿真结果显示，开关闭合产生的电压波动输出了约50ms左右的低电平，这是非常不合适的，因为实际的麦克风产生的电压波动情况远远复杂于我们的模拟，会产生持续时间更长的低电平信号，而后级的单稳态触发器，当输入低电平信号持续时间大于1.1RC时，输出高电平的时间会相应的延长，我们想要的应当是一个持续时间很短的电平信号。 解决方法是加入负反馈： 图中绿色部分为增加的负反馈电路，当555定时器输出高电平时，C5充电将Q2 B极电位拉高，使其截止，相当于开关闭合，从而将Q3的B极电位拉低，使得Q3的C极低电位只持续很短的时间。 重新仿真结果如下： 低电平的持续时间变为500us左右。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:4","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"电机驱动 此部分的功能是利用555定时器输出的高电平信号驱动电机转动 电动机是怎么驱动的？非常简单，电池分别接正负极即可。 但是，在已有的场景下，不能使用这种方式，即把555定时器的输出端3号管脚接到电动机正极，地接电动机负极。 原因是：555定时器的驱动能力不足。 查询555定时器（NE555P）的数据手册可知，输出电流最大只有225mA左右，常见的电动玩具马达空载驱动电流在600mA左右，555定时器是远不足以驱动马达的。 最简单的放大电流的方法就是晶体管反相器，所以电机驱动的电路原理图如下： 并联两个三极管增大放大倍数，二极管是防止电机反转，注意这是一个反相器，所以要接到电动机的负极。 用灯泡代替电动机，简单仿真如下： 注意此处输入端用单刀双掷开关，单开关断开是悬空状态，不是输入低电平。 电源两端并联电容是为了稳压和滤波。 ","date":"2022-01-04","objectID":"/electronic_dog/:4:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"总体仿真 将以上模块合并，仿真图如下（光敏二极管用光耦合器代替）： 仿真结果： 电路启动时触发一次电子狗，三种信号各触发一次，注意这里光信号和磁信号使用的是回弹式开关，为下文埋下了伏笔。 ","date":"2022-01-04","objectID":"/electronic_dog/:5:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改进 学校提供的原理图的分析就到这里了，但实际做实验的时候有一些不方便的地方，比如实验室是常亮状态，光照就会一直触发电子狗，必须遮住光，暴露一下就要马上再遮住，在仿真中使用回弹式开关也是这个原因，还是在于单稳态触发器的输入信号不能持续太长时间，我提出的改进方法如下： ","date":"2022-01-04","objectID":"/electronic_dog/:6:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为黑暗触发 这种改进方案很简单，在光信号转化模块后面加一个二极管反相器就可以。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为边沿触发 改进方案与仿真结果如图所示： 开关关闭和开启会被转化为一个短暂的低电平信号，这个信号的持续时间可以通过调整R和C的值来改变。 原理：利用一阶RC电路将原输入信号做一个短暂延时，再与原信号做同或运算，延时的部分就被计算为了0，其他时刻为1。 当初写实验报告的时候只简单写了一个“用边沿触发器实现即可”，现在想想还真不是这么回事。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"结束语 ","date":"2022-01-04","objectID":"/electronic_dog/:7:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"体会 这门课我还是学到了很多东西的。但是我看了看实验报告的标题“电子狗组装”，实在是很让人难蚌。 ","date":"2022-01-04","objectID":"/electronic_dog/:7:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"参考文献 555定时器_Leeshy’s Blog 小马达电机_淘宝网 干簧管_华壬电子 光电三极管_百度百科 一文看懂咪头的工作原理及结构（驻极体话筒） ","date":"2022-01-04","objectID":"/electronic_dog/:7:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"备注 本文仿真使用的是Multisim，原理图绘制使用的是立创EDA。 本文依赖文件：https://github.com/leeshy-tech/Electronic-Design/tree/main/e-dog NE555P数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-04","objectID":"/electronic_dog/:7:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design"],"content":"什么是555定时器 555定时器是一种集成电路芯片，常被用于定时器、脉冲产生器和振荡电路。555可被作为电路中的延时器件、触发器或起振元件。 内部组成如下：由比较器C1C2、RS触发器、缓冲非门G、放电二极管T组成 ","date":"2022-01-02","objectID":"/555timer/:1:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"芯片分析 电压比较器：一种模拟输入、数字输出的接口电路，输出特性如下： in out Vp \u003e Vn 1 Vp \u003c Vn 0 在555定时器内部，左侧是纯电阻分压电路，将比较器阈值设置为 $$ V_{P1}=\\frac{2}{3} V_{cc}, V_{N2}=\\frac{1}{3} V_{cc} $$ C1C2的输出特性如下： C1 C2 in out in out Vp \u003e 2/3Vcc 0 Vn \u003e 1/3Vcc 1 Vp \u003e 2/3Vcc 1 Vn \u003c 1/3Vcc 0 结合RS触发器的真值表可得555定时器的真值表如下： Ui1 Ui2 复位Rd Uo 放电管T x x 0 0 导通 \u003c2/3Vcc \u003c1/3Vcc 1 1 截止 \u003e2/3Vcc \u003e1/3Vcc 1 0 导通 \u003c2/3Vcc \u003e1/3Vcc 1 不变 不变 ","date":"2022-01-02","objectID":"/555timer/:2:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"典型应用 单稳态电路 多谐振荡器 施密特触发器 ","date":"2022-01-02","objectID":"/555timer/:3:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"555定时器为核心的单稳态电路 ","date":"2022-01-02","objectID":"/555timer/:4:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"理论分析 应用电路如下： 稳定状态时，管脚2输入信号为高电平，管脚6跨电容与地相连，相当于输入低电平，复位引脚4接高电平，故输出保持低电平不变，放电二极管保持导通不变。 当输入信号的下降沿到来，输出变为高电平，放电二极管截止，管脚7向外放电，电容C开始充电，直到$ u_C=\\frac{2}{3} V_{cc}$ 若忽略晶体管的饱和压降，则充电时间为 $t_w=RCln \\frac{\\mathrm{Vcc}}{Vcc-\\frac{2}{3} Vcc} =RCln 3 \\approx 1.1 RC$ 当输入信号回到高电平且电容充电完毕后，输出回到低电平，放电二极管截止。 ","date":"2022-01-02","objectID":"/555timer/:4:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"仿真验证 使用Multisim仿真，电路如下： 选用回弹式开关使输入信号在电容充电完毕之前回到高电平，以便于从示波器图形上测得充电时间。 仿真结果： 电路行为与理论分析一致，根据理论分析公式 $\\mathrm{t}_{\\mathrm{w}}=1.1 \\times 10 \\mathrm{k} \\times 4.7 \\mathrm{u}=51.7 \\mathrm{~ms} $,仿真测得充电时间为50.94ms，且充满后电压为2.985V，与理论分析相符的很好。 ","date":"2022-01-02","objectID":"/555timer/:4:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"总结 该单稳态触发器的功能总结为：将低电平脉冲信号（持续时间小于1.1RC）转化为持续时间为1.1RC的高电平信号，持续时间大于1.1RC的话，就只是由低电平转化为高电平。 ","date":"2022-01-02","objectID":"/555timer/:4:3","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"结束语 ","date":"2022-01-02","objectID":"/555timer/:5:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"参考文献 555定时器及应用 电压比较器_百度百科 555定时器_百度百科 NE555P_立创商城 ","date":"2022-01-02","objectID":"/555timer/:5:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"备注 仿真文件及数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-02","objectID":"/555timer/:5:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":null,"content":"关于我是谁 20岁 北京邮电大学19级信息工程专业本科生 技能点主要是软件定义网络（SDN，software defined network）、电子设计以及Python ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"多说几句 不管任何行业，劣币驱逐良币是很常见的事情，我希望我能永远忠于技术、遵守开源精神。 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"友链 lgt的博客：https://ayamir.github.io/ 黄鸡的博客：https://hyiker.com/ ClSlaid的博客：https://clslaid.icu/ liCheng前辈的博客：http://www.muzixing.com/ 广告位招租 ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"}]