[{"categories":["SDN"],"content":"SDN十篇推荐论文 推荐论文来自BUPT课程“软件定义网络” ","date":"2022-06-27","objectID":"/sdn_paper_recom/:0:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(1988)The Design Philosophy of the DARPA Internet Protocols DARPA互联网协议的设计哲学 ​ Internet 协议套件 TCP/IP 于 15 年前首次提出。 它由国防高级研究计划局 (DARPA) 开发，并已广泛用于军事和商业系统。 虽然有描述协议如何工作的论文和规范，但有时很难从中推断出协议为何如此。 例如，Internet 协议基于无连接或数据报服务模式。 这样做的动机被大大误解了。 本文试图捕捉形成 Internet 协议的一些早期推理。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:1:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2005)Overcoming the Internet Impasse through Virtualization 通过虚拟化克服互联网僵化 当前的互联网陷入僵局，因为新架构无法部署，甚至无法进行充分评估。 本文敦促社区正视这一僵局，并提出一种可以使用虚拟化来克服它的方法。 在这个过程中，我们讨论了建筑的本质以及纯粹主义者和多元主义者之间的争论。 提出使用网络虚拟化技术改变互联网技术革新模式。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:2:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2005)A Clean Slate 4D Approach to Network Control and Management 网络控制和管理的全新 4D 方法 ​ 当今的数据网络异常脆弱且难以管理。我们认为，这些问题的根源在于控制和管理平面的复杂性——协调网络元素的软件和协议——尤其是决策逻辑和分布式系统问题不可避免地交织在一起的方式。我们提倡对功能进行完全重构，并提出三个关键原则——网络级目标、网络范围的视图和直接控制——我们认为这些原则应该是新架构的基础。遵循这些原则，我们在架构的四个平面（决策、传播、发现和数据）之后确定了一个我们称之为“4D”的极端设计点。 4D 架构将 AS 的决策逻辑与管理网络元素之间交互的协议完全分开。 AS 级目标在决策平面中指定，并通过直接配置驱动数据平面如何转发数据包的状态来强制执行。在 4D 架构中，路由器和交换机只是按照决策平面的要求转发数据包，并收集测量数据以帮助决策平面控制网络。尽管 4D 会对当今的控制和管理平面进行重大更改，但数据包的格式不需要更改；这简化了 4D 架构的部署路径，同时仍然实现了网络控制和管理方面的重大创新。我们希望探索一个极端的设计点将有助于将研究和工业界的注意力集中在这个至关重要且具有智力挑战性的领域上。 解决现有互联网问题的最大困难是分布式系统问题和决策逻辑缠绕在一起。 4D技术路线的要义就是分离分布式计算问题(Distributed Computing Issue) 和组网逻辑问题(Networking Issue)。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:3:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2007)Ethane: Taking Control of the Enterprise 早期SDN原型 本文介绍了 Ethane，一种适用于企业的新网络架构。 Ethane 允许管理人员定义一个单一的网络范围的细粒度策略，然后直接执行它。 Ethane 将极其简单的基于流的以太网交换机与管理流的准入和路由的集中控制器相结合。 虽然激进，但这种设计向后兼容现有的主机和交换机。 我们已经在硬件和软件中实现了 Ethane，支持有线和无线主机。 在过去的四个月里，我们运营的 Ethane 网络在斯坦福大学的网络中支持了 300 多台主机，这种部署经验对 Ethane 的设计产生了重大影响。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:4:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2008)OpenFlow: Enabling Innovation in Campus Networks ​ 本白皮书提出了 OpenFlow：一种供研究人员在他们每天使用的网络中运行实验协议的方法。 OpenFlow 基于以太网交换机，具有内部流表和用于添加和删除流条目的标准化接口。我们的目标是鼓励网络供应商将 OpenFlow 添加到他们的交换机产品中，以部署在大学校园骨干网和配线间中。我们认为 OpenFlow 是一种务实的折衷方案：一方面，它允许研究人员以统一的方式以线速和高端口密度在异构交换机上运行实验；另一方面，供应商不需要公开其交换机的内部工作原理。除了允许研究人员在现实世界的流量设置中评估他们的想法外，OpenFlow 还可以作为一个有用的校园组件，用于提议的大规模测试平台（如 GENI）。斯坦福大学的两座建筑物将很快使用商用以太网交换机和路由器运行 OpenFlow 网络。我们将努力鼓励在其他学校部署；我们鼓励您也考虑在您的大学网络中部署 OpenFlow。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:5:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2013)On Scalability of Software-Defined Networking 论软件定义网络的可扩展性 在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是 SDN 独有的。 我们探讨了不同环境中经常出现的问题，讨论了 SDN 设计空间中的可扩展性权衡，并介绍了一些关于 SDN 可扩展性的最新研究。 此外，我们列举了超出常用性能指标的可扩展性方面被忽视但重要的机遇和挑战。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:6:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2013)Improving Network Management with Software Defined Networking 使用软件定义网络改进网络管理 ​ 网络管理具有挑战性。为了操作、维护和保护通信网络，网络运营商必须处理低级别的供应商特定配置，以实施复杂的高级网络策略。尽管之前提出了许多使网络更易于管理的建议，但由于难以改变底层基础设施，许多网络管理问题的解决方案都只是权宜之计。底层基础设施的僵化几乎没有创新或改进的可能性，因为网络设备通常是封闭的、专有的和垂直集成的。一种新的网络范式，软件定义网络（SDN），主张将数据平面和控制平面分离，使数据平面中的网络交换机成为简单的数据包转发设备，并留下一个逻辑集中的软件程序来控制整个网络的行为。 SDN 为网络管理和配置方法引入了新的可能性。在本文中，我们确定了当前最先进的网络配置和管理机制存在的问题，并介绍了改进网络管理各个方面的机制。我们关注网络管理中的三个问题：实现网络条件和状态的频繁更改，以高级语言提供网络配置支持，以及为执行网络诊断和故障排除的任务提供更好的可见性和控制。我们描述的技术使网络运营商能够以高级策略语言实施广泛的网络策略，并轻松确定性能问题的根源。除了系统本身，我们还描述了校园和家庭网络中的各种原型部署，展示了 SDN 如何改进常见的网络管理任务。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:7:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2014)A Survey of Software-Defined Networking: Past, Present, and Future of Programmable Networks 软件定义网络调查：可编程网络的过去、现在和未来 综述了可编程网络的最新进展，重点介绍了SDN。提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:8:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2014)Software-Defined Networking: A Comprehensive Survey 在本文中，我们对 SDN 进行了全面调查。我们首先介绍 SDN 的动机，解释它的主要概念以及它与传统网络的区别、它的根源以及关于这种新颖范式的标准化活动。接下来，我们使用自下而上的分层方法展示 SDN 基础设施的关键构建块。我们对硬件基础设施、南向和北向 API、网络虚拟化层、网络操作系统（SDN 控制器）、网络编程语言和网络应用程序进行了深入分析。我们还研究了调试和故障排除等跨层问题。为了预测这种新范式的未来发展，我们讨论了 SDN 的主要正在进行的研究工作和挑战。特别是，我们解决了交换机和控制平台的设计——重点关注弹性、可扩展性、性能、安全性和可靠性等方面——以及运营商传输网络和云提供商的新机遇。最后但同样重要的是，我们分析了 SDN 作为软件定义环境的关键推动者的地位。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:9:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["SDN"],"content":"(2014)P4: Programming Protocol-Independent Packet Processors P4：编写协议无关的包处理器 ​ P4 是一种用于编程独立于协议的包处理器的高级语言。 P4 与 OpenFlow 等 SDN 控制协议结合使用。 在目前的形式中，OpenFlow 明确指定了它所操作的协议头。 这组在几年内从 12 个字段增长到 41 个字段，增加了规范的复杂性，同时仍然不能提供添加新标头的灵活性。 在本文中，我们提出 P4 作为 OpenFlow 未来应该如何发展的草案建议。 我们有三个目标： (1) 现场可重构性：一旦部署，程序员应该能够改变交换机处理数据包的方式。 (2) 协议独立性：交换机不应与任何特定的网络协议绑定。 (3) 目标独立性：程序员应该能够独立于底层硬件的细节来描述数据包处理功能。 作为示例，我们描述了如何使用 P4 来配置交换机以添加新的分层标签。 ","date":"2022-06-27","objectID":"/sdn_paper_recom/:10:0","tags":["SDN","Paper"],"title":"SDN十篇推荐论文","uri":"/sdn_paper_recom/"},{"categories":["Note"],"content":" 起因是看到了三位大佬的工程https://github.com/Direktor799/rusted_os/commits/main，非常的赏心悦目，才知道commit也有固定的格式 Commit Message格式，目前规范使用较多的是 Angular 团队的规范, 继而衍生了 Conventional Commits specification. 很多工具也是基于此规范, 它的 message 格式如下: Commit格式包含三个部分，Header、Body、Footer \u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e\r\u003cBLANK LINE\u003e\r\u003cbody\u003e\r\u003cBLANK LINE\u003e\r\u003cfooter\u003e\r 首行header：必填，描述修改类型和内容 scope：commit影响的范围 subject：commit的概述 body：commit具体修改的内容 footer：备注，通常是 BREAKING CHANGE 或修复的 bug 的链接. ","date":"2022-06-14","objectID":"/git_commit_format/:0:0","tags":["Git"],"title":"git使用笔记——commit格式","uri":"/git_commit_format/"},{"categories":["Note"],"content":"Header Header只有一行，包括三个字段type（必填）scope（可选）subject（必填） type 说明commit的类别 feat：新增功能 fix：bug 修复 docs：文档更新 style：不影响程序逻辑的代码修改(修改空白字符，格式缩进，补全缺失的分号等，没有改变代码逻辑) refactor：重构代码(既没有新增功能，也没有修复 bug) perf：性能, 体验优化 test：新增测试用例或是更新现有测试 build：主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交 ci：主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交 chore：不属于以上类型的其他类，比如构建流程, 依赖管理 revert：回滚某个更早之前的提交 scope 说明commit影响的范围，比如文件或者逻辑层。 subject commit简述 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） ","date":"2022-06-14","objectID":"/git_commit_format/:0:1","tags":["Git"],"title":"git使用笔记——commit格式","uri":"/git_commit_format/"},{"categories":["Note"],"content":"Body commit详细描述 ","date":"2022-06-14","objectID":"/git_commit_format/:0:2","tags":["Git"],"title":"git使用笔记——commit格式","uri":"/git_commit_format/"},{"categories":["Note"],"content":"Footer 只用于两种情况 不兼容变动 关闭Issue ","date":"2022-06-14","objectID":"/git_commit_format/:0:3","tags":["Git"],"title":"git使用笔记——commit格式","uri":"/git_commit_format/"},{"categories":["Paper"],"content":"摘要 ​ 我们引入了Oracle-MNIST数据集，包括10个类别的30222个古代字符的28×28灰度图像，用于基准模式分类，特别是图像噪声和失真方面的挑战。训练集共有27222张图像，测试集每个类有300张图像。Oracle-MNIST与原始MNIST数据集共享相同的数据格式，允许与所有现有的分类器和系统直接兼容，但它构成了比MNIST更具挑战性的分类任务。由于三千年的埋藏和老化，古文字的形象受到了极其严重和独特的噪音影响，以及古文字的书写风格的巨大变化，这些都使其具有机器学习研究的现实感。该数据集可以在https://github.com/wm-bupt/oracle-mnist上免费获得。 ","date":"2022-06-12","objectID":"/oracle-mnist/:1:0","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"1 引言 ​ 在过去的几年里，由于专门的数据集作为实验测试平台和当前进展的公共基准的发布，机器学习(ML)取得了快速的进展，从而集中了研究社区的努力。计算机视觉中最广为人知的数据集是MNIST数据集，该数据集于1998年由LeCun等人(1998)首次引入。MNIST是一个10类数字分类数据集，由60,000张用于训练的灰度图像和10,000张用于测试的灰度图像组成。整个数据集相对较小，可以自由访问和使用，并以完全直接的方式进行编码和存储，这几乎肯定有助于它的广泛使用。 ​ 然而，随着改进学习算法的发现，MNIST的性能已经饱和。例如，卷积神经网络(CNNs) (Krizhevsky等人，2012;He et al.， 2016)可以轻松达到99%以上的准确率。这部分归因于基准测试没有捕获许多真实场景的需求。为了避免饱和性能并为改进的ML算法提供挑战，构建了一些改进的MNIST数据集，例如EMNIST (Cohen等人，2017)和fashionn -MNIST (Xiao等人，2017)。EMNIST通过引入大写和小写字符扩展了类的数量，但额外的类需要改变MNIST使用的深度神经网络的框架。fashion - mnist包含10级时尚产品的7万张灰度图像。这些产品图片来源于Zalando的网站e1，由专业摄影师拍摄，清晰规范。然而，它未能在现实世界中尽可能广泛地捕捉各种变化。 ​ 本文的目的是提供一个真实且具有挑战性的数据集Oracle-MNIST，以方便ML算法对真实的古代字符图像进行简单快速的评估。oracle - mnist包含属于10个类别的oracle字符的30222个图像。 真实世界的挑战。 与手写数字不同，甲骨文字符是从真实的甲骨文表面扫描而来。因此，Oracle-MNIST由于数千年的埋藏和老化而产生了极其严重和独特的噪音，并且在每个类别中都包含着各种各样的写作风格，这都使得ML研究更加现实和困难。 易用性。 与原来的MNIST相同，图像在Oracle-MNIST有28×28灰度像素。它可以立即兼容任何能够与MNIST数据集工作的ML包，因为它共享相同的数据格式。事实上，使用这个数据集需要做的唯一更改就是更改获取MNIST数据集的URL。 ","date":"2022-06-12","objectID":"/oracle-mnist/:2:0","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"2 Oracle-MNIST 数据集 ","date":"2022-06-12","objectID":"/oracle-mnist/:3:0","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"2.1甲骨文字符发现 ​ 古代史依赖于对古文字的研究。甲骨文是中国最古老的象形文字(Flad et al.， 2008;Keightley, 1997)，近三千年的历史，为现代文明做出了巨大的贡献，使中华文化得以代代相传，成为唯一延续至今的文明。如图1所示，甲骨文被镌刻在龟甲和兽骨上，记录了商朝(公元前1600-1046年)的生活和历史，包括占卜、征战、狩猎、医疗和生育等。1899年，清朝(1644-1911)，一位名叫王希荣的商人首次发现了它们。20世纪初，中国的研究人员在商朝都城河南安阳的小屯村发掘了大量的甲骨文。此后，甲骨文文字的研究备受关注。它对于中国的词源学和书法，以及学习中国古代乃至世界的文化和历史都具有重要的意义。 ​ 甲骨文字符大多采用扫描图像存储，扫描图像是将一张纸盖在主体上，然后用卷墨拓印，再现甲骨文表面，如图2(a)所示。识别这些甲骨文字符对专家和机器来说都很困难。到目前为止，已经发现了近4500个不同的甲骨文字符，但只有大约2200个字符被成功破译。原因如下。(1)磨损和噪声。几个世纪以来，许多甲骨铭文遭到破坏，它们的文字现在已经残缺不全。铭文的老化过程也使其不易辨认，因此扫描的文字破损，并含有严重的噪音。(2)大方差。不同的写作风格导致了类内的高度差异。如图2(b)所示，属于同一类别的字符在笔画甚至拓扑结构上都存在较大差异。不同类别的一些字符彼此相似，这给识别带来了很大的困难。例如，图2(c)和图2(d)所示的“木”和“牛”两个类别的字符仅在一些小细节上有所不同。 ","date":"2022-06-12","objectID":"/oracle-mnist/:3:1","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"2.2 数据集的细节 ​ Oracle-MNIST是基于殷奇文苑网站的集合。这些甲骨文字是从真实的甲骨文表面扫描而来的，因此会出现破碎和噪音严重的现象。每个扫描图像的中心都有一个字符。大多数原始图像都有灰色或黑色背景，分辨率也各不相同。 ​ 我们选择了10个类的30222个常用字符构建Oracle-MNIST。然后将原始图像送入下面的转换管道，如图3所示。我们还试图通过一些图像增强技术，如灰度拉伸和直方图均衡化来处理图像。虽然成功地提高了图像的视觉质量，但识别性能略有下降。因此，Oracle-MNIST并没有采用图像增强技术。我们还提供原始图像，并将数据处理工作留给算法开发人员。 将图像转换为8位灰度像素。 如果前景比背景暗，则取消图像的强度。 使用双三次插值算法将图像的最长边缘调整为28。 将最短的边延长到28，并将图像放到画布的中心。 ​ 我们利用字符的含义作为它们的类标签。这些标签是由考古学或古生物学专家手工标注的。表2给出了Oracle-MNIST中所有类标签的总结，并给出了每个类的示例。 ​ 最后，我们将数据集分为训练集和测试集，并确保它们是不相交的。训练集由随机选取的27222张图像组成，测试集每类包含300张图像。图像和标签以与MNIST数据集相同的文件格式存储，MNIST数据集是为存储向量和多维矩阵而设计的。表1列出了结果文件。 ","date":"2022-06-12","objectID":"/oracle-mnist/:3:2","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"3 实验 ​ 我们在Oracle-MNIST上评估了一些不同参数的算法，结果如表3所示。对于每种算法，通过三次重复实验报告了平均分类精度。MNIST和Fashion-MNIST数据集上的基准也包括在并排比较中。 ​ 从结果中，我们有以下观察结果。首先，经典(浅层)ML算法在MNIST数据集上可以轻松实现97%，这证明了MNIST算法太容易评估。我们的Oracle-MNIST数据集提供了10类古代字符的图像，并进一步捕捉了现实世界中尽可能广泛的变化，这比MNIST数字数据和Fashion-MNIST数据提出了更具有挑战性的分类任务。我们可以看到，所有经典的(浅)ML算法在MNIST上表现最好，其次是fashionmnist，在oracle MNIST上表现最差。例如，随机森林分类器的准确率分别为97.1%、87.1%和64.9%。这是因为上文2.1节所述的类内方差和类间相似度较高，会给分类带来很大的困难。此外，由于模糊、噪声和遮挡等原因，扫描到的甲骨文图像会严重退化，甚至完全失去识别字形信息。 ​ 其次，CNN优于Oracle-MNIST上所有的经典(浅)ML算法。得益于局部接收场和空间或时间子采样，CNN可以强制提取局部特征，降低输出对位移和失真的敏感性(LeCun et al.， 1995)。因此，现实世界的挑战，如不同的写作风格，噪音和闭塞，可以在一定程度上解决。然而，Oracle-MNIST上的性能还没有饱和。本文使用的CNN在Oracle-MNIST上的错误率为6.2%，还有改进的空间。尽管CNN具有强大的表示能力，但是识别这些古文字的问题还有待完全解决。 ","date":"2022-06-12","objectID":"/oracle-mnist/:4:0","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"4 结论 ​ 在本文中，我们提出了一个现实的和具有挑战性的基准数据集，即Oracle-MNIST。它包含10类30222个古文字的28×28灰度图像，用于对计算机视觉中的图像噪声和失真的鲁棒性进行基准测试。Oracle-MNIST被转换成一种与构建来处理MNIST数据集的分类器直接兼容的格式。由于数千年的埋藏和老化，这些古老的文字噪音大，书写风格各异，给识别带来了很大的困难。基准测试结果表明，古文字分类任务确实更具挑战性。 ","date":"2022-06-12","objectID":"/oracle-mnist/:5:0","tags":["Paper"],"title":"论文笔记——Oracle-MNIST：a Realistic Image Dataset for Benchmarking Machine Learning Algorithms","uri":"/oracle-mnist/"},{"categories":["Paper"],"content":"AMM: Attentive Multi-field Matching for News Recommendation ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:0:0","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"论文概况 https://dl.acm.org/doi/abs/10.1145/3404835.3463232 SIGIR ‘21: Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval July 2021 Pages 1588–1592 https://doi.org/10.1145/3404835.3463232 自翻：https://github.com/leeshy-tech/PaperTranslate/blob/main/AMMAttentive_Multi-field_Matching.md ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:1:0","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"引言 ​ 用户兴趣与候选新闻的准确匹配是准确的个性化新闻推荐的前提。现有的方法主要是通过顺序或注意力模型聚合用户之前浏览过的新闻来学习用户的兴趣向量，然后将其与候选新闻向量进行匹配，取得了相当大的进展。例如，NPA [12] 根据候选新闻和之前点击的新闻之间的相似性来学习用户表示。 LSTUR [1] 使用 GRU 网络从点击的新闻中模拟短期和长期的用户兴趣。 NAML [11] 和 NRMS [13] 应用注意力网络从点击的新闻中学习用户表示。 FIM [9] 为每个新闻提取多级表示，并通过卷积执行细粒度匹配。然而，这些方法中的大多数将每个用户和新闻表示为单个向量，这可能会丢失文本匹配信号（例如，词级关系）。因此，我们的方法不是简单地将用户浏览的新闻建模为一个整体，而是关注每个浏览的候选新闻对之间的关系，以捕获细粒度的语义匹配表示。此外，这种对设计是在线服务友好的，匹配的表示可以离线存储，以避免重复计算。在这里，我们首先使用 BERT 来学习每个浏览候选新闻对在不同语义级别的匹配表示，然后将它们聚合到最终的用户新闻匹配信号。 ​ 此外，上述方法基于单视图新闻信息[1,9,13]或多视图信息[11]学习新闻之间的语义相关性，它们仅利用字段内语义相关性（例如，标题-标题，正文-正文）。 但有时，跨领域信息（例如标题-摘要、标题-正文）可能有利于新闻匹配。 比如新闻𝑎的标题信息丰富，而新闻𝑏的标题很吸引人，新闻𝑎的标题和新闻𝑏的正文匹配可能更好。 因此，与每条新闻相关的多个字段可能包含互补信息，这些信息促使我们学习多字段（字段内和跨字段）匹配表示。 ​ 在本文中，我们提出了一种注意力多字段匹配（AMM）框架，该框架捕获每个浏览候选新闻对的多字段语义匹配表示，然后将这些表示聚合为最终的用户新闻匹配信号，用于新闻推荐。 这项工作的主要贡献总结如下： 我们提出了一种新的方法，专注于分离的浏览候选新闻对的匹配，以捕获文本语义匹配信号，这对在线服务很友好。 我们设计了 AMM 框架，以在领域内和跨领域的方式中提取多领域匹配表示，以深入探索用户的兴趣。 我们对两个公共基准数据集进行了实验，以证明我们方法的有效性。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:2:0","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"我们的方法 图 1 显示了 AMM 的整体架构。 首先，我们为每个浏览的候选新闻构建多字段对输入。 然后，匹配编码器用于提取每对输入的匹配表示。 最后，我们将所有对的匹配表示聚合到用户新闻信号以估计点击概率。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:3:0","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"2.1 多头部匹配 ​ 不同的新闻字段通常可以相互补充。 为了更好地编码浏览-候选匹配，我们利用字段内和跨字段匹配作为多字段信息来增强匹配表示。 ​ 给定用户浏览的新闻$\\left[N_{1}, N_{2}, \\ldots, N_{i}\\right]$和候选新闻$N_x$，对于每个浏览-候选对$\\left(N_{i}, N_{c}\\right)$，我们建立多头部对输入$\\left[N_{i}^{m}, N_{c}^{n}\\right]$，其中$m \\in{t, a, b},n \\in{t, a, b}$，t、a、b分别是新闻的标题、摘要、主体。我们将新闻标题$N^t$表示为词向量$\\left[w_{1}^{t}, w_{2}^{t}, \\ldots, w_{\\left|N^{t}\\right|}^{t}\\right]$，新闻摘要$N^a$表示为$\\left[w_{1}^{a}, w_{2}^{a}, \\ldots, w_{|N a|}^{a}\\right]$，新闻主体$N^b$表示为$\\left[w_{1}^{b}, w_{2}^{b}, \\ldots, w_{\\left|N^{\\prime}\\right|}^{b}\\right]$，其中$\\left|N^{t}\\right|\\left|N^{a}\\right|$和$\\left|N^{b}\\right|$分别表示标题、摘要、主体的长度。 ​ 在这项研究中，如图 1 所示，不仅像$\\left[N_{i}^{t}, N_{c}^{t}\\right]$（标题和标题）这样的字段内对输入，而且像$\\left[N_{i}^{t}, N_{c}^{b}\\right]$（标题和正文）这样的跨字段对输入都被获得 ，这些输入对中的每一个都被馈送到匹配编码器以获得其匹配表示。 我们最终将这些表示串接为浏览候选新闻对的多字段匹配表示。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:3:1","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"2.2 匹配编码器 该模块用于学习每个浏览过的新闻和候选新闻之间的语义匹配。 我们将来自多字段匹配的浏览-候选多字段对作为输入，然后将其输入到来自 Transformers (BERT) [4] 的双向编码器表示中，以进行匹配表示学习。 多头部自注意层 该子层旨在捕获句子的上下文感知语义匹配。 使用多头，来自不同位置的不同语义子空间的信息是可联合学习的，这对于捕获不同标记之间的匹配信号非常有帮助。 位置智慧型前馈网络 这个子层的目的是赋予模型非线性和不同维度之间的相互作用，这是一个完全连接的前馈网络(FFN)，它由两个线性变换组成，中间有一个ReLU激活。 另外，对每个子层进行残差连接和层归一化处理。最后，我们可以通过该匹配编码器得到每个浏览-候选新闻的多字段对的匹配表示。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:3:2","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"2.3 匹配聚合器 ​ 匹配聚合器用于聚合每个浏览新闻和候选新闻的匹配表示，以获得最终的用户新闻匹配信号。我们使用以下三种类型的聚合器获得最终的用户新闻匹配表示$\\tilde{M}$： 最大/平均聚合器：对的匹配嵌入直接取最大或平均作为用户-新闻匹配嵌入。 $$ \\tilde{M}=\\text { Aggregate }(M)=\\max / \\operatorname{mean}(M)\\tag 5 $$ 注意力聚合器：使用门限注意网络 [2] 来学习 𝑀 的组合权重，它应用具有$W_h$和$b_h$的全连接神经网络，使用 tanh 作为第一层激活函数，然后使用$W_o$和$b_o$构造第二个全连接神经网络来学习在等式（6）中定义的组合权重 𝑟 ，最后在等式（7）中计算词向量的线性组合。 $$ \\tilde{M}=\\text { Aggregate }(M)=\\mathbf{r}^{\\top} M\\tag 6 $$ $$ r=\\operatorname{softmax}\\left(\\tanh \\left(\\tilde{E} W_{h}+b_{h}\\right) W_{o}+b_{o}\\right)\\tag 7 $$ ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:3:3","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"2.4 点击预测 最后，我们介绍点击预测模块。 将用户-新闻匹配表示表示为$\\tilde{M}$，点击概率 𝑦 通过应用全连接层计算： $$ y=\\operatorname{softmax}\\left(\\tilde{M} W^{o}+b^{o}\\right)\\tag 8 $$ 其中$W^{o} \\in \\mathbb{R}^{d^{\\prime} \\times 1}$和$b^{o} \\in \\mathbb{R}^{1}$是可学习参数。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:3:4","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"3 实验 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:4:0","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"3.1 实验设置 数据集 MIND Adressa 评价指标 ​ 我们使用 AUC、MRR、nDCG@𝐾，其中𝐾 = 5, 10 用于 MIND，𝐾 = 1, 3 用于 Adressa，作为我们的评估指标。 性能是所有展示日志中这些指标的平均值。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:4:1","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"3.2 性能评估 ​ 我们通过将 AMM 与几种基准方法进行比较来评估 AMM 的性能， LibFM [8]，分解机（FM）； DeepFM[6]：一种结合了FM和神经网络的深度分解机； DKN[10]，一种基于知识感知CNN的深度新闻推荐方法； NPA[12]，引入注意力机制来选择重要的词和新闻； NAML [11]，一种具有注意力多视图学习的神经新闻推荐方法； LSTUR [1]，它使用 GRU 从点击历史中对短期和长期兴趣进行建模； NRMS [13]，它使用多头自注意力来学习用户和新闻表示； FIM[9]，一种用于神经新闻推荐的细粒度兴趣匹配方法； AMM，我们的方法。 使用深度神经网络提取新闻语义表示的方法（3-8）比基于特征的方法（1-2）表现更好。这种性能改进应归功于更好的新闻表示方法。 在方法（3-8）中，NAML 在 MIND 中表现最好，NRMS 在 Adressa 中表现最好，这是因为 NAML 使用了不同种类的新闻信息，而 NRMS 应用了多头自注意力来进一步捕捉单词和点击新闻互动。 FIM 在所有基线中的 Adressa 中表现最好，因为它可以捕获更细粒度的兴趣匹配信号。 我们提出的 AMM 通过考虑分离的浏览候选新闻对和跨字段匹配来捕获多字段的更好的文本语义匹配，在所有指标方面在两个数据集上实现了最佳性能。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:4:2","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"3.3 消融实验 比较了AMM与三个单一字段(标题、摘要、正文)在MIND上的性能。 带有标题和正文的AMM的表现优于带有摘要的AMM，这表明标题和正文比摘要更有利于新闻表征。 此外，单个标题或正文的AMM的性能优于最佳基准，表明了分离策略引入文本语义匹配的必要性。 通过实验验证了多领域匹配的有效性。 AMM多字段比AMM内字段性能更好，这可能是因为通过跨字段匹配可以融合更多的互补信息，字段内和多字段信息的集成可以提高用户新闻匹配，捕捉细粒度用户的兴趣。 探讨了不同匹配聚合器的有效性。 我们可以看到带有注意力聚合器的 AMM 的性能略好于带有最大+平均池化的 AMM。 而且，最大+平均池化的表现也比 最佳基准方法好很多，验证了多字段语义匹配的有效性，这些简单的操作让在线服务更有可能。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:4:3","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"结论 ​ 在本文中，我们提出了一种新颖的注意力多领域匹配（AMM）新闻推荐框架。 我们建议以新闻分离的方式学习用户-新闻匹配表示，捕获每对浏览候选新闻的匹配表示，然后将这些表示聚合为最终匹配信号，从而获得细粒度的语义匹配信息以及它是在线服务友好的。 此外，我们的方法同时考虑了字段内和跨字段作为多字段匹配，利用了字段间的互补信息，提高了新闻对的匹配表示。 两个公共基准数据集的实验结果证明了 AMM 的最新性能。 ","date":"2022-05-24","objectID":"/ammattentive_multi-field_matching/:5:0","tags":["News Recommendation","Paper"],"title":"论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching","uri":"/ammattentive_multi-field_matching/"},{"categories":["Paper"],"content":"Personalized News Recommendation with Knowledge-aware Interactive Matching 基于知识感知交互匹配的个性化新闻推荐 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:0:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"论文概况 https://dl.acm.org/doi/abs/10.1145/3404835.3462861 SIGIR ‘21: Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval July 2021 Pages 61–70 https://doi.org/10.1145/3404835.3462861 自翻：https://github.com/leeshy-tech/PaperTranslate/blob/main/Personalized_news_recommendation.md ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:1:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"摘要 ​ 在本文中，我们提出了一种用于新闻推荐的知识感知交互式匹配方法。我们的方法以交互方式对候选新闻和用户兴趣进行建模，以促进它们的准确匹配。我们设计了一个知识感知新闻协同编码器，在知识图谱的帮助下捕获它们在语义和实体中的相关性，交互式地学习点击新闻和候选新闻的表示。我们还设计了一个用户新闻协同编码器来学习候选新闻感知用户兴趣表示和用户感知候选新闻表示，以实现更好的兴趣匹配。在两个真实世界数据集上的实验验证了，我们的方法可以有效地提高新闻推荐的性能。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:2:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"1 引言 ​ 现有方法通常根据其文本信息对候选新闻进行建模，并以独立的方式从用户的点击历史中推断出用户兴趣[21, 37]。 候选新闻文章可能包含多个方面和实体 [18、33]，并且用户可能有多个兴趣 [32]。 因此，候选新闻和用户兴趣的独立建模可能不如兴趣匹配[31]。 ​ 在本文中，我们探索更好地模拟候选新闻和用户兴趣之间的相关性，以实现准确的兴趣匹配。 我们的论文受到以下观察的启发。 候选新闻可能涵盖不同的方面和实体，并且用户可能有多种兴趣。 例如，图中 候选新闻2 与篮球明星和政治家有关，含有多个实体（库里和特朗普）。示例用户对车、音乐、体育等领域感兴趣，第二个候选新闻只能匹配特定的用户兴趣即“体育”，但是用户可能只对实体“库里”感兴趣。所以如果独立建模，用候选新闻匹配用户兴趣的效果是较差的。 候选新闻和点击新闻的语义匹配有助于更准确地进行兴趣匹配。 例如，第二条点击新闻也与第一条候选新闻有语义相关性，因为它们提到了相同的事件。基于这些语义相关性，我们可以推断用户可能对第一个候选新闻感兴趣。 借助知识图谱，点击新闻和候选新闻中实体之间的知识匹配也有助于了解用户对候选新闻的兴趣。 例如，第 4 条点击新闻中的实体“史蒂夫·科尔”与第 2 条候选新闻中的实体“斯蒂芬·库里”具有内在关联，因为前者和后者分别是“NBA”勇士队的球员和教练。根据知识匹配，我们可以推断出用户可能对第二个候选新闻感兴趣。因此，在语义和知识层面利用点击新闻和候选新闻之间的相关性有利于兴趣匹配。 ​ 在本文中，我们提出了一种用于个性化新闻推荐的知识感知交互式匹配框架（命名为KIM）。我们的方法可以交互地对候选新闻和用户兴趣进行建模，以学习候选新闻感知的用户兴趣表示和用户感知的候选新闻表示，从而更准确地匹配用户兴趣和候选新闻。在该框架中，我们提出了一种知识协同编码器，借助知识图谱从点击新闻中的实体与候选新闻中的实体之间的相关性来建模用户对候选新闻的兴趣。 ​ 更具体地说，我们 首先提出了一个图协同注意网络（ graph co-attention network）： 它通过选择和聚合对兴趣匹配有用的邻居，从知识图谱中学习实体的表示。 进一步提出了使用实体协同注意力网络（ entity co-attention network）： 它通过捕获实体之间的相关性来交互式地学习点击新闻和候选新闻的基于知识的表示。 提出了一种语义协同编码器（ semantic coencoder）： 通过对文本之间的语义相关性进行建模，交互式地学习用户点击新闻和候选新闻的基于语义的表示。新闻的统一表示被表述为基于知识和语义的表示的聚合。 进一步提出了一种用户新闻联合编码器（ user-news co-encoder）： 用于从点击新闻和候选新闻的表示中构建候选新闻感知的用户兴趣表示和用户感知的候选新闻表示，以更好地模拟用户对候选新闻的兴趣。最后，根据候选新闻的表示与用户兴趣之间的相关性对候选新闻进行排名。 我们对两个真实的数据集进行了广泛的实验，并表明我们的方法可以有效地提高新闻推荐的性能并优于其他基准方法。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:3:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"2 相关的工作 ​ 现有方法通常通过内容对候选新闻进行建模，并根据点击新闻独立建模用户兴趣，然后根据候选新闻和用户兴趣的相关性进行匹配。 只有一部分候选新方面和用户兴趣对匹配用户兴趣和候选新闻有用。然而，这些方法独立地对候选新闻和用户兴趣进行建模，这对于进一步的兴趣匹配可能较差。与这些方法不同的是，在 KIM 方法中，我们提出了一个知识感知的交互式匹配框架，在考虑相关性的情况下对候选新闻和用户兴趣进行交互建模，可以更好地将用户兴趣与候选新闻进行匹配。 ​ 一些方法以候选感知的方式模拟用户兴趣。事实上，候选新闻可能包含多个方面和实体，其中只有一部分可能与用户兴趣相匹配。然而，这些方法在没有考虑目标用户的情况下对候选新闻进行建模，这对于进一步将用户兴趣与候选新闻进行匹配可能较差。与这些方法不同，我们的 KIM 方法在考虑目标用户的情况下对候选新闻进行建模。此外，这些方法在没有考虑相关性的情况下对点击新闻和候选新闻进行建模，这对于进一步衡量候选新闻和从点击新闻推断出的用户兴趣之间的相关性也可能不是最优的。与这些方法不同，KIM 可以交互地学习点击新闻和候选新闻的表示，以实现更好的兴趣匹配。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:4:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"3 方法论 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:5:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"问题表述 ​ 给定一个用户𝑢和一个候选新闻$n^c$，我们需要计算相关性分数𝑧来衡量用户𝑢对候选新闻内容$n^c$的兴趣。 然后根据相关性得分对不同的候选新闻进行排名并推荐给用户𝑢。 用户𝑢与他/她点击的新闻集相关联。 每个新闻 𝑛 都与其文本 𝑇 和文本中的实体 𝐸 相关联。 此外，还有一个知识图 G 用于提供实体之间的相关性。 它包含实体和实体之间的关系。 G 中的每个实体 𝑒 与其嵌入相关联，e 基于知识图进行预训练。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:5:1","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"KIM（ Knowledge-aware Interactive Matching）的框架 ​ KIM 包含两个主要模块。： 第一个是知识感知新闻协同编码器（knowledge-aware news co-encoder），它通过捕获语义和知识层面的相关性，交互式地学习用户点击新闻和候选新闻的知识感知表示（ knowledge-aware representations）。 第二个是用户新闻协同编码器（user-news co-encoder），它从上个模块生成的用户点击新闻的表征和候选新闻表征中交互学习候选新闻感知的用户兴趣表征（ candidate news-aware user interest representation）u和用户感知的候选新闻表征（ user-aware candidate news representation）。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:5:2","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"知识感知新闻协同编码器（knowledge-aware news co-encoder） ​ 它从文本和文本中的实体中交互式地学习用户点击的新闻$n_u$和候选新闻$n_c$的表示，它包含三个子模块。 第一个是知识协同编码器（Knowledge co-encoder） 对于点击新闻$n_u$和候选新闻$n_c$，它基于知识图谱从实体之间的相关性中交互式地学习基于知识的表示${k}^{u}$$和 $${k}^{c}$。 它包含三个组件： 图注意网络（ graph attention network） 图协同注意网络（ graph co-attention network） 实体协同注意网络（ entity co-attention network） 第二个是语义协同编码器（semantic co-encoder） 对于点击新闻$n_u$和候选新闻$n_c$，它交互式地学习基于语义的表示${t}^{u}$和${t}^{c}$，以根据文本之间的语义相关性来模拟用户对候选新闻的兴趣。 最后，对于点击新闻$n_u$或候选新闻$n_c$，我们投影其基于知识和语义的表示来学习统一的新闻表示${n}^{u}$或${n}^{c}$。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:5:3","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"用户-新闻 协同编码器 ​ 它从用户点击的新闻和候选新闻的表示中学习候选新闻感知的用户兴趣表示和用户感知的候选新闻表示。 ​ 通常，用户的兴趣是多样的，只有一部分可以与候选新闻匹配[20]。因此，学习候选新闻感知的用户兴趣表示可以更好地建模用户兴趣以匹配候选新闻。 ​ 类似地，候选新闻可能涵盖多个方面，用户可能只对其中的一部分感兴趣 [33, 34]。因此，学习用户感知的候选新闻表示也有利于兴趣匹配。 ​ 因此，我们应用新闻协同注意网络来学习候选新闻感知用户表示和用户感知候选新闻表示。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:5:4","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"实验 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:6:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"数据集 MIND2 Feeds 此外，我们在实验中使用了 WikiData 作为知识图谱。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:6:1","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"性能评估 ​ 我们将 KIM 与几种最先进的个性化新闻推荐方法进行比较，如下所示： EBNR [21]：通过 GRU 网络从用户的点击历史中表示用户兴趣。 DKN [32]：将多通道 CNN 网络 [15] 应用于新闻标题中对齐的单词和实体的嵌入，以学习新闻表示。 DAN [47]：通过 CNN 网络从新闻标题的单词和实体中学习新闻表示，并通过细心的 LSTM 网络 [8] 学习用户兴趣表示。 NAML [33]：通过多个注意力集中的 CNN 网络从新闻标题、正文、类别和子类别中学习新闻表示。 NPA [34]：使用具有个性化注意查询的注意网络来学习新闻和用户表示。 LSTUR [1]：通过 GRU 网络从用户最近点击的新闻中建模短期用户兴趣，并通过用户 ID 嵌入建模长期用户兴趣。 NRMS [37]：通过多头自注意力网络对新闻内容和用户点击行为进行建模。 FIM [31]：通过CNN网络从用户点击新闻和候选新闻的文本中匹配用户和新闻。 KRED [18]：通过图注意力网络从新闻中的实体及其在知识图中的邻居中学习新闻的表示。 ​ 我们重复了五次不同的实验，并在表 2 中列出了不同方法的平均性能和相应的标准差。 KIM 明显优于其他基准方法。 LSTUR、NRMS和KRED这些方法独立地对候选新闻和用户兴趣进行建模，而不考虑它们的相关性。这是因为用户可能对多个领域感兴趣，并且候选新闻也可能包含多个方面和实体。因此，这些方法很难准确匹配用户兴趣和候选新闻，因为它们是在这些方法中独立建模的。 KIM 还优于通过考虑候选新闻来建模用户兴趣的基线方法。 例如 DKN、DAN。这是因为候选新闻可能涵盖多个方面，而用户可能只对其中的一部分感兴趣[33、34]。然而，这些方法在没有考虑目标用户的情况下对候选新闻进行建模，这对于进一步将候选新闻与用户兴趣匹配可能较差。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:6:2","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"消融实验 ​ 进行了两项消融研究来评估 KIM 的有效性。首先评估不同信息（即文本和知识）对新闻内容建模的有效性。 首先，删除语义信息（即新闻文本）会严重损害 KIM 的性能。这是因为文本通常包含有关新闻内容的丰富信息，对于新闻内容的理解至关重要 [45]。去除语义信息会使新闻表示失去很多重要信息，并且不能准确地对新闻内容进行建模。 其次，在新闻内容建模中去除知识图谱（即知识知识图谱中的实体及其邻居）也会使 KIM 的性能显著下降。这是因为文本信息通常不足以理解新闻内容 [18, 32]。幸运的是，知识图谱包含不同实体之间的丰富关联。此外，用户点击新闻中的实体与候选新闻之间的相关性可以提供语义信息之外的丰富信息，以了解用户对候选新闻的兴趣。因此，将实体信息纳入个性化新闻推荐有可能提高推荐的准确性。 ​ 接下来，我们通过分别用注意力网络替换它们来评估 KIM 中几个重要的注意力网络的有效性。 首先，在用户新闻协同编码器中去除新闻关注网络后，KIM 的性能变得更差。这是因为用户兴趣可能是多样的，并且只有一部分用户点击的新闻对于建模用户兴趣和候选新闻之间的相关性是有用的[32]。此外，候选新闻内容可能包含多个方面，用户可能只对其中的一部分感兴趣。因此，通过新闻共同关注网络学习候选新闻感知用户兴趣和用户感知候选新闻表示可以更好地捕捉用户对候选新闻的兴趣。 其次，去除语义协同注意网络也会损害 KIM 的性能。这是因为点击新闻和候选新闻之间的语义相关性可以帮助理解用户对候选新闻的兴趣。此外，一条候选新闻或一条点击新闻通常包含多个方面，其中只有一部分对兴趣匹配有用。如果它们的语义信息是独立建模的，则很难在语义级别有效地捕捉点击新闻和候选新闻的相关性。因此，通过语义共同注意网络交互式学习点击新闻和候选新闻的基于语义的表示可以更好地捕捉它们之间的相关性，以便将用户兴趣与候选新闻匹配。 同时去除图协同注意力网络和实体协同注意力网络会导致 KIM 的性能下降。这是因为实体级别的点击新闻和候选新闻之间的相关性对于兴趣匹配也非常有用。此外，如果该方法独立地表示来自其实体的点击新闻和候选新闻，则对于兴趣匹配也是次优的。在KIM方法中，图协同注意力网络和实体协同注意力网络都用于以交互方式捕捉点击新闻和候选新闻实体之间的相关性，可以将丰富的信息融入KIM模型进行兴趣匹配。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:6:3","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"结论 ​ 在本文中，我们提出了一种用于个性化新闻推荐的知识感知交互式匹配框架（命名为 KIM）。该框架旨在对候选新闻和用户兴趣进行交互建模，以实现更准确的兴趣匹配。更具体地说，我们首先提出了一个图协同注意网络，通过选择和聚合它们的邻居的信息来基于知识图对实体进行建模，这些信息为兴趣匹配提供了丰富的信息。我们还提出使用实体协同注意网络从实体之间的相关性中交互式地对点击新闻和候选新闻进行建模。此外，我们建议使用语义共同注意网络从文本之间的语义相关性中交互式地对点击新闻和候选新闻进行建模。此外，我们提出了一种用户新闻协同编码器来学习候选新闻感知用户表示和用户感知候选新闻表示，以更好地捕捉用户兴趣和候选新闻之间的相关性。我们对两个真实世界的数据集进行了广泛的实验。实验结果表明，我们的 KIM 方法显著优于其他基准方法。 ","date":"2022-05-23","objectID":"/personalized_news_recommendation/:7:0","tags":["News Recommendation","Paper"],"title":"论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching","uri":"/personalized_news_recommendation/"},{"categories":["Paper"],"content":"RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT ","date":"2022-05-23","objectID":"/rmbert/:0:0","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Paper"],"content":"论文概况 https://dl.acm.org/doi/abs/10.1145/3404835.3463234 SIGIR ‘21: Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval July 2021 Pages 1773–1777 https://doi.org/10.1145/3404835.3463234 ","date":"2022-05-23","objectID":"/rmbert/:1:0","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Paper"],"content":"摘要 ​ 现有的方法大多是根据新闻内容将每个用户和新闻分别编码为向量，然后对两个向量进行匹配。但是，用户对每个新闻或新闻的每个主题的兴趣可能是不同的。动态地学习用户和新闻向量，并对他们的互动进行建模是必要的。 ​ 在本研究中，我们提出了基于BERT的循环推理记忆网络(RMBERT)用于新闻推荐。与其他方法相比，我们的方法可以利用BERT的内容建模能力。此外，循环推理记忆网络执行一系列基于注意力的推理步骤，可以动态学习用户和新闻向量，并对每一步的交互进行建模。因此，我们的方法可以更好地模拟用户的兴趣。我们在真实世界的新闻推荐数据集上进行了广泛的实验，结果表明，我们的方法显著优于现有的最先进的方法。 ","date":"2022-05-23","objectID":"/rmbert/:2:0","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Paper"],"content":"1 引言 ​ 最近，一些方法探索使用神经网络以端到端方式学习新闻和用户表示，并在训练过程中优化这些表示。DKN [13]， NPA [15]， LSTUR[1]提出使用CNN学习新闻表示，然后将候选新闻与用户点击的新闻进行匹配。DKN将知识图表示引入新闻推荐。NPA通过嵌入用户ID来关注重要词汇和新闻，增强了新闻和用户表示。LSTUR结合了长期和短期用户表示，以更精确地对用户进行建模。NRMS[16]引入多头自我注意学习新闻表示。FIM[12]通过叠加扩张卷积提取每个新闻的多层表示。 ​ 在新闻推荐场景中有两个常见的观察结果。首先，不同的用户可能对候选人新闻的不同部分感兴趣。第二，用户的兴趣通常是多样化的，用户历史中不同的新闻代表了该用户的不同兴趣。以前的工作 [9, 13, 16] 使用一个固定的嵌入向量来表示用户和新闻，这可能会限制模型的表达能力。作为一个解决方案，我们需要动态地确定关于候选新闻的用户向量。记忆网络能够捕获两个对象之间的高阶复杂关系，在问题回答[4,7]、情感分析[11]、机器理解[10]等领域都取得了很大的进展。受其成功的激励，我们设计了一个循环结构的迭代推理过程，多个推理记忆单元(RMC)级联执行结构化推理操作，一步一步确定匹配分数。 ​ 我们的方法的体系结构如图1所示。 新闻编码器模块通过处理每个新闻的标题并生成新闻嵌入来提取候选新闻和一些用户点击的新闻。 在此之后，循环推理记忆网络中包含一些以新闻嵌入为输入的rmc，它们协同工作，逐级执行推理过程。在每一步中，RMC通过查询单元和存储单元进行推理操作。查询单元使用注意机制来选择用户可能感兴趣的候选新闻嵌入的某些方面来更新查询状态。所述存储单元根据查询状态，从用户点击的新闻嵌入中动态检索用户的兴趣。经过几个推理步骤后，RMBERT可以从多个方面捕获用户对候选新闻的偏好。 最后，我们根据最后的存储状态来推荐新闻，该状态包含了用户和候选新闻之间的交互信息。 ​ 这项工作的主要贡献总结如下。 我们使用BERT对候选新闻和用户点击新闻进行独立编码。我们的方法可以利用BERT的表达能力，同时获得离线预计算新闻嵌入的能力。 我们提出了一种循环结构来逐步执行基于注意力的推理操作。 在每个步骤中，RMC 可以推断候选新闻的某些部分与用户兴趣之间的匹配分数。 RMC可以在每一步动态确定新闻和用户向量，并在多方面探索它们的匹配。 从MSN新闻收集的真实数据集上进行的大量实验证实，我们的方法比现有的最先进的方法具有更好的性能。 ","date":"2022-05-23","objectID":"/rmbert/:3:0","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Paper"],"content":"2 提出的方法 ","date":"2022-05-23","objectID":"/rmbert/:4:0","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Paper"],"content":"2.1 新闻编码器 ","date":"2022-05-23","objectID":"/rmbert/:4:1","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Paper"],"content":"2.2 推理存储单元 ","date":"2022-05-23","objectID":"/rmbert/:4:2","tags":["News Recommendation","Paper"],"title":"论文笔记——RMBERT: News Recommendation via Recurrent Reasoning Memory Network over BERT","uri":"/rmbert/"},{"categories":["Network"],"content":"在linux平台安装OLSR协议 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:0:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"前言 因为要做一个OLSR和SDN自定义控制面的对比实验，所以要利用mininet-wifi平台自定义拓扑跑一下OLSR协议。 平台：ubuntu20.04 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:1:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"安装 官网：www.olsr.org/ github：https://github.com/OLSR/olsrd ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:2:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"通过mininet-wifi安装 进入mininet-wifi目录sudo ./install.sh -o ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:2:1","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"从git安装(没有亲自试，来自网络) 安装语法分析器：sudo apt install bison flex 下载源码：git clone https://github.com/OLSR/olsrd 编译：cd olsrd;make 安装：sudo make install ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:2:2","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"mininet-wifi拓扑构建 构造一个网络拓扑来测试OLSR协议。 拓扑文件（参考example/adhoc.py）： https://github.com/leeshy-tech/mininet-wifi/blob/master/examples/OLSR/olsr_test.py #!/usr/bin/python \"\"\" This example use four motionless station to test the OLSR protocol in adhoc network. It's almost the same as example/adhoc.py. use \"sudo python olsr_test.py olsrd\" in terminal to run it. \"\"\" import sys from mininet.log import setLogLevel, info from mn_wifi.link import wmediumd, adhoc from mn_wifi.manetRoutingProtocols import olsrd from mn_wifi.cli import CLI from mn_wifi.net import Mininet_wifi from mn_wifi.wmediumdConnector import interference def topology(args): \"Create a network.\" net = Mininet_wifi(link=wmediumd, wmediumd_mode=interference) info(\"*** Creating nodes\\n\") kwargs = dict() if '-a' in args: kwargs['range'] = 100 sta1 = net.addStation('sta1', ip6='fe80::1',position='25,50,0', **kwargs) sta2 = net.addStation('sta2', ip6='fe80::2',position='75,10,0', **kwargs) sta3 = net.addStation('sta3', ip6='fe80::3',position='75,90,0', **kwargs) sta4 = net.addStation('sta4', ip6='fe80::4',position='125,50,0', **kwargs) net.setPropagationModel(model=\"logDistance\", exp=4) info(\"*** Configuring wifi nodes\\n\") net.configureWifiNodes() info(\"*** Creating links\\n\") # MANET routing protocols supported by proto: # babel, batman_adv, batmand and olsr # WARNING: we may need to stop Network Manager if you want # to work with babel protocols = ['babel', 'batman_adv', 'batmand', 'olsrd', 'olsrd2'] kwargs = dict() for proto in args: if proto in protocols: kwargs['proto'] = proto net.addLink(sta1, cls=adhoc, intf='sta1-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.addLink(sta2, cls=adhoc, intf='sta2-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.addLink(sta3, cls=adhoc, intf='sta3-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.addLink(sta4, cls=adhoc, intf='sta4-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.plotGraph(max_x=200, max_y=200) info(\"*** Starting network\\n\") net.build() info(\"\\n*** Addressing...\\n\") if 'proto' not in kwargs: sta1.setIP6('2001::1/64', intf=\"sta1-wlan0\") sta2.setIP6('2001::2/64', intf=\"sta2-wlan0\") sta3.setIP6('2001::3/64', intf=\"sta3-wlan0\") sta4.setIP6('2001::4/64', intf=\"sta4-wlan0\") info(\"*** Running CLI\\n\") CLI(net) info(\"*** Stopping network\\n\") net.stop() if __name__ == '__main__': setLogLevel('info') topology(sys.argv) 可视化： 解读： 从图中可以看出，sta1只能与sta2和sta3进行单跳通信，如果要与sta4通信，就需要sta2或者sta3进行中继。如果没有OLSR协议，节点在收到目的IP不是本节点的包之后就会丢掉，无法完成中继。OLSR协议会在网络中的节点维护整个网络拓扑，就能完成中继。 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:3:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"实验测试 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"关闭NetworkManager sudo systemctl stop NetworkManager NetworkManager是linux的自动网络配置工具，我们希望自己配置网络，所以要把它关掉。 查看节点的网络状态ip addr，没有图中的NO-CARRIER说明NetworkManager已经被关闭。（这个命令可以在本机运行，也可以在mininet虚拟主机运行。） ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:1","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"配置OLSR 编辑配置文件：vim /etc/olsrd/olsrd.conf 添加所有节点的网卡： 退出、保存 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:2","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"运行拓扑文件 sudo python olsr_test.py olsrd ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:3","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"网络测试 sta1 ping sta4 能ping通，说明OLSR协议运行正常。 查看路由：sta3 route 多了三条路由，这是OLSR协议运行的结果。 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:4","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"结束 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:5:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"恢复系统 开启NetworkManager：sudo systemctl start NetworkManager 退出mininet-wifi：exit 清理系统：sudo mn -c ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:5:1","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"参考文献 centos7 开启 关闭 NetworkManager Linux虚拟机下OLSR协议的安装 Unable to create IPv6 multi hop mesh network in ad hoc mode #342这个issue救了大命了 Linux卸载olsrd,olsrd路由协议移植到嵌入式linux中使用 www.olsr.org/官网写的说明太少了，根本看不懂，麻了。 https://github.com/OLSR/olsrd ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:5:2","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Linux"],"content":"图片url生成 ","date":"2022-03-17","objectID":"/linux_image_url/:0:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"准备 ","date":"2022-03-17","objectID":"/linux_image_url/:1:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"安装JDK，JRE 下载linux的jdk，jre压缩包： https://www.oracle.com/java/technologies/downloads/#java8 用xftp传到服务器上。 解压tar -zxvf jdk-17_linux-x64_bin.tar.gz jre-8u321-linux-x64.tar.gz，记住此时所在的路径（pwd命令可查）。 配置环境变量： cd /etc vim profile i进入编辑模式 文件末尾加上如下代码，JAVA_HOME,JRE_HOME分别为解压的文件夹的路径： export JAVA_HOME=/home/ubuntu/jdk-17.0.2 export JRE_HOME=/home/ubuntu/jre1.8.0_321 export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH Esc退出，输入:wq保存退出。 使能配置：source /etc/profile 检验：java -version，输出版本信息，安装成功。 ","date":"2022-03-17","objectID":"/linux_image_url/:1:1","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"安装tomcat 下载安装包： https://tomcat.apache.org/download-10.cgi 用xftp传到服务器上，解压tar -zxvf apache-tomcat-10.0.18.tar.gz 进入bin目录，启动tomcat cd apache-tomcat-10.0.18/bin ./startup.sh ","date":"2022-03-17","objectID":"/linux_image_url/:1:2","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"防火墙设置 到服务器控制台，开启8080端口： 浏览器访问服务器IP:8080地址，看到tomcat默认页说明tomcat安装运行成功。 ","date":"2022-03-17","objectID":"/linux_image_url/:1:3","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"生成图片url 假设图片存放在服务器路径：/home/ubuntu/image 进入tomcat文件夹的conf路径，编辑server.xml： cd conf vim server.xml 结尾处插入此代码\u003cContext docBase=\"/home/ubuntu/image\" path=\"/pictures\" debug=\"0\" reloadable=\"true\"/\u003e 则可以通过url=http://ip:8080/path/图片名+后缀访问该图片。 ","date":"2022-03-17","objectID":"/linux_image_url/:2:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"结束语 ","date":"2022-03-17","objectID":"/linux_image_url/:3:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"参考文献 https://www.bilibili.com/video/BV1uh411a7Jg?p=268 tomcat启动“成功”，但是浏览器无法访问 访问 Linux 服务器上的文件（以图片为例 ","date":"2022-03-17","objectID":"/linux_image_url/:3:1","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Install"],"content":"Ryu安装 ","date":"2022-03-07","objectID":"/ryu_install/:0:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"安装git sudo apt install git ","date":"2022-03-07","objectID":"/ryu_install/:1:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"安装python3 时代变了，不装不行。 下载 sudo apt install python3 查看python3的位置和版本号，用于第四步 whereis python3 删除原来python2的软连接 sudo rm /usr/bin/python 建立新的软连接 sudo ln -s /usr/bin/python3.9 /usr/bin/python 查看版本 python --version ","date":"2022-03-07","objectID":"/ryu_install/:2:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"安装Ryu 更新pip sudo pip install --upgrade pip 克隆源代码 git clone git://github.com/faucetsdn/ryu.git 进入ryu目录 cd ryu 安装依赖 sudo pip install -r tools/pip-requires 安装ryu sudo python setup.py install ","date":"2022-03-07","objectID":"/ryu_install/:3:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"测试 进入ryu/ryu/app目录 cd ryu/ryu/app 运行simple_switch.py ryu-manager app/simple_switch.py 出现以下输出为正常： loading app app/simple_switch.py\rloading app ryu.controller.ofp_handler\rinstantiating app app/simple_switch.py of SimpleSwitch\rinstantiating app ryu.controller.ofp_handler of OFPHandler\r ","date":"2022-03-07","objectID":"/ryu_install/:4:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"参考文献 Ubuntu将默认python版本改为python3 https://github.com/leeshy-tech/ryu ","date":"2022-03-07","objectID":"/ryu_install/:5:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"install mysql on linux ","date":"2022-03-07","objectID":"/mysql_install/:0:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"安装： sudo apt update sudo apt install mysql-server ","date":"2022-03-07","objectID":"/mysql_install/:1:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"配置root密码为123456： sudo mysql use mysql; update user set authentication_string='' where user='root'; alter user 'root'@'localhost' identified with mysql_native_password by '123456'; ","date":"2022-03-07","objectID":"/mysql_install/:2:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"参考文献： Ubunto20.04安装MySQL并修改root用户密码 如何在 Ubuntu 20.04 上安装 MySQL ","date":"2022-03-07","objectID":"/mysql_install/:3:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"安装mininet-wifi mininet学了快半年了，还是安装七八次才能装上，人麻了，怒写一篇博客。平台：Ubuntu20.04。 ","date":"2022-03-07","objectID":"/mininet-wifi_install/:0:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"安装git sudo apt install git ","date":"2022-03-07","objectID":"/mininet-wifi_install/:1:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"安装python3 mininet在python2和python3环境下都是能正常运行的，但是，apt中一些python2的包已经升级到3了，比如python-matplotlib，你不升级python3，mininet-wifi就会安装它，但是apt里又没有，只会一直报错。你再怎么更新源，也找不到这个玩意，因为它已经变成python3-matplotlib了。所以还是要安装python3。 下载 sudo apt install python3 查看python3的位置和版本号，用于第四步 whereis python3 删除原来python2的软连接 sudo rm /usr/bin/python 建立新的软连接 sudo ln -s /usr/bin/python3.9 /usr/bin/python 查看版本 python --version ","date":"2022-03-07","objectID":"/mininet-wifi_install/:2:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"安装mininet-wifi ","date":"2022-03-07","objectID":"/mininet-wifi_install/:3:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"有梯子，或者有git代理 克隆源代码 git clone https://github.com/intrig-unicamp/mininet-wifi 查看安装可选项 sudo mininet-wifi/util/install.sh -h 选择一些项安装（默认就按这个） sudo mininet-wifi/util/install.sh -Wlnfv ","date":"2022-03-07","objectID":"/mininet-wifi_install/:3:1","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"无代理 这里主要是指以https无法正常访问github的情况，需要把所有的git网址改为git://开头，因为install.sh里会有下载其他库的git命令，所以直接运行install.sh会报git超时，需要提前把相关库下好。 克隆 git clone git://github.com/intrig-unicamp/mininet-wifi git clone git://github.com/ramonfontes/mac80211_hwsim_mgmt git clone git://github.com/mininet/mininet git clone git://github.com/vchakour/wmediumd 选择一些项安装（默认就按这个） sudo mininet-wifi/util/install.sh -Wlnfv ","date":"2022-03-07","objectID":"/mininet-wifi_install/:3:2","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"运行 运行，这句正常运行就说明下载成功。 sudo mn --wifi 退出 exit 清理 sudo mn -c ","date":"2022-03-07","objectID":"/mininet-wifi_install/:4:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"参考文献 https://github.com/intrig-unicamp/mininet-wifi Ubuntu将默认python版本改为python3 ","date":"2022-03-07","objectID":"/mininet-wifi_install/:5:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Paper"],"content":"Wireless SDN Mobile Ad Hoc Network:from Theory to Practice. ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:0:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/7996340 2017 IEEE International Conference on Communications (ICC) 自翻：https://github.com/leeshy-tech/PaperTranslate/blob/main/wireless_SDN_mobile.md ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:1:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"重要的名词 D2D （device to device） MANET （移动自组织网络） VANET（车辆自组织网络） 本地流量：信息流的源和目的距离很近的数据连接。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:2:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"引言 根据思科[1]最近的一份报告，通过无线网络传输的数据流量正在不断增加，不久将超过有线流量。在未来的5G场景中，无线流量的模式将对本地流量产生越来越大的需求。 使用当前的网络标准，即使是本地数据也要通过蜂窝网络传输到一个集中的实体，然后再重新分发。对于本地流量的交换来说，这种方法显然不是最优的。一种更有前途的方法依赖于设备到设备(D2D)技术[4]，其中设备可以在MANET或者VANET[6]中以分布式方式组织。 在没有集中控制的情况下，每个节点必须独立行动，做出路由决策，并在移动网络中动态地适应快速变化的拓扑结构。前人提出了一些解决方案： 按需距离矢量(AODV)协议，它仅在需要时才寻找路由路径，适合流量偶发的场景。 优化的链路状态路由（OLSR）协议，当几个源-目的对之间的流量比较正常的情况下，预先定义网络中每个可能的节点对之间的路由的主动协议。 区域路由（ZRP）协议，将网络划分为多个集群，如果源节点和目的节点在同一个集群中，则使用OLSR等主动路由策略;否则，采用反应性策略，如AODV。 OLSR的主要问题：它需要节点之间频繁的控制消息交换，以维护每个节点上更新的网络拓扑。ZRP能够显著减少控制消息的数量，因为更新的拓扑信息只需要在每个集群中的节点之间进行维护，但是当一个包被发送到一个属于不同集群的节点时，会引入显著的延迟，因为新的路径应该以响应式的方式搜索。 在节点具有移动性的条件下，必须在减少开销（网络中交换的控制信息）和完全掌握网络拓扑之间做出权衡，如果要设计更好的传输路线，则要更频繁地交换控制信息，不仅耗费了更多的带宽资源，而且也增加了设备的处理压力。 为了适应这种网络不断变化的移动特性，我们参考SDN范例，将数据平面（包括节点之间本地交换的所有数据流量）与控制平面（包括所有的控制报文和本地路由决策）隔开。他们实现的结构是，设备中有两个用于 DP （data plane）和 CP（control plane） 的无线接口，设备以星形拓扑结构与集中式单元CU连接，CU以集中的方式做出路由决策，几乎实时地了解拓扑。这个框架的两个主要优点： ad hoc网络中引入的开销是最小的,每个节点只需要知道它的邻居并且把该信息传给CU。 根本上减少了每个节点的复杂性,因为路由算法运行在CU。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:3:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"SDN MANET的结构 DP MAC协议：采用了ieee802.11的P2P模式独立基本服务集(IBSS)[16]，这是ieee802.11的特设模式标准，根据我们的方法的需要，将交换能力完全控制给上层。 SDN协议：OpenFlow。 无线交换机：Open vSwitch (OVS)。 控制器：ON开发的Open Network Operating System (ONOS)。 平台：Rasp berry Pi(树莓派)Model B+，Linux操作系统 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:4:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"实现细节 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:5:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"修改MAC头 为了实现SDN架构，需要修改交换机设备的Linux内核，允许CU直接控制节点的路由。 图中左侧为标准 Linux 内核协议栈中从物理层 (PHY) 到应用层 (APP) 的逻辑数据流， 以太网帧通过铜缆（在 PHY 层）到达设备，并被发送到以太网驱动程序（在 MAC 层），在删除 PHY 标头并将它们发送到以太网堆栈之前检查它们的完整性。 在以太网堆栈中，在将数据包发送到路由所在的 NET 层之前，MAC 标头也被删除。 如果从无线接口接收到 Wi-Fi 数据包，则数据包首先被发送到 Wi-Fi 驱动程序，在那里去除 PHY 包头，然后由特定模块处理，将 Wi-Fi 数据包转换为以太网数据包，随后被发送到以太网堆栈。 在 SDN 块中，数据报可以根据从 SDN 控制器接收到的规则进行修改。 特别是，为了控制路由路径，SDN控制器强加的规则涉及修改相应数据报的MAC头。 在这些修改之后，数据报将被发送回 SDN 网桥，并转发到以太网堆栈进行与左侧情况相同的处理。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:5:1","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"多跳过程分析 如图所示，涉及从源节点（S）到目的地 (D)的两跳传输。 数据包由 S 生成。它首先传输到辅助节点 (H)，然后由 H 中继到 D。 数据包由主机 S (hS) 生成，它在 IP 报头和 MAC 报头中指定目标主机 D (hD) 的地址。 hS 不知道到达 hD 所需的任何路由信息。 它只是通过有线信道将数据包传输到节点 S (sS) 的交换机，该交换机负责无线传输它。 sS 正在运行 SDN 模块，该模块根据从 SDN 控制器接收到的指令修改 MAC 层的源地址和目标地址。 MAC头中的源和目的地分别变成sS和sH（节点H的交换机）。 然后，数据包可以被 sS 发送，也可以被 sH 接收。 由于数据包中的目的MAC地址为sH，因此数据包由sH进一步处理，并向sS发回确认（ACK）。sH 执行类似的过程，修改目的MAC地址，数据包可以被转发到目的节点（sD）的交换机。 最后，sD 根据来自 SDN 控制器的另一条规则，将源 MAC 地址和目标 MAC 地址分别修改为 hS 和 hD。 这个过程，称为 MAC 恢复，是必要的，以便 hD 识别数据包是由 hS 发送的，而不需要来自 SDN 框架的任何进一步信息。 对于大多数 Wi-Fi 适配器，如果 固件的MAC 和目的地不匹配，则固件中会丢弃数据包，因此修改 MAC 地址是多跳传送数据包的必要步骤。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:5:2","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"平台测试：性能比较 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"网络设置 实验场景由具有三个 SDN 节点的 SDN MANET 组成，标记为 S、H 和 D，如上一节所示，部署如图所示。每个节点由一个 RPi Model B+ 和一个 Wi -Fi 适配器（Ralink RT5370 USB）组成，DP 中的传输使用 IEEE 802.11g ad-hoc 模式。 三个 SDN 节点配备了 OVS-2.4.0，并连接到运行 ONOS 控制器的 CU 和我们的 MANET 应用程序 [12]。 第二个网络名为 OLSR MANET，它使用相同位置和相同拓扑的相同三个节点（S、H 和 D）进行比较。 实际上，在第二个网络中，节点没有配备我们的 SDN 框架，但它们正在运行分布式路由策略 OLSR。 在这两个网络中，数据流量都是在节点 S 使用流量生成器 iPerf3 [35] 生成的，该流量生成器会创建一个随机 TCP 流，流向目的地节点 D。实验时间为 N 秒，时间间隔为 1秒。 对于每个间隔 τn，n = 1,…,N，端到端吞吐量以每秒比特 (bps) 为单位测量为： $$ T\\left(\\tau_{n}\\right)=\\frac{\\text { TCP } \\text { RWND } \\times 8}{\\text { RTT }} $$ 其中 TCP RWND 是间隔 τi 期间 TCP 会话的平均接收窗口大小，RTT 是平均往返时间，即从发送的 TCP 段的第一个比特传输到接收到该 TCP 段的 TCP ACK的最后一个比特所经过的时间。 为了比较 SDN MANET 和 OLSR MANET 在拓扑突然变化的情况下的行为，我们改变了图a的全连接拓扑为图b的多跳拓扑（S和D之间没有直接连接）。实现的方法是，在节点的 MAC 层设计一个模块来模拟 S 和 D 之间的链路故障，该模块可以拒绝来自 S 的所有数据包（对于 节点 D），或来自 D（对于节点 S）。 这样，我们可以在我们的实验中完美地控制 S 和 D 之间的链路何时发生故障，或者何时重新启动。 对于 SDN MANET 和 OLSR MANET，每个实验重复 M = 20 次。 结果中显示的平均吞吐量为： $$ \\bar{T}\\left(\\tau_{n}\\right)=\\frac{\\sum_{m=1}^{M} T_{m}\\left(\\tau_{n}\\right)}{M} $$ 其中 Tm(τn) 是第 m 次实验在时间间隔 τn 期间获得的吞吐量。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:1","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"链路断开实验 在时间 t = 10，S 和 D 之间的直接链路发生故障。 SDN控制器立即收到此事件的通知，并迅速做出反应，将新的SDN规则强加给节点S和H。这样，节点S将所有发往D的数据包发送给H，H将这些数据包转发给D。 SDN MANET 的吞吐量立即恢复到初始吞吐量的一半，因为从 S 到 D 的新路径现在有两跳。 OLSR MANET 能够识别链路故障并通过仅在 t = 25 时将路径更改为 D 来对其做出反应，延迟约 15 秒，从而导致严重的吞吐量中断。 这个结果是意料之中的，因为 OLSR 有一个完全分布式的路由算法，它需要大量时间来更新。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:2","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"连接实验 在第二个实验中，我们观察了当初始拓扑是图b中的拓扑时，SDN MANET 和 OLSR MANET 经历的平均吞吐量，即 S 和 D 之间的两跳路径。 在 t = 10 时，S 和 D 之间的直接链接也被激活，如图a所示。 正如预期的那样，我们观察到，在 SDN MANET 的情况下，网络能够迅速对拓扑的变化做出反应，并且吞吐量在 t \u003e 10 时几乎翻了一番。另一方面，OLSR MANET 的延迟约为 20 秒。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:3","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"快速变化拓扑实验 在第三个实验中，有一系列连续的拓扑变化。 在 t = 0 时，拓扑是图a中的拓扑（S 和 D 之间有直接链路），然后在 t = 30 时，拓扑变为图b中的拓扑（两跳） ，然后在 t = 60 时再次切换到图a，最后在 t = 90 时切换到图b。 同样在这种情况下，实验重复 20 次，结果取所有试验的平均值。 对于每个拓扑变化，我们观察到 SDN MANET 如何能够几乎立即对拓扑变化做出反应，而 OLSR MANET 对变化的反应有一定的延迟，正如预期的那样，会导致显著的吞吐量损失。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:4","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"结论 在这项工作中，我们提出了一个 SDN MANET 的实际实现，它提供了 D2D 数据传输的所有优点，同时具有集中网络管理的灵活性。 为了展示 SDN MANET 的优势以及所提供的所有软件的有效性，我们将我们的 SDN MANET 与以分布式方式管理的 ad hoc 网络进行了比较。 我们用几个简单的例子强调了我们方法的显着优势，特别是对于快速变化的网络拓扑。 在未来的工作中，我们计划处理大规模的 SDN MANET，解决可能出现的可扩展性问题。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:7:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["HarmonyOS"],"content":"用户登录 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"项目结构 └─ entry\r├─src.main\r├─ java.com.example.users\r├─beans\r├─ Account API请求体\r└─ LoginMsg API返回体\r├─slice\r├─ UserInfoAbilitySlice 个人主页Slice\r└─ MainAbilitySlice 主页面Slice\r├─utils\r├─ DataBaseUtil 数据库操作类\r├─ HttpRequestUtil API调用类\r└─ LoadImageUtil 网络图片加载到image组件\r├─ LocalDBAbility 本地数据库的DataAbility\r├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r├─ ability_userinfo.xml 个人页面布局文件\r└─ ability_main.xml 主页面布局文件\r└─ build.gradle 添加外部依赖\r","date":"2022-02-20","objectID":"/harmonyos_userlogin/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"效果 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"项目逻辑 此项目的重点是token，它存储在本地数据库，扮演类似浏览器中cookie的角色。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"登陆页 首页获取用户的账号和密码，点击按钮向后端发送http请求。 登陆成功，则将后端返回的token存入本地数据库，并导航到个人页面。 登陆不成功，则使用ToastDialog组件显示提示信息，账号错误或密码错误。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:2:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"个人页 个人页面高度精简，只显示用户头像。 导航到此页，说明用户一定已经登陆。 查询本地数据库，获得token。 向后端发送请求，获取用户头像的url。 将url加载到image组件。 当用户退出APP，清理后台后，仍然能记住登陆状态，导航回个人主页，不用重新登陆。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:2:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"后端接口 代码：https://github.com/leeshy-tech/API_userLogin/blob/main/user_login_token.py 博客：Python实践——后端接口实现(2) ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"准备 这些都是之前的博客详细说过的部分，不再赘述。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"添加依赖 implementation ('com.alibaba:fastjson:1.2.47') ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"本地数据库的DataAbility——LocalDBAbility 把之前写过的照抄过来，改一下数据库名、表名、建表sql语句即可。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"请求体和返回体类——Account，LoginMsg 根据后端接口的格式建立的类。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:3","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"网络图片加载——LoadImageUtil 将网络图片加载到image组件，copy之前的项目。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:4","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"API调用类——HttpRequestUtil 发送HTTP请求的封装类，这个之前没讲过，照抄会用即可。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:5","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"DataBaseUtil 为了尽可能的简化主体代码，把从数据库里查询token，和插入token的操作封装成这个类。 //数据库查询、插入 帮助类 public class DataBaseUtil { private static Uri uri = Uri.parse(\"dataability:///com.example.users.LocalDBAbility/user_info\"); public static String getToken(Context context){ String value = null; DataAbilityHelper dataAbilityHelper = DataAbilityHelper.creator(context); String[] colums = {\"token\"}; DataAbilityPredicates predicates = new DataAbilityPredicates(); try { ResultSet rs = dataAbilityHelper.query(uri, colums, predicates); if(rs.getRowCount() \u003e0){ rs.goToFirstRow(); value = rs.getString(0); } } catch (DataAbilityRemoteException e) { e.printStackTrace(); } return value; } public static int setToken(String token,Context context) { int i = 0; ValuesBucket valuesBucket = new ValuesBucket(); valuesBucket.putString(\"token\",token); DataAbilityHelper dataAbilityHelper = DataAbilityHelper.creator(context); try { i = dataAbilityHelper.insert(uri, valuesBucket); } catch (DataAbilityRemoteException e) { e.printStackTrace(); } return i; } } ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"MainAbilitySlice onStart方法： super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); String token_s = DataBaseUtil.getToken(this); //如果本地数据库没有token，说明用户还没有登陆 if (token_s == null) { Button btn_login = findComponentById(ResourceTable.Id_login_btn); TextField tf_userid = findComponentById(ResourceTable.Id_login_id_textfield); TextField tf_userPwd = findComponentById(ResourceTable.Id_login_pwd_textfield); String url = \"http://8.136.83.196:8899/users/login\"; btn_login.setClickedListener(component -\u003e { //开新线程 TaskDispatcher globalTaskDispatcher = this.getGlobalTaskDispatcher(TaskPriority.DEFAULT); //异步 globalTaskDispatcher.asyncDispatch(() -\u003e { String user_id = tf_userid.getText(); String user_pwd = tf_userPwd.getText(); //发送http请求，并获得数据 Account account = new Account(user_id, user_pwd); String account_json = JSON.toJSONString(account); String login_msg = HttpRequestUtil.sendPostRequest(this, url, account_json); LoginMsg login_msg_obj = JSON.parseObject(login_msg, LoginMsg.class); String token = login_msg_obj.getToken(); String msg = login_msg_obj.getMsg(); if (token != null) { //将token存入本地数据库，并跳到个人页 DataBaseUtil.setToken(token, this); present(new UserInfoAbilitySlice(), new Intent()); } else { //返回主线程进行UI重绘，原因是show方法不能在子线程中运行 getUITaskDispatcher().asyncDispatch(new Runnable() { @Override public void run() { new ToastDialog(getContext()).setText(msg).show(); } }); } }); }); } //如果本地数据库有token，说明已经登陆，就跳到个人页 else{ present(new UserInfoAbilitySlice(), new Intent()); } 进来先进行一个判断，若本地数据库里有token，则直接跳转到个人页，为了应对APP被杀死后重启的情况。 按钮监听，获取输入框的信息，向后端发送请求，获得token和msg。 若token不为空，则存到本地数据库，并跳转到个人页。 若token为空，则建立一个ToastDialog组件，显示msg。ToastDialog组件专门用于显示提示信息，它存在几秒后自动消失。 注意\r\r建立Toast Dialog组件这里，重绘UI的操作只能在主线程里运行，在这里指show方法，如果直接写new ToastDialog(getContext()).setText(msg).show();是不行的，因为此时我们正在新建的线程里，这个任务要扔回到主线程，所以才有了以下的代码块。\r\r getUITaskDispatcher().asyncDispatch(new Runnable() { @Override public void run() { new ToastDialog(getContext()).setText(msg).show(); } }); onActive方法： super.onActive(); //程序重新返回前台调用 //若已经登陆，则导航到个人页 String token_s = DataBaseUtil.getToken(this); if (token_s != null){ present(new UserInfoAbilitySlice(), new Intent()); } 当页面从后台返回前台时，调用的是onActive方法，比如用户在导航到个人页之后，点了一下退出键，就会返回默认页，我们不想让他再发一次http请求，检查token，若存在，直接将其导航回个人页。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"UserInfoAbilitySlice onStart方法： super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_userinfo); //能导航到此页说明用户已经登陆，向服务器请求用户的头像 String token = DataBaseUtil.getToken(this); Image image = findComponentById(ResourceTable.Id_image); if (token != null){ //建新线程 TaskDispatcher globalTaskDispatcher = this.getGlobalTaskDispatcher(TaskPriority.DEFAULT); //异步 globalTaskDispatcher.asyncDispatch(()-\u003e{ //发送请求，更新image组件 String url = \"http://8.136.83.196:8899/users/info\"; String img_url = HttpRequestUtil.sendPostRequestWithToken(this,url,token); LoadImageUtil.loadImg(this,img_url,image); }); } 导航到此页时，从本地数据库中取出token，向后端发送。 后端返回头像的url。 将url显示到image组件。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:7:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"一些瑕疵 没有退出登陆键，这个很容易实现，点击按钮，把token删掉即可，我懒得写了。 个人页太简单，懒就一个字。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:8:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:9:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/Users ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:9:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 HarmonyOS文档 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:9:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["Python"],"content":"增加token验证 书接上文 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:0:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"token是什么 简单来说，token可以认为是身份令牌，当用户登陆成功之后，获得这个令牌，当需要向服务器请求一些私密资源时，便可以提交这个令牌，以证明自己是合法用户。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:1:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"token生成及解析 使用pyjwt这个库：pip install pyjwt ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:2:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"核心代码： import jwt # 加密算法 headers = { \"alg\":\"HS256\", \"typ\":\"JWT\" } # 密钥 SECRET_KEY = \"leeshy\" '''生成一个token''' def token_encode(user_id) -\u003e str: if user_id: payload = { \"user_id\":user_id } token = jwt.encode(payload=payload, key=SECRET_KEY,algorithm='HS256',headers=headers) return token else: return None '''解码token''' def token_decode(token) -\u003e str: payload = jwt.decode(jwt=token,key=SECRET_KEY,verify=False,algorithms='HS256') info = payload[\"user_id\"] return info headers声明加密算法 SECRET_KEY密钥是编码解码的关键 payload项中，有一些官方声明项，除官方声明项外还可以存一些自定义信息。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:2:1","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"用户登陆 如果登陆成功，就返回信息和token，如果不成功，就只返回提示信息。 较上一个版本只有一点改变，核心代码： '''生成一个返回体''' def response_body_login(msg,user_id=None): response_msg = { \"msg\":msg, \"token\":token_encode(user_id) } return jsonify(response_msg) @app.route('/users/login',methods=['POST']) def users_login(): if request.method == \"POST\": user_id = request.json.get(\"user_id\") user_password = request.json.get(\"user_password\") for user_dict in users_list: if user_dict[\"user_id\"] == user_id: if user_dict[\"user_password\"] == user_password: return response_body_login(\"success\",user_id) else: return response_body_login(\"password error\") return response_body_login(\"id not exist\") 规定的请求体格式是application/json ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:3:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"请求用户信息 用户向服务端提供token，验证成功则返回用户头像的url。 @app.route('/users/info',methods=['POST']) def users_info(): if request.method == \"POST\": token = request.headers[\"token\"] try: user_id = token_decode(token) except: return \"token error\" for user_dict in users_headphotos: if user_dict[\"user_id\"] == user_id: return user_dict[\"user_headphoto\"] return \"no headphoto\" token要放在请求头里，所以通过request.headers取得。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:4:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"请求体格式 在前端向后端发送请求时，必须在请求头部分声明请求体格式。 例如：connection.setRequestProperty(\"Content-Type\",\"application/json;charset=utf-8\"); 这个格式是由后端决定的，否则后端无法取到对应的信息。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:5:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"application/x-www-form-urlencoded 这是最常见的 POST 提交数据的方式，提交时按照键值对key1=val1\u0026key2=val2的方式进行编码。 版本1时，就使用了这种方法调试，所以后端代码对应的是： user_id = request.form.get(\"user_id\") user_password = request.form.get(\"user_password\") ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:5:1","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"application/json 指示服务端消息主体是序列化的JSON字符串。 本次使用的调试方式是json，所以后端代码对应： user_id = request.json.get(\"user_id\") user_password = request.json.get(\"user_password\") ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:5:2","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"调试 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:6:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"结束语 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:7:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"源码 https://github.com/leeshy-tech/API_userLogin ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:7:1","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"参考文献 【记录】form-data与x-www-form-urlencoded的区别 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:7:2","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"自己动手写一个API ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:0:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"相关概念 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"端口Port 这里端口指的是网络端口，利用IP+端口号可以唯一的定位一台主机上的某个应用程序，可以认为端口是APP之间交换数据的“门”，要想与某APP进行通信，就需要知道它运行在哪个主机的哪个端口上。 我们要写一个API，实质上是写了一个完成特定功能的应用程序，它的接口暴露在外，以供其他程序员调用。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"URL (Uniform Resource Locator) 统一资源定位符，是互联网上标准资源的地址。而互联网上的每个文件都有唯一的一个的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。格式为protocol :// ip[:port] / path / [;parameters][?query]#fragment 一个应用程序可以暴露多个接口，比如用户登陆、用户注册，url可以是/user/userlogin、/user/usersignup。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"HTTP、HTTPS、POST、GET 超文本传输协议（HTTP）的设计目的是保证客户端与服务器之间的通信。客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。 HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包，更加安全。 POST和GET都是HTTP协议的请求方法，除了它们还有HEAD、PUT等方法。 GET方法将查询字符串放在请求的URL中： /test/demo_form.php?name1=value1\u0026name2=value2 POST方法将查询字符串放在HTTP消息主体中： POST /test/demo_form.php HTTP/1.1\rHost: runoob.com\rname1=value1\u0026name2=value2\r 总的来说，POST方法更加安全，详细区别可参考结尾文章。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:3","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"JSON JSON: JavaScript Object Notation(JavaScript 对象表示法) 它采用完全独立于编程语言的文本格式来存储和表示数据。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 将API看作函数，请求体就是参数，响应体就是返回值，按照JSON格式设计请求体和响应体，前后端程序就能通过JSON解析器互相沟通。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:4","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"准备 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"安装库 pip install flask,flask_cors,gevent ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"功能设计 设计一个简单的用户登陆功能，前端提供账号密码，服务端返回提示消息。 账号密码正确，返回success 密码错误，返回password error 账号不存在，返回id not exist ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"参数 协议：HTTP（HTTPS会涉及到一些复杂的设置，下次再说。） 方法：POST 请求体示例： { {\"user_id\":\"2019210777\"}, {\"user_password\":\"123456\"} } 响应体示例： { {\"msg\":\"success\"} } ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:3","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"核心代码 关于端口\r\r程序里的端口号自主选择，不与其他服务冲突即可。如果冲突会报错：地址(‘0.0.0.0’,port)已被使用，被使用的不是IP地址，而是端口号。要么更换端口，要么杀死该端口的服务（Google相关的命令即可）。\r\r from flask import Flask,request,jsonify from flask_cors import CORS from gevent import pywsgi port = 8899 app = Flask(__name__) CORS(app,resource=r'/*') users_list = [ {\"user_id\":\"2019210777\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210778\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210779\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210780\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210781\",\"user_password\":\"123456\"} ] '''生成一个返回体''' def response_body(msg): response_msg = [ {\"msg\":msg} ] return jsonify(response_msg) @app.route('/login',methods=['POST']) def func(): if request.method == \"POST\": user_id = request.form.get(\"user_id\") user_password = request.form.get(\"user_password\") for user_dict in users_list: if user_dict[\"user_id\"] == user_id: if user_dict[\"user_password\"] == user_password: return response_body(\"success\") else: return response_body(\"password error\") return response_body(\"id not exist\") if __name__ == \"__main__\": server = pywsgi.WSGIServer(('0.0.0.0',port),app) server.serve_forever() print(\"end\") ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:3:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"调试 使用Postman进行调试，新建一个请求，填入相关参数。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:4:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"部署 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:5:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"为什么要部署 写好这个API之后，我尝试写了一个鸿蒙应用来调用，但是始终连接超时，原因如下： 鸿蒙模拟器应当是运行在华为的某台服务器上，它与我的电脑不在同一局域网内，我的电脑的局域网IP，它肯定是访问不到的。 而我用Postman调试，自己访问自己，处于局域网内，所以是没有问题的。 要是想在局域网外进行访问，还是要部署到有公网IP的服务器上。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:5:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"云服务器 我使用的是阿里云服务器 防火墙设置 默认情况下，8899端口的进出流量是不能通过阿里云防火墙的，我们新建一条安全组规则。 运行代码 远程到服务器，执行以下命令： 安装git：yum install git 下载代码：git clone https://github.com/leeshy-tech/API_userLogin 进入目录：cd API_userLogin 执行代码：python user_login.py 调试 在Postman里，url里的IP改为服务器的公网IP，发送请求，调试成功。 服务器也有相应的输出： ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:5:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"结束语 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:6:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"项目源码 https://github.com/leeshy-tech/API_userLogin ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:6:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"参考文献 HTTP 方法：GET 对比 POST_菜鸟教程 JSON教程_菜鸟教程 https://www.bilibili.com/video/BV1TJ411G7po?spm_id_from=333.999.0.0 使用nodejs编写api接口并部署到服务器上 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:6:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-02-12","objectID":"/harmonyos_api/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"项目结构 └─ entry\r├─src.main\r├─ java.com.example.api\r├─beans\r├─ requestBody API请求体\r└─ returnBody API返回体\r├─slice\r└─ MainAbilitySlice 主页面Slice\r├─utils\r├─ baiduApi 百度API调用\r├─ HttpRequestUtil 一般API调用，本项目没用到，但是很重要\r└─ LoadImageUtil 网络图片加载到image组件\r├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r└─ ability_main.xml 主页面布局文件\r└─ build.gradle 添加外部依赖\r","date":"2022-02-12","objectID":"/harmonyos_api/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"效果 单击按钮，将输入框内的文字转换为二维码显示在下方。 用手机扫码，解码的信息与文字相同。 ","date":"2022-02-12","objectID":"/harmonyos_api/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"铺垫 ","date":"2022-02-12","objectID":"/harmonyos_api/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"HTTP 注意\r\r本项目中调用API使用的是https方式，这部分仅作笔记。\r\r 在鸿蒙应⽤中默认只允许访问https接⼝，如果要访问http接⼝，需要在config.json的deviceConfig项中添加如下配置： \"deviceConfig\": { \"default\": { \"network\": { \"cleartextTraffic\": true } } } ","date":"2022-02-12","objectID":"/harmonyos_api/:2:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"JSON API请求体的传入和响应体的解析需要JSON格式的字符串、把JSON字符串转换为对象，虽然也可以用转义符等方式实现，但还是用外部依赖比较方便，常用的依赖有Gson、FastJson、Jackson，本项目使用的是FastJson。 借助转义符传递JSON be like： String jsonBody = \"{\\n \\\"data\\\" : \\\"https://apis.baidu.com/\\\",\\n\" + \" \\\"size\\\" : 20,\\n\" + \" \\\"level\\\" : \\\"L\\\",\\n\" + \" \\\"format\\\" : \\\"jpg\\\",\\n\" + \" \\\"logo\\\" : \\\"https://apisown-test.bj.bcebos.com/qr-code-api-store.png\\\"\\n}\"; 我的老天，它实在是太丑陋了。 ","date":"2022-02-12","objectID":"/harmonyos_api/:2:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"引入外部依赖 添加依赖库fastjson，以及百度的依赖库api-explorer-sdk。 在entry \u003e build.gradle中添加：implementation ('com.baidubce:api-explorer-sdk:1.0.3.1','com.alibaba:fastjson:1.2.47') 技巧\r\r添加外部依赖的方法，详见：鸿蒙开发笔记——引入外部依赖\r\r ","date":"2022-02-12","objectID":"/harmonyos_api/:2:3","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"API调用 API的功能是将字符串转化为二维码图片，这里选用的是百度的API，原因是：有例程。对于我这种啥都没学扎实的人来说，能降低点难度最好。 ","date":"2022-02-12","objectID":"/harmonyos_api/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"API需要注意的点 调用方式：HTTP or HTTPS? POST？GET？DELETE？ 请求体参数。 响应体参数：取决于你如何取到你想要的返回值。 认证密钥。 从该API的介绍中我们看到：http和https均可，POST方式，有认证密钥，请求体和响应体参数示例如下： ","date":"2022-02-12","objectID":"/harmonyos_api/:3:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"核心代码 请求体和响应体各写成一个类：requestBody 、returnBody //API的请求体，共五个参数 public class requestBody { private String data; private int size; private String level; private String format; private String logo; ... } //API的响应体类，只有一个参数 public class returnBody { private String imageUrl; ... } 调用API的过程封装成类的函数：baiduApi.sendRequest(requestBody request_body) //百度API的请求代码，由示例代码更改而来：https://apis.baidu.com/store/detail/581576df-bc52-4e4a-8a3a-2abd6035e7ae public static String sendRequest(requestBody request_body) { //填入自己的accessKey，secretKey，否则项目无法正常运行。 String accessKey = \"accessKey\"; String secretKey = \"secretKey\"; String result = null; String path = \"http://qrcode.api.bdymkt.com/qrcode/generate\"; ApiExplorerRequest request = new ApiExplorerRequest(HttpMethodName.POST, path); request.setCredentials(accessKey, secretKey); // 设置header参数 request.addHeaderParameter(\"Content-Type\", \"application/json;charset=UTF-8\"); // 设置jsonBody参数 String objStr = JSON.toJSONString(request_body); request.setJsonBody(objStr); ApiExplorerClient client = new ApiExplorerClient(new AppSigner()); try { ApiExplorerResponse response = client.sendRequest(request); // 返回结果格式为Json字符串 result = response.getResult(); } catch (Exception e) { e.printStackTrace(); } return result; } ","date":"2022-02-12","objectID":"/harmonyos_api/:3:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"按键监听 注意\r\r本部分参考官方文档 \u003e Ability框架 \u003e 线程管理\r\r 这里的按键监听与之前稍有不同，原因是调用API是一个耗时的工作，它不能在主线程中运行，需要在按键监听器中使用新的线程。 ","date":"2022-02-12","objectID":"/harmonyos_api/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"核心代码 MainAbilitySlice的onStart方法： //设置按键监听 btn1.setClickedListener(component -\u003e { //开一个新线程 TaskDispatcher globalTaskDispatcher = this.getGlobalTaskDispatcher(TaskPriority.DEFAULT); //异步 globalTaskDispatcher.asyncDispatch(()-\u003e{ //调用API生成二维码图片（网络地址） //返回字符串格式：{\"imageUrl\":\"https://bj.bcebos.com/qr-code/22021215e07535dcaa53.jpg\"} String string = tf1.getText(); requestBody request_body = new requestBody(string,20,\"L\",\"jpg\", \"https://apisown-test.bj.bcebos.com/qr-code-api-store.png\"); String request_result = baiduApi.sendRequest(request_body); //将JSON字符串转换为类，取出imageUrl returnBody returndata = JSON.parseObject(request_result, returnBody.class); String image_url = returndata.getImageUrl(); //将网络图片显示到image组件 LoadImageUtil.loadImg(this,image_url,image1); }); }); 在新线程的异步方法里写入监听逻辑：调用API并将返回的网络图片url显示到image组件。 ","date":"2022-02-12","objectID":"/harmonyos_api/:4:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"网络图片显示 注意\r\r本部分参考官方文档 \u003e 媒体 \u003e 图像 \u003e 位图操作开发指导 \u0026 图像解码开发指导。\r\r 当我们API调用成功之后，我们就需要显示这个图片，但是image组件的setImageElement()方法的输入参数类型只能是Element，而Element类型是鸿蒙的本地数据文件管理类型，也就是说通过这个方法只能让image组件显示本地的图片，我们获得的网络图片地址在这里是不能用的。 我们需要自己写接口来实现网络图片的显示：LoadImageUtil.loadImg(Context context, String netImgUrl, Image image) //将网络图片加载到context的image组件里 public static void loadImg(Context context, String netImgUrl, Image image){ //创建一个新线程 TaskDispatcher globalTaskDispatcher = context.getGlobalTaskDispatcher(TaskPriority.DEFAULT); globalTaskDispatcher.asyncDispatch(()-\u003e{ HttpURLConnection connection = null; try{ //建立与网络图片之间的http连接 URL url = new URL(netImgUrl); connection = (HttpURLConnection) url.openConnection(); connection.connect(); //从连接中获取输入流 InputStream inputStream = connection.getInputStream(); //根据数据流将图片数据缓存到ImageSouce对象，创建图片对象 ImageSource imageSource = ImageSource.create(inputStream,new ImageSource.SourceOptions()); //图片数据解码的参数 ImageSource.DecodingOptions decodingOptions = new ImageSource.DecodingOptions(); decodingOptions.desiredPixelFormat = PixelFormat.ARGB_8888; //PixelMap对象就表示一个图片 PixelMap pixelmap = imageSource.createPixelmap(decodingOptions); //将图片载入到组件中：在鸿蒙应用中将图片载入到组件，推荐在一个独立的UI线程中完成 context.getUITaskDispatcher().asyncDispatch(()-\u003e{ image.setPixelMap(pixelmap); pixelmap.release();//释放图片 }); }catch (IOException e){ e.printStackTrace(); } }); } 主要思路： 建立网络连接获得图片数据 图片数据解码 转换成位图对象pixelmap 通过image.setPixelMap(pixelmap)方法载入图片 ","date":"2022-02-12","objectID":"/harmonyos_api/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-12","objectID":"/harmonyos_api/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"项目地址 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/Api ","date":"2022-02-12","objectID":"/harmonyos_api/:6:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"参考文献 Fastjson 使用实例 Java 中 JSON 的使用 百度智能云——二维码生成识别 HarmonyOS文档 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 ","date":"2022-02-12","objectID":"/harmonyos_api/:6:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"Gradle 简单的说，Gradle是一个构建工具，它是用来帮助我们构建app的，构建包括编译、打包等过程。我们可以为Gradle指定构建规则，然后它就会根据我们的“命令”自动为我们构建app。Studio中默认就使用Gradle来完成应用的构建。在创建工程时，Studio自动帮我们生成了一些通用构建规则，很多时候我们甚至完全不用修改这些规则就能完成我们app的构建。 有些时候，我们会有一些个性化的构建需求，比如我们引入了第三方库，或者我们想要在通用构建过程中做一些其他的事情，这时我们就要自己在系统默认构建规则上做一些修改。这时候我们就要自己向Gradle”下命令“了，这时候我们就需要用Gradle能听懂的话了，也就是Groovy。Groovy是一种基于JVM的动态语言，关于它的具体介绍，感兴趣的同学可以文末参考”延伸阅读“部分给出的链接。 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:1:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"依赖坐标 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:2:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"什么是依赖坐标 依赖坐标的概念来源于Maven，俗称 gav：指的是使用下面三个向量子仓库中唯一定位一个 Maven 工程。 groupid:公司或组织域名倒序 com.ys.maven artifactid:模块名，也是实际项目的名称 Maven_05 version:当前项目的版本 0.0.1-SNAPSHOT ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:2:1","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"如何获取依赖坐标 https://mvnrepository.com/ 在mvnrepository官网查询 单击版本号，可以看到它的坐标信息： 各种提示： 比如我现在要调用百度公司的API，示例代码提示我要引用百度的依赖： 那么就获取了坐标信息。 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:2:2","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"在鸿蒙应用中引用依赖 注意\r\r虽然我们在坐标依赖部分一直在说Maven，但是在DevEco Studio中使用的还是gradle，这点要分清楚。\r\r 打开entry \u003e build.gradle： 在dependencies一栏添加如下语句：implementation ('依赖坐标1','依赖坐标2','依赖坐标3') 依赖坐标 = groupid:artifactid:version 例如： dependencies { implementation fileTree(dir: 'libs', include: ['*.jar', '*.har']) testImplementation 'junit:junit:4.13.1' ohosTestImplementation 'com.huawei.ohos.testkit:runner:2.0.0.200' implementation ('com.google.code.gson:gson:2.8.8','com.baidubce:api-explorer-sdk:1.0.3.1') } 打开gradle页面，刷新。 左侧工程目录能看到加入的依赖 由此，在工程中能够正常使用外部依赖。 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:3:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:4:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"参考文献 十分钟理解Gradle https://mvnrepository.com/ Maven详解（五）—— 坐标的概念以及依赖管理 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:4:1","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["Electronic Design"],"content":"模拟开关 模拟开关，英文名Analog switches；主要是完成信号链路中的信号切换功能。采用MOS管的开关方式实现了对信号链路关断或者打开；由于其功能类似于开关，而用模拟器件的特性实现，成为模拟开关。 ","date":"2022-02-09","objectID":"/analogue_switch/:0:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"什么时候用继电器 继电器利用了电生磁原理，通电时电磁铁吸附开关使开关断开，常常应用于电子设计中作为电控开关。模拟开关是集成电路芯片，体积小、寿命高，而且能够实现较为复杂的功能，比如单刀双掷、单刀四掷、四开关集成等等。所以常见场景下还是模拟开关最为适合。 但是，集成电路芯片就决定了它有限制使用条件，信号电压、电流、频率均有一些限制，在大功率、高频场景下，可能模拟开关无法胜任，就需要使用继电器。 ","date":"2022-02-09","objectID":"/analogue_switch/:1:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"四双向模拟开关CD4066 CD4066 的引脚功能如图所示。每个封装内部有 4 个独立的模拟开关，每个模拟开关 有输入、输出、控制三个端子，其中输入端和输出端可互换。当控制端加高电平时，开关导通；当控制端加低电平时开关截止。模拟开关导通时，导通电阻为几十欧姆；模拟开关截止时，呈现很高的阻抗，可以看成为开路。模拟开关可传输数字信号和模拟信号，可传输的模拟信号的上限频率为 40MHz。各开关间的串扰很小，典型值为－50dB。 当模拟开关的电源电压采用双电源时，例如 =﹢5V， =﹣5V(均对地0V而言)，则输入电压对称于0V的正、负信号电压(﹢5V～﹣5V)均能传输。这时要求控制信号C=“1”为+5V，C=“0”为-5V，否则只能传输正极性的信号电压。 ","date":"2022-02-09","objectID":"/analogue_switch/:2:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"单八路模拟开关CD4051 CD4051 的引脚功能如图所示。CD4051 相当于一个单刀八掷开关，开关接通哪一通道，由输入的 3 位地址码 ABC 来决定。 真值表： ","date":"2022-02-09","objectID":"/analogue_switch/:3:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"同系列器件 ","date":"2022-02-09","objectID":"/analogue_switch/:4:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"双四路模拟开关CD4052 ","date":"2022-02-09","objectID":"/analogue_switch/:4:1","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"三组二路模拟开关 CD4053 ","date":"2022-02-09","objectID":"/analogue_switch/:4:2","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"十六路模拟开关 CD4067——单刀十六掷 ","date":"2022-02-09","objectID":"/analogue_switch/:4:3","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"结束语 ","date":"2022-02-09","objectID":"/analogue_switch/:5:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"参考文献 https://www.chip37.com/scp/CD4066 http://www.elecfans.com/dianzichangshi/20171209598886_a.html ","date":"2022-02-09","objectID":"/analogue_switch/:5:1","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"datasheet https://github.com/leeshy-tech/Electronic-Design/tree/main/analog_switches ","date":"2022-02-09","objectID":"/analogue_switch/:5:2","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["HarmonyOS"],"content":"Ability HarmonyOS文档\r\rAbility是应用所具备能力的抽象，也是应用程序的重要组成部分。一个应用可以具备多种能力，HarmonyOS支持应用以Ability为单位进行部署。Ability可以分为FA（Feature Ability）和PA（Particle Ability）两种类型，每种类型为开发者提供了不同的模板，以便实现不同的业务功能。\r\r 总的来说，Ability是功能相似的内容的集合，这种划分便于应用的编程组织，FA提供与用户交互的能力，只包含PageAbility，PA没有可视化界面，包括ServiceAbility和DataAbility。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:0:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"配置 一个应用中所有的Ability必须在config.json中注册。 如果通过新建Ability来创建Ability，Studio会自动注册，不需要手动更改config.json。 但如果通过新建Java类来创建，则需要在config.json添加相关的配置信息。 同样，当删除Ability时，需要删除config.json中对应的配置信息，否则会出现一些问题。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:1:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"生命周期 PageAbility和ServiceAbility具有复杂的生命周期，创建、隐藏到后台、从后台呼出等等都会执行相关的生命周期函数，其中onStart方法最常用，当Ability创建时调用onStart方法，所以UI的绑定、按钮事件响应器等等都需要在onStart方法中实现。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:2:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"Intent HarmonyOS文档\r\rIntent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。\r\r Intent是页面跳转及传参的关键，他包括Operation与Parameters两个属性，不传参时只需要构造默认intent，例如下： btn1.setClickedListener(component -\u003e { Intent intent = new Intent(); this.present(new SecondAbilitySlice(),intent); }); 参数通过Parameters来传递： btn1.setClickedListener(component -\u003e { Intent intent1 = new Intent(); intent1.setParam(\"productId\",\"101\"); this.present(new SecondAbilitySlice(),intent1); }); 通过设置Operation可以启动任意设备的任意应用的任意Ability： Intent intent = new Intent(); // 通过Intent中的OperationBuilder类构造operation对象，指定设备标识（空串表示当前设备）、应用包名、Ability名称 Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.demoapp\") .withAbilityName(\"com.demoapp.FooAbility\") .build(); // 把operation设置到intent中 intent.setOperation(operation); startAbility(intent); ","date":"2022-02-08","objectID":"/harmonyos_ability/:3:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"PageAbility 一个PageAbility可以包含任意个AbilitySlice，默认展示的AbilitySlice是通过**setMainRoute()**方法来指定的。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:4:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"AbilitySlice AbilitySlice相当于一个页面，其显示的内容是通过组件来声明的，其组件加载⽀持两种⽅式： Java代码 xml布局文件 在其onStart方法中通过 setUIContext 来加载视图组件，它有两个重载： setUIContext(int) : 通过布局⽂件的ID，加载resources/base/layout⽬录下的布局⽂件完成⻚⾯的渲染。 setUIContext(ComponentContainer) :通过加载⼀个使⽤Java代码创建的组件完成⻚⾯的渲染 。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:4:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"ServiceAbility HarmonyOS文档\r\r基于Service模板的Ability（以下简称“Service”）主要用于后台运行任务（如执行音乐播放、文件下载等），但不提供用户交互界面。Service可由其他应用或Ability启动，即使用户切换到其他应用，Service仍将在后台继续运行。\r\r ","date":"2022-02-08","objectID":"/harmonyos_ability/:5:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"前台Service 一般情况下，Service都是在后台运行的，后台Service的优先级都是比较低的，当资源不足时，系统有可能回收正在运行的后台Service。 在一些场景下（如播放音乐），用户希望应用能够一直保持运行，此时就需要使用前台Service。前台Service会始终保持正在运行的图标在系统状态栏显示。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:5:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"DataAbility HarmonyOS文档\r\r使用Data模板的Ability（以下简称“Data”）有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。Data既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。 数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。Data对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供 \r\r ","date":"2022-02-08","objectID":"/harmonyos_ability/:6:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"URI URI用来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。格式如下： scheme：协议方案名，固定为“dataability”，代表Data Ability所使用的协议类型。 authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。 path：资源的路径信息，代表特定资源的位置信息。 query：查询参数。 fragment：可以用于指示要访问的子资源。 URI示例： 跨设备场景：dataability://device_id/com.domainname.dataability.persondata/person/10 本地设备：dataability:///com.domainname.dataability.persondata/person/10 ","date":"2022-02-08","objectID":"/harmonyos_ability/:6:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"数据操作 DataAbility可以对文件或数据库进行数据操纵，不同类型数据管理方式写法都不一样，详见文档的数据管理一栏： ","date":"2022-02-08","objectID":"/harmonyos_ability/:6:2","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"实践工程 页面导航 ServiceAbility 电话簿 ","date":"2022-02-08","objectID":"/harmonyos_ability/:7:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"结束语 本文仅是对官方文档做一个简单的总结+个人理解，详细的内容还需参考官方文档。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:8:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS——文档 ","date":"2022-02-08","objectID":"/harmonyos_ability/:8:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"电话簿 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"项目结构 ├─ entry.src.main\r├─ com.example.address_book\r├─slice\r├─ UserAddSlice\r├─ UserListSlice\r└─ MainAbilitySlice\r├─ DataBaseAbility ├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r├─ ability_main.xml\r├─ user_add.xml\r└─ user_list.xml\r","date":"2022-02-08","objectID":"/harmonyos_addressbook/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"效果 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"数据库结构 数据库UserStore：本地、关系型 表users 属性userId：int、主键、自增 属性userName：text、不为空 属性userTel：text、唯一 属性userAddr：text ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"MainAbilitySlice 核心代码： MainAbilitySlice的onStart方法： Button btn1 = (Button) findComponentById(ResourceTable.Id_btn1); btn1.setClickedListener(listener-\u003epresent(new UserAddSlice(),new Intent())); Button btn2 = (Button) findComponentById(ResourceTable.Id_btn2); btn2.setClickedListener(listener-\u003epresent(new UserListSlice(),new Intent())); 执行简单的页面跳转。 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"DataBaseAbility 核心代码： DataBaseAbility类： private RdbStore rdbStore; private StoreConfig config = StoreConfig.newDefaultConfig(\"UserStore.db\"); RdbStore对象：表示与数据库的连接，通过此对象可以完成对数据表中数据的CRUD操作 StoreConfig对象：关联数据⽂件配置(数据库) private RdbOpenCallback callback = new RdbOpenCallback() { @Override public void onCreate(RdbStore rdbStore) { //使⽤rdbStore对象执⾏SQL创建数据表 rdbStore.executeSql(\"create table if not exists users(\" + \"userId integer primary key autoincrement,\" + \"userName text not null,\" + \"userTel text not null unique,\" + \"userAddr text)\"); } }; RdbOpenCallback.onCreate()：数据库创建时被回调，初始化，创建数据表users（当其不存在时）。 DataBaseAbility类的onStart方法： @Override public void onStart(Intent intent) { super.onStart(intent); HiLog.info(LABEL_LOG, \"DataBaseAbility onStart\"); //初始化与数据库的连接 DatabaseHelper helper = new DatabaseHelper(this); rdbStore = helper.getRdbStore(config,1,callback); } 重写insert方法： public int insert(Uri uri, ValuesBucket value) { int i = -1; String path = uri.getLastPath(); if(\"users\".equalsIgnoreCase(path)){ i = (int)rdbStore.insert(\"users\",value); } return i; } 重写query、delete、update方法： public ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) { RdbPredicates rdbPredicates = DataAbilityUtils.createRdbPredicates(predicates, \"users\"); ResultSet resultSet = rdbStore.query(rdbPredicates, columns); return resultSet; } public int delete(Uri uri, DataAbilityPredicates predicates) { RdbPredicates rdbPredicates = DataAbilityUtils.createRdbPredicates(predicates, \"users\"); int i = rdbStore.delete(rdbPredicates); return i; } public int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) { RdbPredicates rdbPredicates = DataAbilityUtils.createRdbPredicates(predicates, \"users\"); int i = rdbStore.update(value, rdbPredicates); return i; } ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"UserAddSlice 核心代码： public class UserAddSlice extends AbilitySlice { private DataAbilityHelper dataAbilityHelper; @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_user_add); dataAbilityHelper = DataAbilityHelper.creator(this); //获取组件对象 Button btn_add = (Button) findComponentById(ResourceTable.Id_btn_add); TextField tf1 = (TextField) findComponentById(ResourceTable.Id_textField1); TextField tf2 = (TextField) findComponentById(ResourceTable.Id_textField2); TextField tf3 = (TextField) findComponentById(ResourceTable.Id_textField3); //绑定事件监听器 btn_add.setClickedListener(component -\u003e { String userName = tf1.getText(); String userTel = tf2.getText(); String userAddr = tf3.getText(); //构造VB ValuesBucket valuesBucket = new ValuesBucket(); valuesBucket.putString(\"userName\",userName); valuesBucket.putString(\"userTel\",userTel); valuesBucket.putString(\"userAddr\",userAddr); //插入数据 try{ Uri uri = Uri.parse(\"dataability:///com.example.address_book.DataBaseAbility/users\"); int i = dataAbilityHelper.insert(uri,valuesBucket); System.out.println(\"------------\u003e\u003e\u003e\u003e\u003e\u003e\"+i); }catch (DataAbilityRemoteException e){ e.printStackTrace(); } }); } } 数据库的相关操作要依靠dataAbilityHelper。 从TextField组件中获取输入的信息。 设置监听器，将获得的信息插入数据表。 插入数据通过ValuesBucket储存，指数据表的一行。 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"UserListSlice 核心代码： public class UserListSlice extends AbilitySlice { private DataAbilityHelper dataAbilityHelper; @Override protected void onStart(Intent intent) { super.onStart(intent); this.setUIContent(ResourceTable.Layout_user_list); Text text = (Text) findComponentById(ResourceTable.Id_infoText); text.setText(\"\"); dataAbilityHelper = DataAbilityHelper.creator(this); //查询所有联系⼈信息 Uri uri = Uri.parse(\"dataability:///com.example.address_book.DataBaseAbility/users\"); String[] colums = {\"userId\",\"userName\",\"userTel\",\"userAddr\"}; DataAbilityPredicates dataAbilityPredicates = new DataAbilityPredicates(); try { ResultSet rs = dataAbilityHelper.query(uri,colums,dataAbilityPredicates); //从rs中获取查询结果 int rowCount = rs.getRowCount(); if(rowCount\u003e0){ rs.goToFirstRow(); do{ int userId = rs.getInt( 0); String userName = rs.getString(1); String userTel = rs.getString(2); String userAddr = rs.getString(3); String info = \" [\"+userId+\",\"+userName+\",\"+userTel+\",\"+userAddr+\"]\"; text.setText( text.getText()+info ); }while(rs.goToNextRow()); } } catch (DataAbilityRemoteException e) { e.printStackTrace(); } } } 通过调用查询接口来查询。 ResultSet为查询结果集，类似于指针，指向结果的第一行。 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:7:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"项目源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/address_book ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:7:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS文档——关系型数据库 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:7:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"ServiceAbility实践 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"项目结构 ├─ entry.src.main\r├─ com.example.serviceability\r├─slice\r└─ MainAbilitySlice\r├─ MainAbility ├─ MyService\r└─ MyApplication\r├─ resources.base.layout\r└─ ability_main.xml\r└─ config.json\r","date":"2022-01-29","objectID":"/harmonyos_serviceability/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"效果 按钮1开启MyService。 按钮2连接到MyService。 按钮3断开与MyService的连接。 按钮4关闭MyService。 服务运行时会在状态栏显示。 不同的点击顺序，命令行输出的提示信息不同。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"铺垫 在MyService里的每个生命周期函数里都加一句sout来显示各个方法执行的顺序。 public class MyService extends Ability { private static final HiLogLabel LABEL_LOG = new HiLogLabel(3, 0xD001100, \"Demo\"); //在每个生命周期函数内加一句sout调试 @Override public void onStart(Intent intent) { super.onStart(intent); HiLog.error(LABEL_LOG, \"MyService::onStart\"); System.out.println(\"--------------------onStart\"); } @Override public void onBackground() { super.onBackground(); HiLog.info(LABEL_LOG, \"MyService::onBackground\"); System.out.println(\"--------------------onBackground\"); } @Override public void onStop() { super.onStop(); HiLog.info(LABEL_LOG, \"MyService::onStop\"); System.out.println(\"--------------------onStop\"); } @Override public void onCommand(Intent intent, boolean restart, int startId) { System.out.println(\"--------------------onCommand\"); } @Override public IRemoteObject onConnect(Intent intent) { System.out.println(\"--------------------onConnect\"); return new LocalRemoteObject() {}; } @Override public void onDisconnect(Intent intent) { System.out.println(\"--------------------onDisconnect\"); } } ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"开启和关闭ServiceAbility 此部分和”页面导航“里开启Ability的操作如出一辙，也就是说，我们只是在开启和关闭Ability，至于它是什么类型，无所谓。 核心代码： ​ MainAbilitySlice的onStart方法： //按钮1开启MyService Button btn1 = (Button) findComponentById(ResourceTable.Id_btn1); btn1.setClickedListener(component -\u003e { Intent intent1 = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.example.serviceability\") .withAbilityName(\"com.example.serviceability.MyService\") .build(); intent1.setOperation(operation); this.startAbility(intent1); }); //按钮4关闭MyService Button btn4 = (Button) findComponentById(ResourceTable.Id_btn4); btn4.setClickedListener(component -\u003e { Intent intent3 = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.example.serviceability\") .withAbilityName(\"com.example.serviceability.MyService\") .build(); intent3.setOperation(operation); this.stopAbility(intent3); }); 通过id获取Button对象，设置事件监听器。 调用startAbility和stopAbility方法，在intent对象的Operation属性里指定开启哪台设备的哪个应用的哪个Ability。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"建立连接 核心代码： ​ MainAbilitySlice的onStart方法： //按钮2连接到MyService Button btn2 = (Button) findComponentById(ResourceTable.Id_btn2); IAbilityConnection connection = new IAbilityConnection() { @Override public void onAbilityConnectDone(ElementName elementName, IRemoteObject iRemoteObject, int i) { System.out.println(\"----------------------连接MyService成功\"); } @Override public void onAbilityDisconnectDone(ElementName elementName, int i) { System.out.println(\"----------------------连接MyService失败\"); } }; btn2.setClickedListener(component -\u003e { Intent intent2 = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.example.serviceability\") .withAbilityName(\"com.example.serviceability.MyService\") .build(); intent2.setOperation(operation); this.connectAbility(intent2,connection); }); 通过id获取Button对象，设置事件监听器。 新建连接对象，重写onAbilityConnectDone和onAbilityDisconnectDone方法，每个方法里都写一句sout用于调试。 onAbilityConnectDone：连接成功建立后执行。 onAbilityDisconnectDone：连接建立失败后执行。 调用connectAbility方法，传递intent和connect对象。 ​ MyService： @Override public IRemoteObject onConnect(Intent intent) { System.out.println(\"--------------------onConnect\"); return new LocalRemoteObject() {}; } 注意返回语句，返回一个LocalRemoteObject对象。 试图与Service建立连接时，触发onConnect方法，它返回一个LocalRemoteObject对象，在这个实例中它返回的是MyService这个Ability，触发回调函数onAbilityConnectDone或者onAbilityDisconnectDone。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"关闭连接 核心代码： MainAbilitySlice的onStart方法： //按钮3断开与MyService的连接 Button btn3 = (Button) findComponentById(ResourceTable.Id_btn3); btn3.setClickedListener(component -\u003e { if(connection != null){ this.disconnectAbility(connection); } }); 若connection对象存在，就调用disconnectAbility方法即可。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"前台Service 前台Service会始终保持正在运行的图标在系统状态栏显示。 核心代码： MyService的onStart方法： // 创建通知，其中1005为notificationId NotificationRequest request = new NotificationRequest(1005); NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent(); content.setTitle(\"title\").setText(\"text\"); NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content); request.setContent(notificationContent); // 绑定通知，1005为创建通知时传入的notificationId keepBackgroundRunning(1005, request); 这段进行一个简单的Ctrl+C、V就行，注意以下几个点： 1005这个notificationId不能与其他的服务重复 title和text在图中对应： config.json中还要申请常驻后台权限： \"reqPermissions\": [ {\"name\": \"ohos.permission.KEEP_BACKGROUND_RUNNING\"} ] 位置如图所示： ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"生命周期分析 整个执行过程如图所示： 启动： 若MyService已建立，执行onCommand。 若未建立，执行onStart和onCommand。 连接： 若MyService已建立，则执行onConnect。 若未建立，则执行onStart和onConnect（红字忽略）。 断开连接：当连接存在，且 MyService是手动创建的，不是由连接唤起的，只执行onDisconnect MyService是由该连接唤起的，执行onDisconnect、onBackground、onStop。 关闭：当MyService没有被连接时，才能关闭，执行onBackground和onStop。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:7:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:8:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"项目源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/ServiceAbility ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:8:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 HarmonyOS文档——ServiceAbility ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:8:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"页面导航 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"项目结构 ├─ entry.src.main\r├─ com.example.page_to_page\r├─slice\r├─ AnotherAbilitySlice\r├─ MainAbilitySlice\r└─ SecondAbilitySlice\r├─ AnotherAbility ├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r├─ ability_another.xml\r├─ ability_main.xml\r└─ ability_second.xml\r","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"效果 点击按钮一，从MainAbilitySlice跳转到SecondAbilitySlice。 点击按钮二，从MainAbilitySlice跳转到SecondAbilitySlice，并传递参数字符串。 点击按钮三，从MainAbility的MainAbilitySlice跳转到AnotherAbility的AnotherAbilitySlice。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"intent HarmonyOS文档——intent intent是对象之间传递信息的载体，Slice之间的导航、传参以及Ability之间的导航都是基于intent。Intent的构成元素包括Operation与Parameters。Operation是执行的操作，Parameters则是携带的参数。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"Slice间导航 核心代码： MainAbilitySlice的onStart方法： Button btn1 = (Button) findComponentById(ResourceTable.Id_btn1); btn1.setClickedListener(listener-\u003epresent(new SecondAbilitySlice(),new Intent())); 通过id获取按钮对象。 给按钮绑定事件监听器，执行present方法。 这里只是导航，没有其他操作，所以传递一个默认intent即可。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"Slice间传参 核心代码： Button btn2 = (Button) findComponentById(ResourceTable.Id_btn2); btn2.setClickedListener(listener -\u003e { Intent intent1 = new Intent(); intent1.setParam(\"my_string\",\"从MainAbilitySlice传参\"); this.present(new SecondAbilitySlice(),intent1); }); 跟导航部分思路相同。 传参的关键是构造intent对象的Parameters属性，使用setParam方法存储键值对。setParam方法有很多重载，包括int，string等等，但是没有对象类型，也就是传参不能传对象。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"PageAbility间导航 核心代码： MainAbilitySlice类的onStart方法： Button btn3 = (Button) findComponentById(ResourceTable.Id_btn3); btn3.setClickedListener(listener -\u003e navigateToAnotherPage(listener)); 设置监听器的逻辑相同，不过这次我们让监听器执行我们的自定义函数navigateToAnotherPage。 MainAbilitySlice类新增: private void navigateToAnotherPage(Component component){ Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") //空字符串为本机 .withBundleName(\"com.example.page_to_page\")//本应用的标识 .withAbilityName(\"com.example.page_to_page.AnotherAbility\")//想启动的Ability .build(); intent.setOperation(operation); this.startAbility(intent); } 使用OperationBuilder构建一个Operation，设置给intent。 将intent传给监听器 页面跳转的核心是intent对象的Operation属性，这里构建Operation有三个参数DeviceId、BundleName、AbilityName，因为鸿蒙可以启动任意设备的任意应用的任意Ability，可能这就是万物互联吧。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"项目源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/page_to_page ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:6:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 HarmonyOS文档——intent ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:6:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"DevEco Studio HUAWEI DevEco Studio（获取工具请点击链接下载，以下简称DevEco Studio）是基于IntelliJ IDEA Community开源版本打造，面向华为终端全场景多设备的一站式集成开发环境（IDE），为开发者提供工程模板创建、开发、编译、调试、发布等E2E的HarmonyOS应用/服务开发 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:0:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"配置 DevEco是基于IDEA打造的，所以二者非常相似，有些配置不会的话可以直接google IDEA的相关配置。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"界面风格 将界面风格改为暗黑模式 打开设置：file\u003esettings Appearance \u0026 Behavior \u003e Appearance Theme：改为Darcula，点击OK。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:1","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"字体 打开设置：file\u003esettings Editor \u003e Font Font：字体风格，我个人比较喜欢Inconsolata ; Size：字号 ; Line height：行距 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:2","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"注释颜色 初始的注释颜色非常浅，还是灰色，所以想调成亮一点的绿色。 打开设置：file\u003esettings Editor \u003e Color Scheme \u003e Language Default 点开Comments，其中Block comment是块注释，Line comment是行注释，尽量二者颜色统一吧，颜色栏是可以复制的。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:3","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"输入联想——大小写不敏感 初始的输入联想是大小写敏感的，Str才能补全成String，设置大小写不敏感，使str也能补全成String。 打开设置：file\u003esettings Editor \u003e General \u003e Code Completion 去掉右侧Match case的勾 效果如下： ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:4","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"自动引包优化 打开设置：file\u003esettings Editor \u003e General \u003e Auto import 在右侧勾上如图的两句话。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:5","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"汉化 编辑器设中文其实意义不大，汉化部分很少，都是一些基础的单词，但是我看到中文有一种莫名的安心感，所以还是汉化了。 打开设置：file\u003esettings Plugins 搜索chinese，在installed里找到Chinese (Simplified) ，点击enable。 注意你会在Marketplace里找到Chinese (Simplified) Language Pack，它是IDEA的插件，适配效果没有内置的好。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:6","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"拼写检查 拼写检查默认开启，有时会提示一些莫名其妙的单词，非常难受，所以将其关掉。 打开设置：file\u003esettings Editor \u003e Inspections \u003e Spelling 将右侧的勾取消。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:7","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"同时打开多项目 默认情况下只能打开一个项目窗口，新的项目会覆盖之前打开的项目，如果要参考其他项目的代码就比较困难。 打开设置：file\u003esettings Appearance \u0026 Behavior \u003e System Settings 选择Open project in new window ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:8","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"项目结构 坑，待填。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:2:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"调试方法 鸿蒙项目有两种调试方式：previewer和在设备运行 Previewer previewer本质上是个页面预览器，预览的页面是工作区前台的Page。位置在： 在设备运行 设备有很多种，本地模拟器、远程模拟器、远程真机等等（细节可以看官方文档），都是将整个项目完整的打包成应用在设备上运行。推荐使用远程模拟器，因为本地模拟器会占用相当大一部分的本机资源。在右上角打开设备管理器即可进行管理。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:3:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"选择调试方式 设备：不管是远程还是本地，使用上都会有一定的卡顿，并且项目具有默认显示页面，调试非默认页面时，需要保证跳转逻辑等等无误。 预览器：工作区打开什么文件就默认预览什么文件，不需要考虑其他页面或者Ability的逻辑，但是，预览器是高度阉割的，某些逻辑不能很好的在预览器运行，比如我昨天遇到一个报错`[ClassCastException: java.lang.Object cannot be cast to java.lang.String，在预览器中运行就会报这个错误无法启动预览器，但是在设备中运行就正常。所以要灵活选择调试方式。当然，不提供页面服务的Ability的肯定要在设备上测试。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:3:1","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:4:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"参考文献 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:4:1","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["Code error"],"content":"1 Bug\r\r不可转换的类型；无法将 ‘ohos.agp.components.Component’ 转换为 ‘ohos.ai.cv.text.Text’\r\r 原因：使用Tab键补全Text时，Studio自动引库引到了错误的库import ohos.ai.cv.text.Text;，实际应当是import ohos.agp.components.Text;。 ","date":"2022-01-27","objectID":"/harmonyos_application_error/:0:1","tags":["HarmonyOS","Java"],"title":"程序报错总结——HarmonyOS","uri":"/harmonyos_application_error/"},{"categories":["Code error"],"content":"2 Bug\r\rjava.lang.NullPointerException: Attempt to invoke virtual method ‘void ohos.agp.components.Button.setClickedListener(ohos.agp.components.Component$ClickedListener)’ on a null object reference\r\r 原因：在写xml文件时，误把注释写成了//，应该是\u003c!-- --\u003e。这里它不会直接报错，而是说我获得的按键对象为空，说明xml构建出了问题。 ","date":"2022-01-27","objectID":"/harmonyos_application_error/:0:2","tags":["HarmonyOS","Java"],"title":"程序报错总结——HarmonyOS","uri":"/harmonyos_application_error/"},{"categories":["Code error"],"content":"3 Bug\r\rohos.agp.window.wmc.AGPWindowManager$O000000: Can’t show toast, Looper.don’t prepare\r\r 原因：一般是因为在子线程中直接操作UI导致的，这个主要是指导致UI重绘的操作，指上图中的.show()，.setText()是可以在子线程中正常使用的。 解决办法：利用getUITaskDispatcher把UI操作返回到主线程中。 ","date":"2022-01-27","objectID":"/harmonyos_application_error/:0:3","tags":["HarmonyOS","Java"],"title":"程序报错总结——HarmonyOS","uri":"/harmonyos_application_error/"},{"categories":["Paper"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/6461198 IEEE Communications Magazine Volume 51 Issue 2 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:1:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"摘要 在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是SDN所独有的。我们探讨了在不同环境中经常出现的问题，讨论了SDN设计空间中可扩展性的权衡，并介绍了一些关于SDN可扩展性的最新研究。此外，我们还列举了在可扩展性方面的重要机遇和挑战。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:2:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"引言 普遍认为SDN中的控制是集中的，这导致了对SDN可伸缩性和弹性的关注。毕竟，无论控制器的能力如何，中央控制器都不会随着网络的增长而扩展(增加交换机、流量、带宽等的数量)，并且在提供相同的服务保证的同时也无法处理所有传入的请求。此外，由于大多数早期的SDN提议都是基于流的，额外的流启动延迟成为一个问题。 我们认为SDN的可扩展性没有固有的瓶颈;我们认为这些可扩展性限制并不局限于SDN;传统的控制协议设计也面临着同样的挑战。虽然这并没有解决这些问题，但这表明我们在SDN中不需要比在传统网络中更担心可扩展性。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:3:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"SDN中可扩展性的根源 SDN与传统数据网络的根本区别在于控制与转发平面的分离。这种解耦导致了一些有趣的特性。 然而，这种解耦也有它自己的陷阱。在这两个平面之间定义一个标准的API是绝对重要的。从技术上讲，这个API应该能够处理各种体系结构的需求，并且应该能够促进这两个平面的独立演化。此外，所有或大多数交换机供应商应该采用相同的标准API，以使其有用；否则，网络将与特定的供应商绑定，会阻碍网络的快速变化和创新。将传统的本地控制功能移动到远程控制器可能会导致新的瓶颈。它还可能导致信令开销。 在接下来的内容中，我们首先讨论SDN控制器的可扩展性，概述为什么它一直受到关注，以及最近在这个领域的工作。然后，我们回顾一些其他经常提到的SDN可扩展性问题，包括流程设置开销和故障恢复能力。我们认为，尽管这些问题不是SDN特有的，但它们可以通过另一种设计来缓解(其中一些设计现在很常见)。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:4:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"控制器可扩展性 一种可能的SDN设计是将所有的控制功能推到一个集中式控制器上。控制器有可能成为网络操作中的瓶颈，随着网络规模的增长，更多的事件和请求会被发送到控制器，并且在某个时刻，控制器无法处理所有传入的请求。缓解这种担忧的一种方法是在多核系统中提高并行性，并提高IO性能。第二种方法是减少转发到控制器的请求数量，比如DevoFlow通过底层网络约束，牺牲细粒度流级可见性（ fine-grained flow-level visibility）换来了可扩展性。 或者，还可以将控制功能的状态和/或计算分配到多个控制器上。提供一个严格一致的集中视图可能会阻碍响应时间和吞吐量。在保持可用性和分区容差的同时实现强一致性并不总是可行的。因此，选择一个合适的一致性水平是SDN中一个重要的设计权衡。 有一些解决方案，我们可以物理地分布控制平面元素，同时保持网络范围的视图。例如，Onix就是一个分布式控制平台，它促进了分布式控制平面的实现。它为控制应用程序提供了一组通用api，以方便访问分布在Onix实例上的网络状态(NIB)。另一方面，HyperFlow在多个控制器实例之间同步网络状态，使控制应用程序(在每个控制器实例上运行)产生控制整个网络的错觉。这保持了在中央控制器上开发控制平面的简单性，同时减轻了与中央控制器相关的可伸缩性问题，尽管这是针对满足某些特性的一组更受限制的控制应用程序。 Kandoo[9]采用了一种不同的方法来分配控制平面。它定义了一个操作范围，使具有不同要求的应用程序能够共存：本地作用域的应用程序（即，可以使用交换机的本地状态进行操作的应用程序）部署在数据路径附近，以处理频繁的请求并保护控制平面的其他部分免受负载。另一方面，根控制器负责需要网络范围状态的应用程序，同时也充当本地控制器之间需要的任何协调的中介。 一个有趣的观察结果是，SDN中的控制平面可扩展性挑战（例如，收敛性和一致性要求）与传统网络设计中所面临的挑战并没有本质上的不同。SDN本身既不太可能消除控制平面设计的复杂性，也不太可能使其或多或少具有可扩展性。 与传统网络不同，在SDN中，我们不需要反复解决基本但具有挑战性的问题，如拓扑发现、状态分布和恢复力。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:5:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"其他SDN可扩展性问题 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:6:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"流启动开销 让我们回顾一下流设置过程来解释瓶颈，并展示一个好的设计如何可以避免它们： 包到达但是没有匹配到流规则 交换机产生一个流请求给控制器 控制器返回一个新的流转发规则 交换机更新流表 前三个步骤和最后一个步骤的性能部分取决于交换机能力和资源(管理CPU、内存等)【？这里为什么要说前三个和最后一个】。以及其软件堆栈的性能。第三步中的延迟是由控制器的资源以及控制程序的性能来决定。最后，交换机的FIB更新时间导致了完成流程设置过程的延迟。 目前支持OpenFlow的软交换机性能远好于硬件交换机，原因是交换机上缺乏资源（管理CPU），对交换机芯片组和管理CPU之间的高频通信的支持不足，以及不佳的软件实现。可以预见，FIB更新时间将成为开关侧流设置延迟的主要因素。 While we argue that controllers and, in the near future, switches would be able to sustain sufficient throughput with negligible latency for reactive flow setup, in the end the control logic determines the scalability of a reactive design. A control program installing an end-to-end path on a per-flow basis does not scale, because the per switch memory is fixed but the number of forwarding entries in the data path grows with the number of active flows in the network. However, the control program may install aggregate rules matching a large number of micro-flows (thereby facing the same scalability challenges as a proactive design), or proactively install rules in the network core to provide end-to-end connectivity and identify quality of service (QoS) classes, while classifying and reactively labeling flows at the edge. A viable solution to the scalability challenges of the proactive designs in the former class due to data path memory scarcity is proposed in DIFANE [5]; while the scalability the latter class follows from the observation that the fanout of an edge switch and thus the number of flows initiated there is bounded (just add edge controllers as the network grows in size). 【没看懂】 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:6:1","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"故障恢复 早期的系统为单中心控制的设计树立了榜样，因此对故障的恢复能力一直是一个主要问题。一个状态同步的从控制器将足以从控制器故障中恢复，但一个网络分区将留下一半的网络无脑。在多控制器网络中，如果有适当的控制器发现机制，交换机总是可以发现一个存在于其分区中的控制器。因此，在一个可伸缩的发现机制下，控制器故障不会对SDN的可伸缩性构成挑战。 响应于链路失效的收敛有五个步骤。交换机检测到变化。然后交换机通知控制器。在收到通知后，控制程序计算修复操作，并将更新推到受影响的数据路径元素，这些元素反过来更新它们的转发表。在传统网络中，链路故障通知会在整个网络中泛滥，而在SDN中，该信息直接发送到控制器。因此，SDN网络中的信息传播时延并不比传统网络差。另外，SDN的一个优点是，计算是在更有能力的控制机器上进行的，而不是在所有交换机的弱管理cpu上进行的，无论它们是否受到故障的影响。 请注意，上述参数建立在隐含的假设之上，即故障的交换机或链路不影响交换机-控制器通信信道。如果有一个出现故障的链路或交换机是控制网络本身的一部分，则需要首先修复控制网络本身。因此，在这种角落的情况下，收敛速度可能比传统网络要慢。 总的来说，SDN中的故障恢复过程并不比传统网络中的更差。因此，存在类似的可伸缩性问题，并且在传统网络中用于最小化停机时间的相同技术也适用于SDN。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:6:2","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"不同的网络设置中的可伸缩性 采用一种不同的方法，解释不同类型网络中的可伸缩性模式和陷阱。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:7:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"数据中心 一个典型的数据中心网络有数万个交换元件，并且可以快速增长。在该规模的任何网络中生成的控制事件的绝对数量足以使任何集中式控制器过载。解决这个问题的一种方法是主动在交换机上安装规则，在它们进入控制平面之前有效地消除大多数控制请求。当然，这里的成本是控制器精度和反应性的损失。 当应用程序需要精确的流量统计和/或响应性时，可以将应用程序部署在交换机附近。例如，只要最小化对全局状态的访问，就可以将频繁的事件委托给运行在终端主机上的进程。考虑到整个数据中心网络的处理资源可用性，可以使用像Kandoo[9]这样的解决方案达到任意可伸缩性级别。分布式控制器(如HyperFlow或Onix)也可以是数据中心网络的合理解决方案。考虑到这种网络中的低延迟，状态和流设置的同步延迟将是最小的，对于大多数应用程序来说是可以接受的。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:7:1","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"服务提供商网络 通常，服务提供商网络没有数据中心网络那么多的交换机/路由器；然而，这种网络中的节点通常是在地理上分布的。这些网络的大直径加剧了控制器的可伸缩性问题、流设置和状态收敛延迟以及一致性要求。我们可以利用网络的物理分布将其划分为单独的区域；每个分区都可以由一个独立的控制器控制，这些控制器只能交换所需的状态变化事件，有效地向外部控制器隐藏了大部分事件。考虑到这种网络中固有的延迟，所有的控制应用程序都应该是容忍延迟的，并且有较弱的一致性要求。 除了高延迟外，服务提供商网络通常比其他网络有更多的流量。因此，这里也关注数据路径资源限制。流的聚合是一个简单的解决方案，它以控制中的粒度为代价。我们注意到，这些问题也存在于传统的网络中，而这并不是SDN所独有的。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:7:2","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"机遇和挑战 传统上，网络的可伸缩性是基于性能指标来研究的，也就是说，当我们沿着给定的维度扩展网络时，特定的性能指标是如何变化的。在实践中，还有其他正交的方面深刻地影响系统如何适应增长。例如,可管理性(如何方便地管理网络,在大尺度状态下添加,删除,或修改网络元素)和功能可伸缩性(是否方便将新功能添加到网络)与网络可伸缩性、性能一样重要，不应被忽视。关于行为和编程抽象、测试和验证以及SDN可扩展性的初步结果表明，我们认为SDN在这一领域提供了一个重要的机遇。显然，在我们能够充分发挥SDN的潜力之前，我们在这些方面都面临着重大挑战。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"行为和编程抽象 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:1","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"测试和验证 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:2","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"可延展性 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:3","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"结论 自SDN引入以来，可伸缩性一直是一个主要问题。目前关于SDN可伸缩性的研究表明： 这些担忧既不是由SDN引起的，也不是由SDN所独有的。 这些问题大多可以得到解决，而不会失去SDN的好处。 在这个领域，通常被忽视的是SDN对网络增长的其他限制因素的影响，如网络规划和管理复杂性。软件定义的网络增加了一种灵活性，可以大规模地适应网络编程和管理。传统的网络在这一领域历来都失败过。最近在这个方向上的尝试非常有希望，尽管未来仍面临许多挑战。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:9:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/6739370 IEEE Communications Surveys \u0026 Tutorials Volume 16 Issue 3 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:1:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"摘要 本文综述了可编程网络的最新进展，重点介绍了SDN。我们提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:2:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"1 引言 传统网络出现的问题：网络管理和性能调优困难，网络僵化。 可编程网络具有革命性，比如软件定义网络，网络设备成为简单的包转发设备，可以通过开放的接口进行编程。 第二节：早期可编程网络 第三节：SDN及其体系结构，以及OpenFlow协议。 第四节：开发和测试SDN的平台和工具。 第五节：在数据中心和无线网络的应用。 第六节：面临的挑战和未来发展的方向。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:3:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"2 早期可编程网络 描述了一些SDN和OpenFlow概念的前身，在早期的一些项目中已经有了关于可编程网络和数控平面分离的思想。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:4:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"3 SDN体系结构 路由器和交换机通常是封闭的系统，只有很少的提供给供应商的接口。适配新版本的协议（比如Ipv6）非常困难，更不用说部署全新的协议和服务。网络僵化效应主要是由于设备的数据和控制平面紧密耦合，新的app或功能的部署需要直接实现在物理设施中。解决网络僵化的一个手段是使用中间设备，比如CDN（内容交付网络）。 软件定义网络将转发硬件和控制逻辑分离，可以更容易地部署新协议和应用程序。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 当前SDN架构 目前有两种SDN架构：ForCES和OpenFlow ForCES将单个设备中的控制元素与转发元素分开，意图实现在单一网络设备中将转发硬件与第三方控制相结合。它定义了两个逻辑实体，转发元素FE和控制元素CE，它们通过ForCES协议通信，FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能。ForCES还有一个重要功能块LFB（逻辑功能块），它安装在FE上，通过CE进行控制，实现FE的配置和数据包处理。 OpenFlow完全将控制平面从网络设备上剥离，转发设备基于流表进行转发，流表控制着转发规则。没有匹配流表时按照“table-miss”流表项执行相应的动作，比如丢弃、转发给控制器。控制平面与转发平面通过OpenFlow协议进行通信，远程控制器可以添加、删除或更新交换机的流表项。 ForCES和OpenFlow的模型不同，但是可以实现相似的功能。 OpenFlow得到了各界的大力支持，以至于被认为是SDN的官方标准。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 转发设备 底层网络中，转发设备有路由器、交换机、无线接入点等。但是在SDN中，控制逻辑和算法都由控制器维护，基本转发硬件均被称为switches——交换机。 规则空间是OpenFlow可扩展性的瓶颈，在尊重网络策略和约束的同时，优化使用规则空间来服务于一定数量的流条目是一个具有挑战性和重要的课题。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 控制器 单个控制器能够处理惊人数量的新流请求，并且应该能够管理除最大的网络之外的所有网络。 交换机控制延迟对网络的整体行为有重大影响，因为每个交换机在从控制器收到插入流表中适当规则的消息之前不能转发数据。这个间隔可能会随着链路延迟而增加，并显著影响网络应用程序的性能。 控制建模对网络的可扩展性影响很大。 集中式和分布式：软件定义的网络可能具有集中式或分布式的控制平面。OpenFlow允许多个控制器连接到一台交换机上，这将允许备份控制器在出现故障时接管。软件定义的网络还可以具有一定程度的逻辑去中心化，具有多个逻辑控制器。 粒度控制：传统网络的基本元素是包。在软件定义网络中，网络元素是远程控制的，开销是由数据平面和控制平面之间的通信引起的。控制器对每个包做决策会增加额外的延迟，对流的第一个包所做的决策可以应用于该流的所有后续包，通过将流分组可以进一步减少开销。 被动控制和主动控制：这部分没看懂 P1624。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 南向接口：控制器——交换机 OpenFlow本身就是控制器——交换机交互的一种实现。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 北向接口：控制器——服务 目前还没有公认的针对北向交互的标准，而且它们更有可能在特定应用程序的特殊基础上实现。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"F 标准化工作 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:6","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"4 SDN开发工具 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 仿真和仿真工具 mininet,NS-3 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 可用软交换机平台 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 实体交换机 目前在商品网络硬件中实现的SDN主要技术是OpenFlow标准。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 可用控制器平台 其中有两个特殊用途的控制器：Flowvisor、RouteFlow Flowvisor：充当交换机和多个控制器之间的透明代理，它能够创建网络片，将每个片的控制委托给不同的控制器，促进了片之间的隔离。 RouteFlow：它由一个OpenFlow控制器应用程序、一个独立的服务器和一个虚拟网络环境组成，它可以复制物理基础设施的连接并运行IP路由引擎。路由引擎根据所配置的路由协议(如OSPF、BGP)，将转发信息库(FIB)生成到LinuxIP表中。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 代码验证和调试 NICE：自动化的测试工具，用于通过模型检查和符号执行来帮助发现OpenFlow程序中的bug。 Anteater：试图检查数据平面中存在的网络不变量，如连通性或一致性。这种方法的主要优点是它与协议无关；它还将捕获由错误的交换机固件或与控制平面通信不一致而导致的错误。 VeriFlow：进一步提出了一个驻留在控制器和转发元素之间的实时验证工具。能够停止在到达网络之前会导致异常行为的规则。 OFRewind：允许以不同的粒度记录网络事件（控制和数据），然后再回放以重现特定的场景，从而提供定位和排除导致网络异常的事件的机会。 ndb：为SDN实现了断点和数据包回溯。 STS：是一个由软件定义的网络故障排除模拟器。它是用python编写的，并且依赖于POX。它模拟了给定网络中的设备，允许进行测试用例，并识别产生给定错误的输入集。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"5 SDN应用 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 企业网络 校园网也算是特殊的企业网络。适当的管理在企业环境中至关重要，SDN可以通过编程方式执行和调整网络策略，以及帮助监控网络活动和调整网络性能。使用SDN实现的中间设备包括NAT，防火墙，负载平衡器和网络访问控制。对于更复杂的中间设备，直接实现导致性能下降，可以使用SDN提供统一控制和管理。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 数据中心 在大规模数据中心中能源消耗有很重要的成本，ElasticTree是一种电源管理器，利用SDN来寻找满足当前流量条件的最小功率网络的子集。B4是谷歌提出的SDN概念应用于数据中心环境中的实际例子，它是一个连接谷歌全球数据中心的广域网。B4被证明是高效的，而且工作经验表明，控制平面到数据平面通信和硬件编程开销造成的瓶颈是今后工作中需要考虑的重要问题。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 基于基础设施的无线接入网 OpenRoads：设想了一种软件定义蜂窝网络。 Odin：在企业无线局域网环境中引入了可编程性，它在控制器上构建一个访问点抽象，将关联状态与物理访问点分离，实现主动移动管理和负载平衡。 OpenRadio：专注于部署可编程无线数据平面，在PHY和MAC层而不是第三层，提供灵活性，旨在提供一个模块化接口，能够处理使用不同协议的流量子集，基于决策平面和转发平面分离的思想，操作员可以表示由处理平面模块(如FFT模块、维特比解码等)组装而来的决策平面规则和相应的动作。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 光网络 将SDN和OpenFlow标准应用于光传输网络的好处包括：提高光传输网络控制和管理灵活性，支持部署第三方管理和控制系统，以及通过利用虚拟化和SDN部署新的服务。 文献[88]-[93] ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 家庭和小型企业 随着低成本网络设备的广泛可用性，这些环境变得越来越复杂和普遍，对更仔细的网络管理和更严格的安全性的需求也相应地增加了。但是，在每个家庭和办公室都有一个专门的网络管理员是不现实的。 Calvert建议将控制器作为“家庭网络数据记录器”，创建可用于故障排除或其他目的日志。 Feamster建议外包第三方专家，通过远程控制可编程交换机和分布式网络监控和推理算法，来检测可能的安全问题。 文献[94]-[97] ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"5 研究所面临的挑战和未来的发展方向 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 控制器和交换机设计 可扩展性、性能、鲁棒性、安全性 DIFANE：流被主动推到交换机上，试图减少向控制器的请求数量。 Devoflow：建议处理交换机中的短寿命流和控制器中的长寿流，以减少流设置延迟和控制器开销。 [28]：主张用一系列规则匹配记录来替换ASIC上的计数器，并在CPU中处理它们，以允许高效访问计数器。 FLARE：专注于“深度可编程网络”的新型网络节点模型，它为数据平面、控制平面以及它们之间的接口提供了可编程性。 为了提高可扩展性，特别是为了可靠性和鲁棒性，人们已经认识到逻辑集中的控制器必须是物理分布的。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 软件定义互联网 目前许多关于SDN的工作都是在单个管理域的上下文中检查或提出解决方案。然而，那些管理本质上是分散的环境，比如互联网，需要一个逻辑分布的控制平面。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 控制器——服务交互 目前南向接口定义的相当好，但是北向接口却没有统一的标准，一种可能的解释是，北向接口完全是在软件中定义的，而南向接口必须支持硬件实现。 如果我们认为控制器是一个“网络操作系统”，那么应该有一个明确定义的接口，应用程序可以访问底层硬件（交换机），与其他应用程序共存和交互，并利用系统服务（例如拓扑发现、转发），而不需要应用程序开发人员知道控制器的实现细节。 此外，北向的API应该允许应用程序对同一流应用不同的策略(例如，通过目的地进行转发和通过源IP进行监控)。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 虚拟化和云服务 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 以信息为中心的网络 信息中心网络(ICN)是针对未来互联网架构提出的一种新的范式，它旨在提高内容交付的效率和内容可用性。他们的驱动动机是，当前的互联网是信息驱动的，但网络技术仍然专注于基于位置的寻址和主机对主机的通信的想法。通过提出一种处理命名数据而不是命名主机的体系结构，内容分发可以直接实现到网络结构中，而不是依赖于目前用于将内容映射到单个位置的复杂映射、可用性和安全机制。 ICN中信息处理和转发的分离与SDN中数据平面和控制平面的解耦相一致。然后，问题就变成了如何将ICN和SDN结合起来。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"F 异构网络支持 未来网络面临的一个主要挑战是资源的有效利用；在无线多跳自组网中尤其如此，因为可用的无线容量本质上是有限的。这是由于许多因素，包括共享物理介质的使用、无线信道损坏和受管理基础设施的缺乏。自组织网络缺乏专用资源，而且连接性的变化使容量共享变得困难。底层网络的异构特性（例如，物理介质、拓扑结构、稳定性）和节点（例如，缓冲区大小、功率限制、移动性）在考虑路由和资源分配时也增加了另一个重要的因素。 迄今为止的SDN技术，如OpenFlow，主要针对基于基础设施的网络。它们促进了一种不适合在无基础设施环境中出现的分散、中断和延迟级别的集中控制机制。虽然之前的工作已经研究了SDN在无线环境中的使用，但其范围主要集中在基于基础设施的部署。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:6","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"7 结束语 在本文中，我们提供了一个可编程网络的概述，并在此背景下，考察了软件定义网络(SDN)的新兴领域。我们来看看可编程网络的历史，从早期的想法到最近的发展。我们特别详细描述了SDN体系结构以及OpenFlow[2]标准。我们介绍了当前的SDN实现和测试平台，并检查了基于SDN范式开发的网络服务和应用程序。最后，我们讨论了SDN所支持的未来发展方向，从支持异构网络到信息中心网络(ICN)。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:9:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"语句摘录 As a result, network management and performance tuning is quite challenging and thus error-prone. 因此，网络管理和性能调优非常具有挑战性，所以很容易出错。 Because of its huge deployment base and the fact it is considered part of our society’s critical infrastructure (just like transportation and power grids), the Internet has become extremely difficult to evolve both in terms of its physical infrastructure as well as its protocols and performance. 由于其庞大的部署基础，且被视为我们社会关键基础设施(就像交通和电网)的一部分，所以互联网在其物理基础设施、协议和性能方面的发展已经变得极其困难。 As SDN becomes more widely adopted and protocols such as OpenFlow are further defined, new solutions are proposed and new challenges arise. 随着SDN被广泛采用，并且OpenFlow等协议被进一步定义，新的解决方案被提出，新的挑战出现. The Internet has revolutionized the way we, as individuals and as a society, live, work, conduct business, socialize, get entertainment, etc. As a result, the Internet is now considered part of our society’s critical infrastructure much like the power, water, and transportation grids. 互联网已经彻底改变了我们作为个人和社会、生活、工作、做生意、社交、获得娱乐等方面的方式。因此，互联网现在被认为是我们社会关键基础设施的一部分，就像电力、水和交通电网一样。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:10:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["SDN"],"content":"自学习交换机 交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。 SDN的自学习交换机跟传统交换机不一样的点有： 帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。 自学习的过程中可能会有流表的变化。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:1:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"ping命令过程 ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。 局域网ping命令的执行过程： 网络模型为：h1 —- s1 —- h2，两台主机连接到同一个交换机。 假设h1 ping h2 首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。 交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。 h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。 h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。 h2收到报文后应答，ping完成。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:2:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验分析 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验内容 通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：ryu源码解读——simple_switch.py。 使用OVS搭建网络模型：h1 —- s1 —- h2，将s1连接到控制器。 h1 ping h2，观察PacketIn消息。 查看s1的流表变化。 这里不用mininet平台搭建网络的原因是：mininet主机会定时检查与交换机的连接，导致出现很多的冗余PacketIn消息，不利于观察。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:1","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验结果 当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。 使用ovs-ofctl dump-flows s1命令观察流表，结果如下： 执行完ping命令后多了两条流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:2","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"流程分析 日志的输出格式是：packet in \u003c交换机标号\u003e \u003c源mac\u003e \u003c目的mac\u003e \u003c输入端口\u003e h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。 h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。 控制器学习到mac1--端口1，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。 s1广播，h2收到并学习到h1的mac地址，发送\u003csrc = mac2，dst = mac1\u003e的ARP应答报文，s1流表为空，发送PacketIn消息。 控制器学习到mac2--端口2，查找到mac1的对应端口为1，此时下发一条流表in_port=2,output:1，发送PacketOut消息指示s1把这个应答报文转发到端口1。 h1收到应答报文，学习到h2的mac地址，发送\u003csrc = mac1，dst = mac2\u003e的ICMP报文。 此时s1中只有一条流表in_port=2,output:1，仍然发送PacketIn消息。 控制器查找到mac2的对应端口为2，下发一条流表in_port=1,output:2，发送PacketOut消息指示s1把这个报文转发到端口2。 之后略 所以，整个过程中一共上传了三次PacketIn消息，分别是ma1 ff:ff:ff:ff 1，mac2 mac1 2，mac1 mac2 1。 过程结束s1中有两条流表，分别是in_port=2,src=mac2,dst=mac1,action=output:1,in_port=1,src=mac1,dst=mac2,action=output:2。 有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:3","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"总结 要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:1","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"参考文献 Ping过程 详解 ryu源码解读——simple_switch.py ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:2","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"什么是集线器 集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。 ","date":"2022-01-09","objectID":"/simple_hub/:1:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"实现代码 # simple_hub.py from ryu.base import app_manager from ryu.controller import ofp_event from ryu.controller.handler import MAIN_DISPATCHER from ryu.controller.handler import set_ev_cls class L2Switch(app_manager.RyuApp): def __init__(self, *args, **kwargs): super(L2Switch, self).__init__(*args, **kwargs) @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def packet_in_handler(self, ev): msg = ev.msg datapath = msg.datapath ofp = datapath.ofproto ofp_parser = datapath.ofproto_parser actions = [ofp_parser.OFPActionOutput(ofp.OFPP_FLOOD)] out = ofp_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions) datapath.send_msg(out) ","date":"2022-01-09","objectID":"/simple_hub/:2:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"实现逻辑 当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。 ","date":"2022-01-09","objectID":"/simple_hub/:3:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-09","objectID":"/simple_hub/:4:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"参考文献 RYU入门教程 ","date":"2022-01-09","objectID":"/simple_hub/:4:1","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"总览 文件位置：ryu/ryu/app/simple_switch.py simple_switch.py共110行 1-18：注释 21-29：引库 32-110：继承类RyuApp ","date":"2022-01-08","objectID":"/simple_switch_note/:1:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"32-37 继承类RyuApp，并调用构造函数 class SimpleSwitch(app_manager.RyuApp): OFP_VERSIONS = [ofproto_v1_0.OFP_VERSION] # 声明支持的Open Flow版本 # 继承，调用构造函数并添加一个新属性 mac_to_port def __init__(self, *args, **kwargs): super(SimpleSwitch, self).__init__(*args, **kwargs) self.mac_to_port = {} 编写的程序实际上是Ryu控制器的APP，需要继承类RyuApp。 自学习交换机需要控制器来维护交换机的帧交换表，帧交换便就是mac地址与端口号的对应关系，所以添加一个新属性mac_to_port。 ","date":"2022-01-08","objectID":"/simple_switch_note/:2:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"39-51 实现一个添加流表的函数 # 函数：添加流表 def add_flow(self, datapath, in_port, dst, src, actions): ofproto = datapath.ofproto match = datapath.ofproto_parser.OFPMatch( in_port=in_port, dl_dst=haddr_to_bin(dst), dl_src=haddr_to_bin(src)# 源和目的mac地址 ) mod = datapath.ofproto_parser.OFPFlowMod( datapath=datapath, match=match, cookie=0, command=ofproto.OFPFC_ADD, # 命令：添加新流表 idle_timeout=0, hard_timeout=0, priority=ofproto.OFP_DEFAULT_PRIORITY, # 优先级：默认 flags=ofproto.OFPFF_SEND_FLOW_REM, actions=actions) datapath.send_msg(mod) #控制器下发消息 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"datapath 控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"协议细节 OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。 OFPMatch：流匹配规则。 flags：以下三个值之一 | OFPFF_SEND_FLOW_REM 当流过期或删除时，发送删除流消息。 | OFPFF_CHECK_OVERLAP 首先检查重叠的条目。 | OFPFF_EMERG 标记为紧急情况。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"53-94 PacketIn消息的处理逻辑： @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): # 解析数据包 msg = ev.msg datapath = msg.datapath ofproto = datapath.ofproto pkt = packet.Packet(msg.data) eth = pkt.get_protocol(ethernet.ethernet) if eth.ethertype == ether_types.ETH_TYPE_LLDP: # 忽略LLDP类型的包 return dst = eth.dst src = eth.src # 初始化mac_port对应规则 dpid = datapath.id self.mac_to_port.setdefault(dpid, {}) # 打印消息 self.logger.info(\"packet in %s%s%s%s\", dpid, src, dst, msg.in_port) # 记录此包对应的mac_port对应规则 self.mac_to_port[dpid][src] = msg.in_port # 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛 if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD # 封装一个OFPActionOutput类型动作：从out_port端口输出 actions = [datapath.ofproto_parser.OFPActionOutput(out_port)] # 如果已经明确了目的mac的输出端口，那么就下发一条流表 if out_port != ofproto.OFPP_FLOOD: self.add_flow(datapath, msg.in_port, dst, src, actions) # 如果交换机没有缓存该包，那么就把该包还回去 data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data # 发送PacketOut消息 out = datapath.ofproto_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions, data=data) datapath.send_msg(out) 细节分析： ","date":"2022-01-08","objectID":"/simple_switch_note/:4:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"LLDP ","date":"2022-01-08","objectID":"/simple_switch_note/:4:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"PacketIn与PacketOut 当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。 所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。 PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"处理逻辑 解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。 如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。 如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。 封装PacketOut消息，下发。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:3","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"buffer_id与data 交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。 如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。 如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:4","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"96-110 如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息。 这个部分不是自学习交换机必需的。 @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER) def _port_status_handler(self, ev): # 解析消息 msg = ev.msg reason = msg.reason port_no = msg.desc.port_no # 打印 ofproto = msg.datapath.ofproto if reason == ofproto.OFPPR_ADD: self.logger.info(\"port added %s\", port_no) elif reason == ofproto.OFPPR_DELETE: self.logger.info(\"port deleted %s\", port_no) elif reason == ofproto.OFPPR_MODIFY: self.logger.info(\"port modified %s\", port_no) else: self.logger.info(\"Illeagal port state %s%s\", port_no, reason) ","date":"2022-01-08","objectID":"/simple_switch_note/:5:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"参考文献 RYU入门教程 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"备注 ryu官方：https://github.com/faucetsdn/ryu 本人注释版：https://github.com/leeshy-tech/ryu ","date":"2022-01-08","objectID":"/simple_switch_note/:6:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN","Network"],"content":"导入 在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 OVS：OpenvSwitch的简称，它是一种支持OpenFlow协议的软交换机。 ryu：基于Python开发的SDN开源控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:1:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"准备工作 树莓派搭载linux操作系统，有无线网卡，利用ifconfig命令查得无线网卡名称。 树莓派之间先组成adhoc网络，参考文章：在树莓派上搭建ad-hoc网络教程 在两台树莓派上安装OVS，参考文章：Open vSwitch系列之二 安装指定版本ovs 在其中一台树莓派上安装ryu控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:2:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"组网步骤 假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"控制节点 IP = 10.0.0.1 开启控制器（进入ryu/ryu/app/文件夹执行）： ryu-manager simple_switch.py\rOVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.1\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"普通节点 IP = 10.0.0.2 OVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.2\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"关于网卡设置的解释 将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下： 无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。 对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。 创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令： 取消wlan0设置的IP地址：ifconfig wlan0 0 设置网卡s1的IP地址为原主机地址：ifconfig s1 10.0.0.1 开启网卡s1：ifconfig s1 up ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:3","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"测试 如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？ 注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。 查询两个交换机的流表信息： ovs-ofctl dump-flows s1 输出为空，此时交换机中没有流表。 在控制节点ping普通节点： ping 10.0.0.2 发现可以ping通，同时可以在控制器窗口看到PacketIn消息。 再次查询流表：ovs-ofctl dump-flows s1 发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:4:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"应用 模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序： 控制节点：python3 SDN_on_Raspberry_pi/client.py 普通节点：python3 SDN_on_Raspberry_pi/sever.py 从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:5:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"结束语 因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"参考文献 在树莓派上搭建ad-hoc网络教程 OVS初级教程：使用Open vSwitch构建虚拟网络 Open vSwitch系列之二 安装指定版本ovs ovs之组网实验 SDN系列学习课程-OpenFlow-Ryu-Mininet TCP/IP网络通信之Socket编程入门 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"备注 本文依赖代码文件：https://github.com/leeshy-tech/SDN_on_Raspberry_pi ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["Note"],"content":"查看信息 查看openvswitch的状态：ovs-vsctl show 查看openvswitch中的所有网桥：ovs-vsctl list-br 查看网桥的信息：ovs-ofctl show br0 查看网桥中的所有端口：ovs-vsctl list-ports br0 查看网桥各端口状态：ovs-ofctl dump-ports br0 查看网桥上的流表：ovs-ofctl dump-flows br0 查看网桥故障模式：ovs-vsctl get-fail-mode br0 查看网桥是否开启stp协议：ovs-vsctl get bridge br0 stp_enable 查看网桥所有配置信息：ovs-vsctl list bridge br0 查看端口所有特性信息：ovs-vsctl list port br0 port1 ","date":"2022-01-07","objectID":"/ovs_cli/:1:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"网桥操作 添加网桥：ovs-vsctl add-br br0 删除网桥：ovs-vsctl del-br br0 将网桥连接到控制器：ovs-vsctl set-controller br0 tcp:\u003ccontroller IP\u003e:\u003cport\u003e 设置网桥的故障模式：ovs-vsctl set-fail-mode br0 \u003csecure or standalone\u003e 给网桥开启stp协议：ovs-vsctl set bridge br0 stp_enable=true ","date":"2022-01-07","objectID":"/ovs_cli/:2:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"端口操作 增加端口：ovs-vsctl add-port br0 port1 删除端口：ovs-vsctl del-port br0 port1 设置端口号：ovs-vsctl set Interface port1 ofport_request=\u003cnumber\u003e 设置端口类型：ovs-vsctl set Interface p4 type=\u003ctype\u003e 端口类型 描述 Normal 普通端口 Internal 这个端口相当于一个虚拟网卡 Patch 用于连接两个网桥的端口 Tunne 隧道端口是一种虚拟端口，支持使用gre或vxlan等隧道技术与位于网络上其他位置的远程端口通讯。 ","date":"2022-01-07","objectID":"/ovs_cli/:3:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"网卡操作 将物理网卡挂接到网桥：ovs-vsctl add-port br0 eth0 列出所有挂接到网卡的网桥：ovs-vsctl port-to-br eth0 删除网桥上已经挂接的网卡：ovs-vsctl del-port br0 eth0 ","date":"2022-01-07","objectID":"/ovs_cli/:4:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"流表操作 添加流表：ovs-ofctl add-flow br0 \u003cmatch\u003e,\u003caction\u003e 删除流表：ovs-ofctl del-flows br0 \u003cmatch\u003e ","date":"2022-01-07","objectID":"/ovs_cli/:5:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"流表动作 action 从端口转发：actions=output:\u003cnumber\u003e 丢弃数据包：actions=drop 广播：actions=NORMAL ","date":"2022-01-07","objectID":"/ovs_cli/:5:1","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"匹配项 match 如有多个匹配项，之间用逗号隔开。 匹配项 描述 in_port=port 网桥端口号 dl_vlan=vlan 数据包的 VLAN Tag 值 dl_vlan_pcp=priority VLAN 优先级，改值取值区间为[0-7]。数字越大，优先级越高。 dl_src=,dl_dst= 匹配源或者目标的 MAC 地址 dl_type=ethertype 匹配以太网协议类型 ,IPv4:0x0800,IPv6:0x086dd,ARP:0x0806 nw_src=,nw_dst= 匹配源或目的IP，前提要设定dl_type table=number 指定流表编号 reg=value[/mask] 网桥中寄存器的值 tp_src=number,tp_dst=number TCP协议源或目的端口 ","date":"2022-01-07","objectID":"/ovs_cli/:5:2","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"参考文献 OpenvSwitch系列 ","date":"2022-01-07","objectID":"/ovs_cli/:6:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Electronic Design","Course"],"content":" 注：本项目来自BUPT课程《电子工艺实习》 ","date":"2022-01-04","objectID":"/electronic_dog/:0:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"导入 电子狗是声控、光控、磁控机电一体化电动玩具。主要工作原理：利用555构成的单稳态触发器，在三种不同的控制方法下，均给以低电平触发，促使电机转动，从而达到了机器狗停走的目的。即：拍手即走、光照即走、磁铁靠近即走，但都只是持续一段时间后就停会下，再满足其中一条件时将继续行走。 原理图如下： 整个系统可分为信号转化、单稳态触发器以及电机驱动三个部分。 ","date":"2022-01-04","objectID":"/electronic_dog/:1:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"单稳态触发器 这部分的功能是：将持续时间很短的低电平信号转换为固定时间间隔（1.1RC）的高电平信号以控制电子狗走路持续时间（控制R和C的数值）。 关于单稳态触发器的原理分析可参考以下文章： 555定时器 ","date":"2022-01-04","objectID":"/electronic_dog/:2:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"信号转换 这部分的功能是将磁、光、声信号转换为低电平电信号。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"磁信号 磁信号向电信号的转换通过干簧管传感器实现，干簧管的电路模型类似于一个磁控开关，外加磁场时开关闭合，常态开关断开（也有常态是闭合的干簧管），详细原理如下： 干簧片相当于一个磁通导体，在尚未操作时，两片簧片并未接触；在通过永久磁铁或电磁线圈产生的磁场时，外加的磁场使两片簧片端点位置附近产生不同的极性, 当磁力超过簧片本身的弹力时，这两片簧片会吸合导通电路；当磁场减弱或消失后,干簧片由于本身的弹性而释放，触面就会分开从而打开电路。 接上拉电阻即可实现常驻高电平，外加磁场时开关闭合输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"光信号 光信号向电信号的转变通过光敏三极管实现，电路模型相当于光控开关，光照相当于开关闭合，详细原理如下： 光敏三极管的发射极具有光敏特性。它的集电极则与普通晶体管一样，可以获得电流增益，基极一般没有引线。当受到光照时CE两极导通，相当于开关闭合。 同样使用上拉电阻，不再赘述。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"声信号 声信号向电信号的转变通过麦克风实现，目前常用的麦克风有驻极体电容麦克风（ECM）和微机电麦克风（MEMS Micphone）。在电子狗实验中使用的是ECM，声波压力推动极板后退使得电容两极电压升高，从而将声信号转换为了电压信号。 因需要对电压放大，驻极体麦克风内部有一个场效应管，正常工作需要加一个直流偏置，其驱动电路之一为： 电容的作用是隔直流。 应用于电子狗的电路设计如下： 左侧为驱动电路，中间加一级共射放大器，右侧是二极管反相器，当麦克风接收到声音信号时，产生交流电压，放大到二级管基极，二极管截止，输出接地，即输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"仿真 干簧管和光敏二极管的电路模型都很简单，没有仿真的必要，以电阻分压的瞬间变化模拟麦克风输出的交流电压，仿真电路如下： 仿真结果显示，开关闭合产生的电压波动输出了约50ms左右的低电平，这是非常不合适的，因为实际的麦克风产生的电压波动情况远远复杂于我们的模拟，会产生持续时间更长的低电平信号，而后级的单稳态触发器，当输入低电平信号持续时间大于1.1RC时，输出高电平的时间会相应的延长，我们想要的应当是一个持续时间很短的电平信号。 解决方法是加入负反馈： 图中绿色部分为增加的负反馈电路，当555定时器输出高电平时，C5充电将Q2 B极电位拉高，使其截止，相当于开关闭合，从而将Q3的B极电位拉低，使得Q3的C极低电位只持续很短的时间。 重新仿真结果如下： 低电平的持续时间变为500us左右。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:4","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"电机驱动 此部分的功能是利用555定时器输出的高电平信号驱动电机转动 电动机是怎么驱动的？非常简单，电池分别接正负极即可。 但是，在已有的场景下，不能使用这种方式，即把555定时器的输出端3号管脚接到电动机正极，地接电动机负极。 原因是：555定时器的驱动能力不足。 查询555定时器（NE555P）的数据手册可知，输出电流最大只有225mA左右，常见的电动玩具马达空载驱动电流在600mA左右，555定时器是远不足以驱动马达的。 最简单的放大电流的方法就是晶体管反相器，所以电机驱动的电路原理图如下： 并联两个三极管增大放大倍数，二极管是防止电机反转，注意这是一个反相器，所以要接到电动机的负极。 用灯泡代替电动机，简单仿真如下： 注意此处输入端用单刀双掷开关，单开关断开是悬空状态，不是输入低电平。 电源两端并联电容是为了稳压和滤波。 ","date":"2022-01-04","objectID":"/electronic_dog/:4:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"总体仿真 将以上模块合并，仿真图如下（光敏二极管用光耦合器代替）： 仿真结果： 电路启动时触发一次电子狗，三种信号各触发一次，注意这里光信号和磁信号使用的是回弹式开关，为下文埋下了伏笔。 ","date":"2022-01-04","objectID":"/electronic_dog/:5:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改进 学校提供的原理图的分析就到这里了，但实际做实验的时候有一些不方便的地方，比如实验室是常亮状态，光照就会一直触发电子狗，必须遮住光，暴露一下就要马上再遮住，在仿真中使用回弹式开关也是这个原因，还是在于单稳态触发器的输入信号不能持续太长时间，我提出的改进方法如下： ","date":"2022-01-04","objectID":"/electronic_dog/:6:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为黑暗触发 这种改进方案很简单，在光信号转化模块后面加一个二极管反相器就可以。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为边沿触发 改进方案与仿真结果如图所示： 开关关闭和开启会被转化为一个短暂的低电平信号，这个信号的持续时间可以通过调整R和C的值来改变。 原理：利用一阶RC电路将原输入信号做一个短暂延时，再与原信号做同或运算，延时的部分就被计算为了0，其他时刻为1。 当初写实验报告的时候只简单写了一个“用边沿触发器实现即可”，现在想想还真不是这么回事。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"结束语 ","date":"2022-01-04","objectID":"/electronic_dog/:7:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"体会 这门课我还是学到了很多东西的。但是我看了看实验报告的标题“电子狗组装”，实在是很让人难蚌。 ","date":"2022-01-04","objectID":"/electronic_dog/:7:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"参考文献 555定时器_Leeshy’s Blog 小马达电机_淘宝网 干簧管_华壬电子 光电三极管_百度百科 一文看懂咪头的工作原理及结构（驻极体话筒） ","date":"2022-01-04","objectID":"/electronic_dog/:7:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"备注 本文仿真使用的是Multisim，原理图绘制使用的是立创EDA。 本文依赖文件：https://github.com/leeshy-tech/Electronic-Design/tree/main/e-dog NE555P数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-04","objectID":"/electronic_dog/:7:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design"],"content":"什么是555定时器 555定时器是一种集成电路芯片，常被用于定时器、脉冲产生器和振荡电路。555可被作为电路中的延时器件、触发器或起振元件。 内部组成如下：由比较器C1C2、RS触发器、缓冲非门G、放电二极管T组成 ","date":"2022-01-02","objectID":"/555timer/:1:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"芯片分析 电压比较器：一种模拟输入、数字输出的接口电路，输出特性如下： in out Vp \u003e Vn 1 Vp \u003c Vn 0 在555定时器内部，左侧是纯电阻分压电路，将比较器阈值设置为 $$ V_{P1}=\\frac{2}{3} V_{cc}, V_{N2}=\\frac{1}{3} V_{cc} $$ C1C2的输出特性如下： C1 C2 in out in out Vp \u003e 2/3Vcc 0 Vn \u003e 1/3Vcc 1 Vp \u003e 2/3Vcc 1 Vn \u003c 1/3Vcc 0 结合RS触发器的真值表可得555定时器的真值表如下： Ui1 Ui2 复位Rd Uo 放电管T x x 0 0 导通 \u003c2/3Vcc \u003c1/3Vcc 1 1 截止 \u003e2/3Vcc \u003e1/3Vcc 1 0 导通 \u003c2/3Vcc \u003e1/3Vcc 1 不变 不变 ","date":"2022-01-02","objectID":"/555timer/:2:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"典型应用 单稳态电路 多谐振荡器 施密特触发器 ","date":"2022-01-02","objectID":"/555timer/:3:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"555定时器为核心的单稳态电路 ","date":"2022-01-02","objectID":"/555timer/:4:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"理论分析 应用电路如下： 稳定状态时，管脚2输入信号为高电平，管脚6跨电容与地相连，相当于输入低电平，复位引脚4接高电平，故输出保持低电平不变，放电二极管保持导通不变。 当输入信号的下降沿到来，输出变为高电平，放电二极管截止，管脚7向外放电，电容C开始充电，直到$ u_C=\\frac{2}{3} V_{cc}$ 若忽略晶体管的饱和压降，则充电时间为 $t_w=RCln \\frac{\\mathrm{Vcc}}{Vcc-\\frac{2}{3} Vcc} =RCln 3 \\approx 1.1 RC$ 当输入信号回到高电平且电容充电完毕后，输出回到低电平，放电二极管截止。 ","date":"2022-01-02","objectID":"/555timer/:4:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"仿真验证 使用Multisim仿真，电路如下： 选用回弹式开关使输入信号在电容充电完毕之前回到高电平，以便于从示波器图形上测得充电时间。 仿真结果： 电路行为与理论分析一致，根据理论分析公式 $\\mathrm{t}_{\\mathrm{w}}=1.1 \\times 10 \\mathrm{k} \\times 4.7 \\mathrm{u}=51.7 \\mathrm{~ms} $,仿真测得充电时间为50.94ms，且充满后电压为2.985V，与理论分析相符的很好。 ","date":"2022-01-02","objectID":"/555timer/:4:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"总结 该单稳态触发器的功能总结为：将低电平脉冲信号（持续时间小于1.1RC）转化为持续时间为1.1RC的高电平信号，持续时间大于1.1RC的话，就只是由低电平转化为高电平。 ","date":"2022-01-02","objectID":"/555timer/:4:3","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"结束语 ","date":"2022-01-02","objectID":"/555timer/:5:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"参考文献 555定时器及应用 电压比较器_百度百科 555定时器_百度百科 NE555P_立创商城 ","date":"2022-01-02","objectID":"/555timer/:5:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"备注 仿真文件及数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-02","objectID":"/555timer/:5:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":null,"content":"关于我是谁 20岁 北京邮电大学19级信息工程专业本科生 技能点主要是软件定义网络（SDN，software defined network）、电子设计以及Python ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"多说几句 博客内容呢，能否转载和是否署名都不是我能控制的事情，毕竟现在的网络时代就是这样。 你们这些学法的到底保护了些什么啊ちくしょう 但是我会永远遵守开源精神，附上我的博客参考的一切。 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"友链 lgt：https://ayamir.github.io/ 黄鸡：https://hyiker.com/ ClSlaid：https://clslaid.icu/ liCheng前辈：http://www.muzixing.com/ Fine：https://ffa2000.github.io/ 广告位招租 ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"听首歌 ","date":"0001-01-01","objectID":"/about/:4:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"引个流 \r","date":"0001-01-01","objectID":"/about/:5:0","tags":null,"title":"","uri":"/about/"}]