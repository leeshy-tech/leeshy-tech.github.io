[{"categories":["Note","SDN"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/6739370 IEEE Communications Surveys \u0026 Tutorials Volume 16 Issue 3 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:1:0","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Note","SDN"],"content":"摘要 本文综述了可编程网络的最新进展，重点介绍了SDN。我们提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:2:0","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Note","SDN"],"content":"1 引言 传统网络出现的问题：网络管理和性能调优困难，网络僵化。 可编程网络具有革命性，比如软件定义网络，网络设备成为简单的包转发设备，可以通过开放的接口进行编程。 第二节：早期可编程网络 第三节：SDN及其体系结构，以及OpenFlow协议。 第四节：开发和测试SDN的平台和工具。 第五节：在数据中心和无线网络的应用。 第六节：面临的挑战和未来发展的方向。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:3:0","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Note","SDN"],"content":"2 早期可编程网络 描述了一些SDN和OpenFlow概念的前身，在早期的一些项目中已经有了关于可编程网络和数控平面分离的思想。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:4:0","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Note","SDN"],"content":"3 SDN体系结构 路由器和交换机通常是封闭的系统，只有很少的提供给供应商的接口。适配新版本的协议（比如Ipv6）非常困难，更不用说部署全新的协议和服务。网络僵化效应主要是由于设备的数据和控制平面紧密耦合，新的app或功能的部署需要直接实现在物理设施中。解决网络僵化的一个手段是使用中间设备，比如CDN（内容交付网络）。 软件定义网络将转发硬件和控制逻辑分离，可以更容易地部署新协议和应用程序。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:0","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Note","SDN"],"content":"A 当前SDN架构 目前有两种SDN架构：ForCES和OpenFlow ForCES将单个设备中的控制元素与转发元素分开，意图实现在单一网络设备中将转发硬件与第三方控制相结合。它定义了两个逻辑实体，转发元素FE和控制元素CE，它们通过ForCES协议通信，FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能。 OpenFlow完全将控制平面从网络设备上剥离，转发设备基于流表进行转发，流表控制着转发规则。没有匹配流表时按照“table-miss”流表项执行相应的动作，比如丢弃、转发给控制器。控制平面与转发平面通过OpenFlow协议进行通信，远程控制器可以添加、删除或更新交换机的流表项。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:1","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Note","SDN"],"content":"语句摘录 As a result, network management and performance tuning is quite challenging and thus error-prone. 因此，网络管理和性能调优非常具有挑战性，所以很容易出错。 Because of its huge deployment base and the fact it is considered part of our society’s critical infrastructure (just like transportation and power grids), the Internet has become extremely difficult to evolve both in terms of its physical infrastructure as well as its protocols and performance. 由于其庞大的部署基础，且被视为我们社会关键基础设施(就像交通和电网)的一部分，所以互联网在其物理基础设施、协议和性能方面的发展已经变得极其困难。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:0","tags":["SDN"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["SDN"],"content":"自学习交换机 交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。 SDN的自学习交换机跟传统交换机不一样的点有： 帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。 自学习的过程中可能会有流表的变化。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:1:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"ping命令过程 ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。 局域网ping命令的执行过程： 网络模型为：h1 —- s1 —- h2，两台主机连接到同一个交换机。 假设h1 ping h2 首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。 交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。 h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。 h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。 h2收到报文后应答，ping完成。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:2:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验分析 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验内容 通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：ryu源码解读——simple_switch.py。 使用OVS搭建网络模型：h1 —- s1 —- h2，将s1连接到控制器。 h1 ping h2，观察PacketIn消息。 查看s1的流表变化。 这里不用mininet平台搭建网络的原因是：mininet主机会定时检查与交换机的连接，导致出现很多的冗余PacketIn消息，不利于观察。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:1","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验结果 当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。 使用ovs-ofctl dump-flows s1命令观察流表，结果如下： 执行完ping命令后多了两条流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:2","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"流程分析 日志的输出格式是：packet in \u003c交换机标号\u003e \u003c源mac\u003e \u003c目的mac\u003e \u003c输入端口\u003e h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。 h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。 控制器学习到mac1--端口1，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。 s1广播，h2收到并学习到h1的mac地址，发送\u003csrc = mac2，dst = mac1\u003e的ARP应答报文，s1流表为空，发送PacketIn消息。 控制器学习到mac2--端口2，查找到mac1的对应端口为1，此时下发一条流表in_port=2,output:1，发送PacketOut消息指示s1把这个应答报文转发到端口1。 h1收到应答报文，学习到h2的mac地址，发送\u003csrc = mac1，dst = mac2\u003e的ICMP报文。 此时s1中只有一条流表in_port=2,output:1，仍然发送PacketIn消息。 控制器查找到mac2的对应端口为2，下发一条流表in_port=1,output:2，发送PacketOut消息指示s1把这个报文转发到端口2。 之后略 所以，整个过程中一共上传了三次PacketIn消息，分别是ma1 ff:ff:ff:ff 1，mac2 mac1 2，mac1 mac2 1。 过程结束s1中有两条流表，分别是in_port=2,src=mac2,dst=mac1,action=output:1,in_port=1,src=mac1,dst=mac2,action=output:2。 有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:3","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"总结 要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:1","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"参考文献 Ping过程 详解 ryu源码解读——simple_switch.py ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:2","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["Ryu"],"content":"什么是集线器 集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。 ","date":"2022-01-09","objectID":"/simple_hub/:1:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"实现代码 # simple_hub.py from ryu.base import app_manager from ryu.controller import ofp_event from ryu.controller.handler import MAIN_DISPATCHER from ryu.controller.handler import set_ev_cls class L2Switch(app_manager.RyuApp): def __init__(self, *args, **kwargs): super(L2Switch, self).__init__(*args, **kwargs) @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def packet_in_handler(self, ev): msg = ev.msg datapath = msg.datapath ofp = datapath.ofproto ofp_parser = datapath.ofproto_parser actions = [ofp_parser.OFPActionOutput(ofp.OFPP_FLOOD)] out = ofp_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions) datapath.send_msg(out) ","date":"2022-01-09","objectID":"/simple_hub/:2:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"实现逻辑 当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。 ","date":"2022-01-09","objectID":"/simple_hub/:3:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"结束语 ","date":"2022-01-09","objectID":"/simple_hub/:4:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu"],"content":"参考文献 RYU入门教程 ","date":"2022-01-09","objectID":"/simple_hub/:4:1","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["Ryu","Source Code Read"],"content":"总览 文件位置：ryu/ryu/app/simple_switch.py simple_switch.py共110行 1-18：注释 21-29：引库 32-110：继承类RyuApp ","date":"2022-01-08","objectID":"/simple_switch_note/:1:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"32-37 继承类RyuApp，并调用构造函数 class SimpleSwitch(app_manager.RyuApp): OFP_VERSIONS = [ofproto_v1_0.OFP_VERSION] # 声明支持的Open Flow版本 # 继承，调用构造函数并添加一个新属性 mac_to_port def __init__(self, *args, **kwargs): super(SimpleSwitch, self).__init__(*args, **kwargs) self.mac_to_port = {} 编写的程序实际上是Ryu控制器的APP，需要继承类RyuApp。 自学习交换机需要控制器来维护交换机的帧交换表，帧交换便就是mac地址与端口号的对应关系，所以添加一个新属性mac_to_port。 ","date":"2022-01-08","objectID":"/simple_switch_note/:2:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"39-51 实现一个添加流表的函数 # 函数：添加流表 def add_flow(self, datapath, in_port, dst, src, actions): ofproto = datapath.ofproto match = datapath.ofproto_parser.OFPMatch( in_port=in_port, dl_dst=haddr_to_bin(dst), dl_src=haddr_to_bin(src)# 源和目的mac地址 ) mod = datapath.ofproto_parser.OFPFlowMod( datapath=datapath, match=match, cookie=0, command=ofproto.OFPFC_ADD, # 命令：添加新流表 idle_timeout=0, hard_timeout=0, priority=ofproto.OFP_DEFAULT_PRIORITY, # 优先级：默认 flags=ofproto.OFPFF_SEND_FLOW_REM, actions=actions) datapath.send_msg(mod) #控制器下发消息 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"datapath 控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"协议细节 OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。 OFPMatch：流匹配规则。 flags：以下三个值之一 | OFPFF_SEND_FLOW_REM 当流过期或删除时，发送删除流消息。 | OFPFF_CHECK_OVERLAP 首先检查重叠的条目。 | OFPFF_EMERG 标记为紧急情况。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"53-94 PacketIn消息的处理逻辑： @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): # 解析数据包 msg = ev.msg datapath = msg.datapath ofproto = datapath.ofproto pkt = packet.Packet(msg.data) eth = pkt.get_protocol(ethernet.ethernet) if eth.ethertype == ether_types.ETH_TYPE_LLDP: # 忽略LLDP类型的包 return dst = eth.dst src = eth.src # 初始化mac_port对应规则 dpid = datapath.id self.mac_to_port.setdefault(dpid, {}) # 打印消息 self.logger.info(\"packet in %s%s%s%s\", dpid, src, dst, msg.in_port) # 记录此包对应的mac_port对应规则 self.mac_to_port[dpid][src] = msg.in_port # 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛 if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD # 封装一个OFPActionOutput类型动作：从out_port端口输出 actions = [datapath.ofproto_parser.OFPActionOutput(out_port)] # 如果已经明确了目的mac的输出端口，那么就下发一条流表 if out_port != ofproto.OFPP_FLOOD: self.add_flow(datapath, msg.in_port, dst, src, actions) # 如果交换机没有缓存该包，那么就把该包还回去 data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data # 发送PacketOut消息 out = datapath.ofproto_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions, data=data) datapath.send_msg(out) 细节分析： ","date":"2022-01-08","objectID":"/simple_switch_note/:4:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"LLDP ","date":"2022-01-08","objectID":"/simple_switch_note/:4:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"PacketIn与PacketOut 当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。 所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。 PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"处理逻辑 解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。 如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。 如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。 封装PacketOut消息，下发。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:3","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"buffer_id与data 交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。 如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。 如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:4","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"96-110 如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息。 这个部分不是自学习交换机必需的。 @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER) def _port_status_handler(self, ev): # 解析消息 msg = ev.msg reason = msg.reason port_no = msg.desc.port_no # 打印 ofproto = msg.datapath.ofproto if reason == ofproto.OFPPR_ADD: self.logger.info(\"port added %s\", port_no) elif reason == ofproto.OFPPR_DELETE: self.logger.info(\"port deleted %s\", port_no) elif reason == ofproto.OFPPR_MODIFY: self.logger.info(\"port modified %s\", port_no) else: self.logger.info(\"Illeagal port state %s%s\", port_no, reason) ","date":"2022-01-08","objectID":"/simple_switch_note/:5:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"结束语 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"参考文献 RYU入门教程 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["Ryu","Source Code Read"],"content":"备注 ryu官方：https://github.com/faucetsdn/ryu 本人注释版：https://github.com/leeshy-tech/ryu ","date":"2022-01-08","objectID":"/simple_switch_note/:6:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN","OVS"],"content":"导入 在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 OVS：OpenvSwitch的简称，他是一种支持OpenFlow协议的软交换机。 ryu：基于Python开发的SDN开源控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:1:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"准备工作 树莓派搭载linux操作系统，有无线网卡，利用ifconfig命令查得无线网卡名称。 树莓派之间先组成adhoc网络，参考文章：在树莓派上搭建ad-hoc网络教程 在两台树莓派上安装OVS，参考文章：Open vSwitch系列之二 安装指定版本ovs 在其中一台树莓派上安装ryu控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:2:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"组网步骤 假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"控制节点 IP = 10.0.0.1 开启控制器（进入ryu/ryu/app/文件夹执行）： ryu-manager simple_switch.py\rOVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.1\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"普通节点 IP = 10.0.0.2 OVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.2\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"关于网卡设置的解释 将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下： 无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。 对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。 创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令： 取消wlan0设置的IP地址：ifconfig wlan0 0 设置网卡s1的IP地址为原主机地址：ifconfig s1 10.0.0.1 开启网卡s1：ifconfig s1 up ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:3","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"测试 如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？ 注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。 查询两个交换机的流表信息： ovs-ofctl dump-flows s1 输出为空，此时交换机中没有流表。 在控制节点ping普通节点： ping 10.0.0.2 发现可以ping通，同时可以在控制器窗口看到PacketIn消息。 再次查询流表：ovs-ofctl dump-flows s1 发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:4:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"应用 模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序： 控制节点：python3 SDN_on_Raspberry_pi/client.py 普通节点：python3 SDN_on_Raspberry_pi/sever.py 从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:5:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"结束语 因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"参考文献 在树莓派上搭建ad-hoc网络教程 OVS初级教程：使用Open vSwitch构建虚拟网络 Open vSwitch系列之二 安装指定版本ovs ovs之组网实验 SDN系列学习课程-OpenFlow-Ryu-Mininet TCP/IP网络通信之Socket编程入门 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","OVS"],"content":"备注 本文依赖代码文件：https://github.com/leeshy-tech/SDN_on_Raspberry_pi ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["Note","OVS"],"content":"查看信息 查看openvswitch的状态：ovs-vsctl show 查看openvswitch中的所有网桥：ovs-vsctl list-br 查看网桥的信息：ovs-ofctl show br0 查看网桥中的所有端口：ovs-vsctl list-ports br0 查看网桥各端口状态：ovs-ofctl dump-ports br0 查看网桥上的流表：ovs-ofctl dump-flows br0 查看网桥故障模式：ovs-vsctl get-fail-mode br0 查看网桥是否开启stp协议：ovs-vsctl get bridge br0 stp_enable 查看网桥所有配置信息：ovs-vsctl list bridge br0 查看端口所有特性信息：ovs-vsctl list port br0 port1 ","date":"2022-01-07","objectID":"/ovs_cli/:1:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"网桥操作 添加网桥：ovs-vsctl add-br br0 删除网桥：ovs-vsctl del-br br0 将网桥连接到控制器：ovs-vsctl set-controller br0 tcp:\u003ccontroller IP\u003e:\u003cport\u003e 设置网桥的故障模式：ovs-vsctl set-fail-mode br0 \u003csecure or standalone\u003e 给网桥开启stp协议：ovs-vsctl set bridge br0 stp_enable=true ","date":"2022-01-07","objectID":"/ovs_cli/:2:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"端口操作 增加端口：ovs-vsctl add-port br0 port1 删除端口：ovs-vsctl del-port br0 port1 设置端口号：ovs-vsctl set Interface port1 ofport_request=\u003cnumber\u003e 设置端口类型：ovs-vsctl set Interface p4 type=\u003ctype\u003e 端口类型 描述 Normal 普通端口 Internal 这个端口相当于一个虚拟网卡 Patch 用于连接两个网桥的端口 Tunne 隧道端口是一种虚拟端口，支持使用gre或vxlan等隧道技术与位于网络上其他位置的远程端口通讯。 ","date":"2022-01-07","objectID":"/ovs_cli/:3:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"网卡操作 将物理网卡挂接到网桥：ovs-vsctl add-port br0 eth0 列出所有挂接到网卡的网桥：ovs-vsctl port-to-br eth0 删除网桥上已经挂接的网卡：ovs-vsctl del-port br0 eth0 ","date":"2022-01-07","objectID":"/ovs_cli/:4:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"流表操作 添加流表：ovs-ofctl add-flow br0 \u003cmatch\u003e,\u003caction\u003e 删除流表：ovs-ofctl add-flow br0 \u003cmatch\u003e ","date":"2022-01-07","objectID":"/ovs_cli/:5:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"流表动作 action 从端口转发：actions=output:\u003cnumber\u003e 丢弃数据包：actions=drop 广播：actions=NORMAL ","date":"2022-01-07","objectID":"/ovs_cli/:5:1","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"匹配项 match 如有多个匹配项，之间用逗号隔开。 匹配项 描述 in_port=port 网桥端口号 dl_vlan=vlan 数据包的 VLAN Tag 值 dl_vlan_pcp=priority VLAN 优先级，改值取值区间为[0-7]。数字越大，优先级越高。 dl_src=,dl_dst= 匹配源或者目标的 MAC 地址 dl_type=ethertype 匹配以太网协议类型 ,IPv4:0x0800,IPv6:0x086dd,ARP:0x0806 nw_src=,nw_dst= 匹配源或目的IP，前提要设定dl_type table=number 指定流表编号 reg=value[/mask] 网桥中寄存器的值 tp_src=number,tp_dst=number TCP协议源或目的端口 ","date":"2022-01-07","objectID":"/ovs_cli/:5:2","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note","OVS"],"content":"参考文献 OpenvSwitch系列 ","date":"2022-01-07","objectID":"/ovs_cli/:6:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Electronic Design","Course"],"content":" 注：本项目来自BUPT课程《电子工艺实习》 ","date":"2022-01-04","objectID":"/electronic_dog/:0:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"导入 电子狗是声控、光控、磁控机电一体化电动玩具。主要工作原理：利用555构成的单稳态触发器，在三种不同的控制方法下，均给以低电平触发，促使电机转动，从而达到了机器狗停走的目的。即：拍手即走、光照即走、磁铁靠近即走，但都只是持续一段时间后就停会下，再满足其中一条件时将继续行走。 原理图如下： 整个系统可分为信号转化、单稳态触发器以及电机驱动三个部分。 ","date":"2022-01-04","objectID":"/electronic_dog/:1:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"单稳态触发器 这部分的功能是：将持续时间很短的低电平信号转换为固定时间间隔（1.1RC）的高电平信号以控制电子狗走路持续时间（控制R和C的数值）。 关于单稳态触发器的原理分析可参考以下文章： 555定时器 ","date":"2022-01-04","objectID":"/electronic_dog/:2:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"信号转换 这部分的功能是将磁、光、声信号转换为低电平电信号。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"磁信号 磁信号向电信号的转换通过干簧管传感器实现，干簧管的电路模型类似于一个磁控开关，外加磁场时开关闭合，常态开关断开（也有常态是闭合的干簧管），详细原理如下： 干簧片相当于一个磁通导体，在尚未操作时，两片簧片并未接触；在通过永久磁铁或电磁线圈产生的磁场时，外加的磁场使两片簧片端点位置附近产生不同的极性, 当磁力超过簧片本身的弹力时，这两片簧片会吸合导通电路；当磁场减弱或消失后,干簧片由于本身的弹性而释放，触面就会分开从而打开电路。 接上拉电阻即可实现常驻高电平，外加磁场时开关闭合输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"光信号 光信号向电信号的转变通过光敏三极管实现，电路模型相当于光控开关，光照相当于开关闭合，详细原理如下： 光敏三极管的发射极具有光敏特性。它的集电极则与普通晶体管一样，可以获得电流增益，基极一般没有引线。当受到光照时CE两极导通，相当于开关闭合。 同样使用上拉电阻，不再赘述。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"声信号 声信号向电信号的转变通过麦克风实现，目前常用的麦克风有驻极体电容麦克风（ECM）和微机电麦克风（MEMS Micphone）。在电子狗实验中使用的是ECM，声波压力推动极板后退使得电容两极电压升高，从而将声信号转换为了电压信号。 因需要对电压放大，驻极体麦克风内部有一个场效应管，正常工作需要加一个直流偏置，其驱动电路之一为： 电容的作用是隔直流。 应用于电子狗的电路设计如下： 左侧为驱动电路，中间加一级共射放大器，右侧是二极管反相器，当麦克风接收到声音信号时，产生交流电压，放大到二级管基极，二极管截止，输出接地，即输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"仿真 干簧管和光敏二极管的电路模型都很简单，没有仿真的必要，以电阻分压的瞬间变化模拟麦克风输出的交流电压，仿真电路如下： 仿真结果显示，开关闭合产生的电压波动输出了约50ms左右的低电平，这是非常不合适的，因为实际的麦克风产生的电压波动情况远远复杂于我们的模拟，会产生持续时间更长的低电平信号，而后级的单稳态触发器，当输入低电平信号持续时间大于1.1RC时，输出高电平的时间会相应的延长，我们想要的应当是一个持续时间很短的电平信号。 解决方法是加入负反馈： 图中绿色部分为增加的负反馈电路，当555定时器输出高电平时，C5充电将Q2 B极电位拉高，使其截止，相当于开关闭合，从而将Q3的B极电位拉低，使得Q3的C极低电位只持续很短的时间。 重新仿真结果如下： 低电平的持续时间变为500us左右。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:4","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"电机驱动 此部分的功能是利用555定时器输出的高电平信号驱动电机转动 电动机是怎么驱动的？非常简单，电池分别接正负极即可。 但是，在已有的场景下，不能使用这种方式，即把555定时器的输出端3号管脚接到电动机正极，地接电动机负极。 原因是：555定时器的驱动能力不足。 查询555定时器（NE555P）的数据手册可知，输出电流最大只有225mA左右，常见的电动玩具马达空载驱动电流在600mA左右，555定时器是远不足以驱动马达的。 最简单的放大电流的方法就是晶体管反相器，所以电机驱动的电路原理图如下： 并联两个三极管增大放大倍数，二极管是防止电机反转，注意这是一个反相器，所以要接到电动机的负极。 用灯泡代替电动机，简单仿真如下： 注意此处输入端用单刀双掷开关，单开关断开是悬空状态，不是输入低电平。 电源两端并联电容是为了稳压和滤波。 ","date":"2022-01-04","objectID":"/electronic_dog/:4:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"总体仿真 将以上模块合并，仿真图如下（光敏二极管用光耦合器代替）： 仿真结果： 电路启动时触发一次电子狗，三种信号各触发一次，注意这里光信号和磁信号使用的是回弹式开关，为下文埋下了伏笔。 ","date":"2022-01-04","objectID":"/electronic_dog/:5:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改进 学校提供的原理图的分析就到这里了，但实际做实验的时候有一些不方便的地方，比如实验室是常亮状态，光照就会一直触发电子狗，必须遮住光，暴露一下就要马上再遮住，在仿真中使用回弹式开关也是这个原因，还是在于单稳态触发器的输入信号不能持续太长时间，我提出的改进方法如下： ","date":"2022-01-04","objectID":"/electronic_dog/:6:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为黑暗触发 这种改进方案很简单，在光信号转化模块后面加一个二极管反相器就可以。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为边沿触发 改进方案与仿真结果如图所示： 开关关闭和开启会被转化为一个短暂的低电平信号，这个信号的持续时间可以通过调整R和C的值来改变。 原理：利用一阶RC电路将原输入信号做一个短暂延时，再与原信号做同或运算，延时的部分就被计算为了0，其他时刻为1。 当初写实验报告的时候只简单写了一个“用边沿触发器实现即可”，现在想想还真不是这么回事。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"结束语 ","date":"2022-01-04","objectID":"/electronic_dog/:7:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"体会 这门课我还是学到了很多东西的。但是我看了看实验报告的标题“电子狗组装”，实在是很让人难蚌。 ","date":"2022-01-04","objectID":"/electronic_dog/:7:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"参考文献 555定时器_Leeshy’s Blog 小马达电机_淘宝网 干簧管_华壬电子 光电三极管_百度百科 一文看懂咪头的工作原理及结构（驻极体话筒） ","date":"2022-01-04","objectID":"/electronic_dog/:7:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"备注 本文仿真使用的是Multisim，原理图绘制使用的是立创EDA。 本文依赖文件：https://github.com/leeshy-tech/Electronic-Design/tree/main/e-dog NE555P数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-04","objectID":"/electronic_dog/:7:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design"],"content":"什么是555定时器 555定时器是一种集成电路芯片，常被用于定时器、脉冲产生器和振荡电路。555可被作为电路中的延时器件、触发器或起振元件。 内部组成如下：由比较器C1C2、RS触发器、缓冲非门G、放电二极管T组成 ","date":"2022-01-02","objectID":"/555timer/:1:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"芯片分析 电压比较器：一种模拟输入、数字输出的接口电路，输出特性如下： in out Vp \u003e Vn 1 Vp \u003c Vn 0 在555定时器内部，左侧是纯电阻分压电路，将比较器阈值设置为 $$ V_{P1}=\\frac{2}{3} V_{cc}, V_{N2}=\\frac{1}{3} V_{cc} $$ C1C2的输出特性如下： C1 C2 in out in out Vp \u003e 2/3Vcc 0 Vn \u003e 1/3Vcc 1 Vp \u003e 2/3Vcc 1 Vn \u003c 1/3Vcc 0 结合RS触发器的真值表可得555定时器的真值表如下： Ui1 Ui2 复位Rd Uo 放电管T x x 0 0 导通 \u003c2/3Vcc \u003c1/3Vcc 1 1 截止 \u003e2/3Vcc \u003e1/3Vcc 1 0 导通 \u003c2/3Vcc \u003e1/3Vcc 1 不变 不变 ","date":"2022-01-02","objectID":"/555timer/:2:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"典型应用 单稳态电路 多谐振荡器 施密特触发器 ","date":"2022-01-02","objectID":"/555timer/:3:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"555定时器为核心的单稳态电路 ","date":"2022-01-02","objectID":"/555timer/:4:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"理论分析 应用电路如下： 稳定状态时，管脚2输入信号为高电平，管脚6跨电容与地相连，相当于输入低电平，复位引脚4接高电平，故输出保持低电平不变，放电二极管保持导通不变。 当输入信号的下降沿到来，输出变为高电平，放电二极管截止，管脚7向外放电，电容C开始充电，直到$ u_C=\\frac{2}{3} V_{cc}$ 若忽略晶体管的饱和压降，则充电时间为 $t_w=RCln \\frac{\\mathrm{Vcc}}{Vcc-\\frac{2}{3} Vcc} =RCln 3 \\approx 1.1 RC$ 当输入信号回到高电平且电容充电完毕后，输出回到低电平，放电二极管截止。 ","date":"2022-01-02","objectID":"/555timer/:4:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"仿真验证 使用Multisim仿真，电路如下： 选用回弹式开关使输入信号在电容充电完毕之前回到高电平，以便于从示波器图形上测得充电时间。 仿真结果： 电路行为与理论分析一致，根据理论分析公式 $\\mathrm{t}_{\\mathrm{w}}=1.1 \\times 10 \\mathrm{k} \\times 4.7 \\mathrm{u}=51.7 \\mathrm{~ms} $,仿真测得充电时间为50.94ms，且充满后电压为2.985V，与理论分析相符的很好。 ","date":"2022-01-02","objectID":"/555timer/:4:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"总结 该单稳态触发器的功能总结为：将低电平脉冲信号（持续时间小于1.1RC）转化为持续时间为1.1RC的高电平信号，持续时间大于1.1RC的话，就只是由低电平转化为高电平。 ","date":"2022-01-02","objectID":"/555timer/:4:3","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"结束语 ","date":"2022-01-02","objectID":"/555timer/:5:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"参考文献 555定时器及应用 电压比较器_百度百科 555定时器_百度百科 NE555P_立创商城 ","date":"2022-01-02","objectID":"/555timer/:5:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"备注 仿真文件及数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-02","objectID":"/555timer/:5:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":null,"content":"关于我是谁 20岁 北京邮电大学19级信息工程专业本科生 技能点主要是软件定义网络（SDN，software defined network）、电子设计以及Python ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"多说几句 博客内容呢，能否转载和是否署名都不是我能控制的事情，毕竟现在的网络时代就是这样。 你们这些学法的到底保护了些什么啊ちくしょう 但是我会永远遵守开源精神，附上我的博客参考的一切。 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"友链 lgt的博客：https://ayamir.github.io/ 黄鸡的博客：https://hyiker.com/ ClSlaid的博客：https://clslaid.icu/ liCheng前辈的博客：http://www.muzixing.com/ 广告位招租 ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"}]