[{"categories":["Network"],"content":"在linux平台安装OLSR协议 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:0:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"前言 因为要做一个OLSR和SDN自定义控制面的对比实验，所以要利用mininet-wifi平台自定义拓扑跑一下OLSR协议。 平台：ubuntu20.04 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:1:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"安装 官网：www.olsr.org/ github：https://github.com/OLSR/olsrd ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:2:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"通过mininet-wifi安装 进入mininet-wifi目录sudo ./install.sh -o ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:2:1","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"从git安装(没有亲自试，来自网络) 安装语法分析器：sudo apt install bison flex 下载源码：git clone https://github.com/OLSR/olsrd 编译：cd olsrd;make 安装：sudo make install ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:2:2","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"mininet-wifi拓扑构建 构造一个网络拓扑来测试OLSR协议。 拓扑文件（参考example/adhoc.py）： https://github.com/leeshy-tech/mininet-wifi/blob/master/examples/OLSR/olsr_test.py #!/usr/bin/python \"\"\" This example use four motionless station to test the OLSR protocol in adhoc network. It's almost the same as example/adhoc.py. use \"sudo python olsr_test.py olsrd\" in terminal to run it. \"\"\" import sys from mininet.log import setLogLevel, info from mn_wifi.link import wmediumd, adhoc from mn_wifi.manetRoutingProtocols import olsrd from mn_wifi.cli import CLI from mn_wifi.net import Mininet_wifi from mn_wifi.wmediumdConnector import interference def topology(args): \"Create a network.\" net = Mininet_wifi(link=wmediumd, wmediumd_mode=interference) info(\"*** Creating nodes\\n\") kwargs = dict() if '-a' in args: kwargs['range'] = 100 sta1 = net.addStation('sta1', ip6='fe80::1',position='25,50,0', **kwargs) sta2 = net.addStation('sta2', ip6='fe80::2',position='75,10,0', **kwargs) sta3 = net.addStation('sta3', ip6='fe80::3',position='75,90,0', **kwargs) sta4 = net.addStation('sta4', ip6='fe80::4',position='125,50,0', **kwargs) net.setPropagationModel(model=\"logDistance\", exp=4) info(\"*** Configuring wifi nodes\\n\") net.configureWifiNodes() info(\"*** Creating links\\n\") # MANET routing protocols supported by proto: # babel, batman_adv, batmand and olsr # WARNING: we may need to stop Network Manager if you want # to work with babel protocols = ['babel', 'batman_adv', 'batmand', 'olsrd', 'olsrd2'] kwargs = dict() for proto in args: if proto in protocols: kwargs['proto'] = proto net.addLink(sta1, cls=adhoc, intf='sta1-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.addLink(sta2, cls=adhoc, intf='sta2-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.addLink(sta3, cls=adhoc, intf='sta3-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.addLink(sta4, cls=adhoc, intf='sta4-wlan0', ssid='adhocNet', mode='g', channel=5, ht_cap='HT40+', **kwargs) net.plotGraph(max_x=200, max_y=200) info(\"*** Starting network\\n\") net.build() info(\"\\n*** Addressing...\\n\") if 'proto' not in kwargs: sta1.setIP6('2001::1/64', intf=\"sta1-wlan0\") sta2.setIP6('2001::2/64', intf=\"sta2-wlan0\") sta3.setIP6('2001::3/64', intf=\"sta3-wlan0\") sta4.setIP6('2001::4/64', intf=\"sta4-wlan0\") info(\"*** Running CLI\\n\") CLI(net) info(\"*** Stopping network\\n\") net.stop() if __name__ == '__main__': setLogLevel('info') topology(sys.argv) 可视化： 解读： 从图中可以看出，sta1只能与sta2和sta3进行单跳通信，如果要与sta4通信，就需要sta2或者sta3进行中继。如果没有OLSR协议，节点在收到目的IP不是本节点的包之后就会丢掉，无法完成中继。OLSR协议会在网络中的节点维护整个网络拓扑，就能完成中继。 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:3:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"实验测试 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"关闭NetworkManager sudo systemctl stop NetworkManager NetworkManager是linux的自动网络配置工具，我们希望自己配置网络，所以要把它关掉。 查看节点的网络状态ip addr，没有图中的NO-CARRIER说明NetworkManager已经被关闭。（这个命令可以在本机运行，也可以在mininet虚拟主机运行。） ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:1","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"配置OLSR 编辑配置文件：vim /etc/olsrd/olsrd.conf 添加所有节点的网卡： 退出、保存 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:2","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"运行拓扑文件 sudo python olsr_test.py olsrd ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:3","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"网络测试 sta1 ping sta4 能ping通，说明OLSR协议运行正常。 查看路由：sta3 route 多了三条路由，这是OLSR协议运行的结果。 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:4:4","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"结束 ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:5:0","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"恢复系统 开启NetworkManager：sudo systemctl start NetworkManager 退出mininet-wifi：exit 清理系统：sudo mn -c ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:5:1","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Network"],"content":"参考文献 centos7 开启 关闭 NetworkManager Linux虚拟机下OLSR协议的安装 Unable to create IPv6 multi hop mesh network in ad hoc mode #342这个issue救了大命了 Linux卸载olsrd,olsrd路由协议移植到嵌入式linux中使用 www.olsr.org/官网写的说明太少了，根本看不懂，麻了。 https://github.com/OLSR/olsrd ","date":"2022-03-27","objectID":"/network_olsr_with_mininet-wifi/:5:2","tags":["Network","OLSR","mininet-wifi"],"title":"网络实验——在linux平台安装OLSR协议","uri":"/network_olsr_with_mininet-wifi/"},{"categories":["Linux"],"content":"图片url生成 ","date":"2022-03-17","objectID":"/linux_image_url/:0:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"准备 ","date":"2022-03-17","objectID":"/linux_image_url/:1:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"安装JDK，JRE 下载linux的jdk，jre压缩包： https://www.oracle.com/java/technologies/downloads/#java8 用xftp传到服务器上。 解压tar -zxvf jdk-17_linux-x64_bin.tar.gz jre-8u321-linux-x64.tar.gz，记住此时所在的路径（pwd命令可查）。 配置环境变量： cd /etc vim profile i进入编辑模式 文件末尾加上如下代码，JAVA_HOME,JRE_HOME分别为解压的文件夹的路径： export JAVA_HOME=/home/ubuntu/jdk-17.0.2 export JRE_HOME=/home/ubuntu/jre1.8.0_321 export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH Esc退出，输入:wq保存退出。 使能配置：source /etc/profile 检验：java -version，输出版本信息，安装成功。 ","date":"2022-03-17","objectID":"/linux_image_url/:1:1","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"安装tomcat 下载安装包： https://tomcat.apache.org/download-10.cgi 用xftp传到服务器上，解压tar -zxvf apache-tomcat-10.0.18.tar.gz 进入bin目录，启动tomcat cd apache-tomcat-10.0.18/bin ./startup.sh ","date":"2022-03-17","objectID":"/linux_image_url/:1:2","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"防火墙设置 到服务器控制台，开启8080端口： 浏览器访问服务器IP:8080地址，看到tomcat默认页说明tomcat安装运行成功。 ","date":"2022-03-17","objectID":"/linux_image_url/:1:3","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"生成图片url 假设图片存放在服务器路径：/home/ubuntu/image 进入tomcat文件夹的conf路径，编辑server.xml： cd conf vim server.xml 结尾处插入此代码\u003cContext docBase=\"/home/ubuntu/image\" path=\"/pictures\" debug=\"0\" reloadable=\"true\"/\u003e 则可以通过url=http://ip:8080/path/图片名+后缀访问该图片。 ","date":"2022-03-17","objectID":"/linux_image_url/:2:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"结束语 ","date":"2022-03-17","objectID":"/linux_image_url/:3:0","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Linux"],"content":"参考文献 https://www.bilibili.com/video/BV1uh411a7Jg?p=268 tomcat启动“成功”，但是浏览器无法访问 访问 Linux 服务器上的文件（以图片为例 ","date":"2022-03-17","objectID":"/linux_image_url/:3:1","tags":["Linux","tomcat"],"title":"Linux——图片url生成","uri":"/linux_image_url/"},{"categories":["Install"],"content":"Ryu安装 ","date":"2022-03-07","objectID":"/ryu_install/:0:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"安装git sudo apt install git ","date":"2022-03-07","objectID":"/ryu_install/:1:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"安装python3 时代变了，不装不行。 下载 sudo apt install python3 查看python3的位置和版本号，用于第四步 whereis python3 删除原来python2的软连接 sudo rm /usr/bin/python 建立新的软连接 sudo ln -s /usr/bin/python3.9 /usr/bin/python 查看版本 python --version ","date":"2022-03-07","objectID":"/ryu_install/:2:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"安装Ryu 更新pip sudo pip install --upgrade pip 克隆源代码 git clone git://github.com/faucetsdn/ryu.git 进入ryu目录 cd ryu 安装依赖 sudo pip install -r tools/pip-requires 安装ryu sudo python setup.py install ","date":"2022-03-07","objectID":"/ryu_install/:3:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"测试 进入ryu/ryu/app目录 cd ryu/ryu/app 运行simple_switch.py ryu-manager app/simple_switch.py 出现以下输出为正常： loading app app/simple_switch.py\rloading app ryu.controller.ofp_handler\rinstantiating app app/simple_switch.py of SimpleSwitch\rinstantiating app ryu.controller.ofp_handler of OFPHandler\r ","date":"2022-03-07","objectID":"/ryu_install/:4:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"参考文献 Ubuntu将默认python版本改为python3 https://github.com/leeshy-tech/ryu ","date":"2022-03-07","objectID":"/ryu_install/:5:0","tags":["Ryu"],"title":"Ryu——安装","uri":"/ryu_install/"},{"categories":["Install"],"content":"install mysql on linux ","date":"2022-03-07","objectID":"/mysql_install/:0:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"安装： sudo apt update sudo apt install mysql-server ","date":"2022-03-07","objectID":"/mysql_install/:1:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"配置root密码为123456： sudo mysql use mysql; update user set authentication_string='' where user='root'; alter user 'root'@'localhost' identified with mysql_native_password by '123456'; ","date":"2022-03-07","objectID":"/mysql_install/:2:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"参考文献： Ubunto20.04安装MySQL并修改root用户密码 如何在 Ubuntu 20.04 上安装 MySQL ","date":"2022-03-07","objectID":"/mysql_install/:3:0","tags":["mysql"],"title":"install mysql on linux","uri":"/mysql_install/"},{"categories":["Install"],"content":"安装mininet-wifi mininet学了快半年了，还是安装七八次才能装上，人麻了，怒写一篇博客。平台：Ubuntu20.04。 ","date":"2022-03-07","objectID":"/mininet-wifi_install/:0:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"安装git sudo apt install git ","date":"2022-03-07","objectID":"/mininet-wifi_install/:1:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"安装python3 mininet在python2和python3环境下都是能正常运行的，但是，apt中一些python2的包已经升级到3了，比如python-matplotlib，你不升级python3，mininet-wifi就会安装它，但是apt里又没有，只会一直报错。你再怎么更新源，也找不到这个玩意，因为它已经变成python3-matplotlib了。所以还是要安装python3。 下载 sudo apt install python3 查看python3的位置和版本号，用于第四步 whereis python3 删除原来python2的软连接 sudo rm /usr/bin/python 建立新的软连接 sudo ln -s /usr/bin/python3.9 /usr/bin/python 查看版本 python --version ","date":"2022-03-07","objectID":"/mininet-wifi_install/:2:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"安装mininet-wifi ","date":"2022-03-07","objectID":"/mininet-wifi_install/:3:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"有梯子，或者有git代理 克隆源代码 git clone https://github.com/intrig-unicamp/mininet-wifi 查看安装可选项 sudo mininet-wifi/util/install.sh -h 选择一些项安装（默认就按这个） sudo mininet-wifi/util/install.sh -Wlnfv ","date":"2022-03-07","objectID":"/mininet-wifi_install/:3:1","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"无代理 这里主要是指以https无法正常访问github的情况，需要把所有的git网址改为git://开头，因为install.sh里会有下载其他库的git命令，所以直接运行install.sh会报git超时，需要提前把相关库下好。 克隆 git clone git://github.com/intrig-unicamp/mininet-wifi git clone git://github.com/ramonfontes/mac80211_hwsim_mgmt git clone git://github.com/mininet/mininet git clone git://github.com/vchakour/wmediumd 选择一些项安装（默认就按这个） sudo mininet-wifi/util/install.sh -Wlnfv ","date":"2022-03-07","objectID":"/mininet-wifi_install/:3:2","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"运行 运行，这句正常运行就说明下载成功。 sudo mn --wifi 退出 exit 清理 sudo mn -c ","date":"2022-03-07","objectID":"/mininet-wifi_install/:4:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Install"],"content":"参考文献 https://github.com/intrig-unicamp/mininet-wifi Ubuntu将默认python版本改为python3 ","date":"2022-03-07","objectID":"/mininet-wifi_install/:5:0","tags":["mininet-wifi"],"title":"mininet-wifi——安装","uri":"/mininet-wifi_install/"},{"categories":["Paper"],"content":"Wireless SDN Mobile Ad Hoc Network:from Theory to Practice. ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:0:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/7996340 2017 IEEE International Conference on Communications (ICC) 自翻：https://github.com/leeshy-tech/PaperTranslate/blob/main/wireless_SDN_mobile.md ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:1:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"重要的名词 D2D （device to device） MANET （移动自组织网络） VANET（车辆自组织网络） 本地流量：信息流的源和目的距离很近的数据连接。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:2:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"引言 根据思科[1]最近的一份报告，通过无线网络传输的数据流量正在不断增加，不久将超过有线流量。在未来的5G场景中，无线流量的模式将对本地流量产生越来越大的需求。 使用当前的网络标准，即使是本地数据也要通过蜂窝网络传输到一个集中的实体，然后再重新分发。对于本地流量的交换来说，这种方法显然不是最优的。一种更有前途的方法依赖于设备到设备(D2D)技术[4]，其中设备可以在MANET或者VANET[6]中以分布式方式组织。 在没有集中控制的情况下，每个节点必须独立行动，做出路由决策，并在移动网络中动态地适应快速变化的拓扑结构。前人提出了一些解决方案： 按需距离矢量(AODV)协议，它仅在需要时才寻找路由路径，适合流量偶发的场景。 优化的链路状态路由（OLSR）协议，当几个源-目的对之间的流量比较正常的情况下，预先定义网络中每个可能的节点对之间的路由的主动协议。 区域路由（ZRP）协议，将网络划分为多个集群，如果源节点和目的节点在同一个集群中，则使用OLSR等主动路由策略;否则，采用反应性策略，如AODV。 OLSR的主要问题：它需要节点之间频繁的控制消息交换，以维护每个节点上更新的网络拓扑。ZRP能够显著减少控制消息的数量，因为更新的拓扑信息只需要在每个集群中的节点之间进行维护，但是当一个包被发送到一个属于不同集群的节点时，会引入显著的延迟，因为新的路径应该以响应式的方式搜索。 在节点具有移动性的条件下，必须在减少开销（网络中交换的控制信息）和完全掌握网络拓扑之间做出权衡，如果要设计更好的传输路线，则要更频繁地交换控制信息，不仅耗费了更多的带宽资源，而且也增加了设备的处理压力。 为了适应这种网络不断变化的移动特性，我们参考SDN范例，将数据平面（包括节点之间本地交换的所有数据流量）与控制平面（包括所有的控制报文和本地路由决策）隔开。他们实现的结构是，设备中有两个用于 DP （data plane）和 CP（control plane） 的无线接口，设备以星形拓扑结构与集中式单元CU连接，CU以集中的方式做出路由决策，几乎实时地了解拓扑。这个框架的两个主要优点： ad hoc网络中引入的开销是最小的,每个节点只需要知道它的邻居并且把该信息传给CU。 根本上减少了每个节点的复杂性,因为路由算法运行在CU。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:3:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"SDN MANET的结构 DP MAC协议：采用了ieee802.11的P2P模式独立基本服务集(IBSS)[16]，这是ieee802.11的特设模式标准，根据我们的方法的需要，将交换能力完全控制给上层。 SDN协议：OpenFlow。 无线交换机：Open vSwitch (OVS)。 控制器：ON开发的Open Network Operating System (ONOS)。 平台：Rasp berry Pi(树莓派)Model B+，Linux操作系统 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:4:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"实现细节 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:5:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"修改MAC头 为了实现SDN架构，需要修改交换机设备的Linux内核，允许CU直接控制节点的路由。 图中左侧为标准 Linux 内核协议栈中从物理层 (PHY) 到应用层 (APP) 的逻辑数据流， 以太网帧通过铜缆（在 PHY 层）到达设备，并被发送到以太网驱动程序（在 MAC 层），在删除 PHY 标头并将它们发送到以太网堆栈之前检查它们的完整性。 在以太网堆栈中，在将数据包发送到路由所在的 NET 层之前，MAC 标头也被删除。 如果从无线接口接收到 Wi-Fi 数据包，则数据包首先被发送到 Wi-Fi 驱动程序，在那里去除 PHY 包头，然后由特定模块处理，将 Wi-Fi 数据包转换为以太网数据包，随后被发送到以太网堆栈。 在 SDN 块中，数据报可以根据从 SDN 控制器接收到的规则进行修改。 特别是，为了控制路由路径，SDN控制器强加的规则涉及修改相应数据报的MAC头。 在这些修改之后，数据报将被发送回 SDN 网桥，并转发到以太网堆栈进行与左侧情况相同的处理。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:5:1","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"多跳过程分析 如图所示，涉及从源节点（S）到目的地 (D)的两跳传输。 数据包由 S 生成。它首先传输到辅助节点 (H)，然后由 H 中继到 D。 数据包由主机 S (hS) 生成，它在 IP 报头和 MAC 报头中指定目标主机 D (hD) 的地址。 hS 不知道到达 hD 所需的任何路由信息。 它只是通过有线信道将数据包传输到节点 S (sS) 的交换机，该交换机负责无线传输它。 sS 正在运行 SDN 模块，该模块根据从 SDN 控制器接收到的指令修改 MAC 层的源地址和目标地址。 MAC头中的源和目的地分别变成sS和sH（节点H的交换机）。 然后，数据包可以被 sS 发送，也可以被 sH 接收。 由于数据包中的目的MAC地址为sH，因此数据包由sH进一步处理，并向sS发回确认（ACK）。sH 执行类似的过程，修改目的MAC地址，数据包可以被转发到目的节点（sD）的交换机。 最后，sD 根据来自 SDN 控制器的另一条规则，将源 MAC 地址和目标 MAC 地址分别修改为 hS 和 hD。 这个过程，称为 MAC 恢复，是必要的，以便 hD 识别数据包是由 hS 发送的，而不需要来自 SDN 框架的任何进一步信息。 对于大多数 Wi-Fi 适配器，如果 固件的MAC 和目的地不匹配，则固件中会丢弃数据包，因此修改 MAC 地址是多跳传送数据包的必要步骤。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:5:2","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"平台测试：性能比较 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"网络设置 实验场景由具有三个 SDN 节点的 SDN MANET 组成，标记为 S、H 和 D，如上一节所示，部署如图所示。每个节点由一个 RPi Model B+ 和一个 Wi -Fi 适配器（Ralink RT5370 USB）组成，DP 中的传输使用 IEEE 802.11g ad-hoc 模式。 三个 SDN 节点配备了 OVS-2.4.0，并连接到运行 ONOS 控制器的 CU 和我们的 MANET 应用程序 [12]。 第二个网络名为 OLSR MANET，它使用相同位置和相同拓扑的相同三个节点（S、H 和 D）进行比较。 实际上，在第二个网络中，节点没有配备我们的 SDN 框架，但它们正在运行分布式路由策略 OLSR。 在这两个网络中，数据流量都是在节点 S 使用流量生成器 iPerf3 [35] 生成的，该流量生成器会创建一个随机 TCP 流，流向目的地节点 D。实验时间为 N 秒，时间间隔为 1秒。 对于每个间隔 τn，n = 1,…,N，端到端吞吐量以每秒比特 (bps) 为单位测量为： $$ T\\left(\\tau_{n}\\right)=\\frac{\\text { TCP } \\text { RWND } \\times 8}{\\text { RTT }} $$ 其中 TCP RWND 是间隔 τi 期间 TCP 会话的平均接收窗口大小，RTT 是平均往返时间，即从发送的 TCP 段的第一个比特传输到接收到该 TCP 段的 TCP ACK的最后一个比特所经过的时间。 为了比较 SDN MANET 和 OLSR MANET 在拓扑突然变化的情况下的行为，我们改变了图a的全连接拓扑为图b的多跳拓扑（S和D之间没有直接连接）。实现的方法是，在节点的 MAC 层设计一个模块来模拟 S 和 D 之间的链路故障，该模块可以拒绝来自 S 的所有数据包（对于 节点 D），或来自 D（对于节点 S）。 这样，我们可以在我们的实验中完美地控制 S 和 D 之间的链路何时发生故障，或者何时重新启动。 对于 SDN MANET 和 OLSR MANET，每个实验重复 M = 20 次。 结果中显示的平均吞吐量为： $$ \\bar{T}\\left(\\tau_{n}\\right)=\\frac{\\sum_{m=1}^{M} T_{m}\\left(\\tau_{n}\\right)}{M} $$ 其中 Tm(τn) 是第 m 次实验在时间间隔 τn 期间获得的吞吐量。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:1","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"链路断开实验 在时间 t = 10，S 和 D 之间的直接链路发生故障。 SDN控制器立即收到此事件的通知，并迅速做出反应，将新的SDN规则强加给节点S和H。这样，节点S将所有发往D的数据包发送给H，H将这些数据包转发给D。 SDN MANET 的吞吐量立即恢复到初始吞吐量的一半，因为从 S 到 D 的新路径现在有两跳。 OLSR MANET 能够识别链路故障并通过仅在 t = 25 时将路径更改为 D 来对其做出反应，延迟约 15 秒，从而导致严重的吞吐量中断。 这个结果是意料之中的，因为 OLSR 有一个完全分布式的路由算法，它需要大量时间来更新。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:2","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"连接实验 在第二个实验中，我们观察了当初始拓扑是图b中的拓扑时，SDN MANET 和 OLSR MANET 经历的平均吞吐量，即 S 和 D 之间的两跳路径。 在 t = 10 时，S 和 D 之间的直接链接也被激活，如图a所示。 正如预期的那样，我们观察到，在 SDN MANET 的情况下，网络能够迅速对拓扑的变化做出反应，并且吞吐量在 t \u003e 10 时几乎翻了一番。另一方面，OLSR MANET 的延迟约为 20 秒。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:3","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"快速变化拓扑实验 在第三个实验中，有一系列连续的拓扑变化。 在 t = 0 时，拓扑是图a中的拓扑（S 和 D 之间有直接链路），然后在 t = 30 时，拓扑变为图b中的拓扑（两跳） ，然后在 t = 60 时再次切换到图a，最后在 t = 90 时切换到图b。 同样在这种情况下，实验重复 20 次，结果取所有试验的平均值。 对于每个拓扑变化，我们观察到 SDN MANET 如何能够几乎立即对拓扑变化做出反应，而 OLSR MANET 对变化的反应有一定的延迟，正如预期的那样，会导致显著的吞吐量损失。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:6:4","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["Paper"],"content":"结论 在这项工作中，我们提出了一个 SDN MANET 的实际实现，它提供了 D2D 数据传输的所有优点，同时具有集中网络管理的灵活性。 为了展示 SDN MANET 的优势以及所提供的所有软件的有效性，我们将我们的 SDN MANET 与以分布式方式管理的 ad hoc 网络进行了比较。 我们用几个简单的例子强调了我们方法的显着优势，特别是对于快速变化的网络拓扑。 在未来的工作中，我们计划处理大规模的 SDN MANET，解决可能出现的可扩展性问题。 ","date":"2022-03-03","objectID":"/paper_wireless_sdn_mobile/:7:0","tags":["SDN","Paper"],"title":"论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.","uri":"/paper_wireless_sdn_mobile/"},{"categories":["HarmonyOS"],"content":"用户登录 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"项目结构 └─ entry\r├─src.main\r├─ java.com.example.users\r├─beans\r├─ Account API请求体\r└─ LoginMsg API返回体\r├─slice\r├─ UserInfoAbilitySlice 个人主页Slice\r└─ MainAbilitySlice 主页面Slice\r├─utils\r├─ DataBaseUtil 数据库操作类\r├─ HttpRequestUtil API调用类\r└─ LoadImageUtil 网络图片加载到image组件\r├─ LocalDBAbility 本地数据库的DataAbility\r├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r├─ ability_userinfo.xml 个人页面布局文件\r└─ ability_main.xml 主页面布局文件\r└─ build.gradle 添加外部依赖\r","date":"2022-02-20","objectID":"/harmonyos_userlogin/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"效果 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"项目逻辑 此项目的重点是token，它存储在本地数据库，扮演类似浏览器中cookie的角色。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"登陆页 首页获取用户的账号和密码，点击按钮向后端发送http请求。 登陆成功，则将后端返回的token存入本地数据库，并导航到个人页面。 登陆不成功，则使用ToastDialog组件显示提示信息，账号错误或密码错误。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:2:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"个人页 个人页面高度精简，只显示用户头像。 导航到此页，说明用户一定已经登陆。 查询本地数据库，获得token。 向后端发送请求，获取用户头像的url。 将url加载到image组件。 当用户退出APP，清理后台后，仍然能记住登陆状态，导航回个人主页，不用重新登陆。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:2:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"后端接口 代码：https://github.com/leeshy-tech/API_userLogin/blob/main/user_login_token.py 博客：Python实践——后端接口实现(2) ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"准备 这些都是之前的博客详细说过的部分，不再赘述。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"添加依赖 implementation ('com.alibaba:fastjson:1.2.47') ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"本地数据库的DataAbility——LocalDBAbility 把之前写过的照抄过来，改一下数据库名、表名、建表sql语句即可。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"请求体和返回体类——Account，LoginMsg 根据后端接口的格式建立的类。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:3","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"网络图片加载——LoadImageUtil 将网络图片加载到image组件，copy之前的项目。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:4","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"API调用类——HttpRequestUtil 发送HTTP请求的封装类，这个之前没讲过，照抄会用即可。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:4:5","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"DataBaseUtil 为了尽可能的简化主体代码，把从数据库里查询token，和插入token的操作封装成这个类。 //数据库查询、插入 帮助类 public class DataBaseUtil { private static Uri uri = Uri.parse(\"dataability:///com.example.users.LocalDBAbility/user_info\"); public static String getToken(Context context){ String value = null; DataAbilityHelper dataAbilityHelper = DataAbilityHelper.creator(context); String[] colums = {\"token\"}; DataAbilityPredicates predicates = new DataAbilityPredicates(); try { ResultSet rs = dataAbilityHelper.query(uri, colums, predicates); if(rs.getRowCount() \u003e0){ rs.goToFirstRow(); value = rs.getString(0); } } catch (DataAbilityRemoteException e) { e.printStackTrace(); } return value; } public static int setToken(String token,Context context) { int i = 0; ValuesBucket valuesBucket = new ValuesBucket(); valuesBucket.putString(\"token\",token); DataAbilityHelper dataAbilityHelper = DataAbilityHelper.creator(context); try { i = dataAbilityHelper.insert(uri, valuesBucket); } catch (DataAbilityRemoteException e) { e.printStackTrace(); } return i; } } ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"MainAbilitySlice onStart方法： super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); String token_s = DataBaseUtil.getToken(this); //如果本地数据库没有token，说明用户还没有登陆 if (token_s == null) { Button btn_login = findComponentById(ResourceTable.Id_login_btn); TextField tf_userid = findComponentById(ResourceTable.Id_login_id_textfield); TextField tf_userPwd = findComponentById(ResourceTable.Id_login_pwd_textfield); String url = \"http://8.136.83.196:8899/users/login\"; btn_login.setClickedListener(component -\u003e { //开新线程 TaskDispatcher globalTaskDispatcher = this.getGlobalTaskDispatcher(TaskPriority.DEFAULT); //异步 globalTaskDispatcher.asyncDispatch(() -\u003e { String user_id = tf_userid.getText(); String user_pwd = tf_userPwd.getText(); //发送http请求，并获得数据 Account account = new Account(user_id, user_pwd); String account_json = JSON.toJSONString(account); String login_msg = HttpRequestUtil.sendPostRequest(this, url, account_json); LoginMsg login_msg_obj = JSON.parseObject(login_msg, LoginMsg.class); String token = login_msg_obj.getToken(); String msg = login_msg_obj.getMsg(); if (token != null) { //将token存入本地数据库，并跳到个人页 DataBaseUtil.setToken(token, this); present(new UserInfoAbilitySlice(), new Intent()); } else { //返回主线程进行UI重绘，原因是show方法不能在子线程中运行 getUITaskDispatcher().asyncDispatch(new Runnable() { @Override public void run() { new ToastDialog(getContext()).setText(msg).show(); } }); } }); }); } //如果本地数据库有token，说明已经登陆，就跳到个人页 else{ present(new UserInfoAbilitySlice(), new Intent()); } 进来先进行一个判断，若本地数据库里有token，则直接跳转到个人页，为了应对APP被杀死后重启的情况。 按钮监听，获取输入框的信息，向后端发送请求，获得token和msg。 若token不为空，则存到本地数据库，并跳转到个人页。 若token为空，则建立一个ToastDialog组件，显示msg。ToastDialog组件专门用于显示提示信息，它存在几秒后自动消失。 注意\r\r建立Toast Dialog组件这里，重绘UI的操作只能在主线程里运行，在这里指show方法，如果直接写new ToastDialog(getContext()).setText(msg).show();是不行的，因为此时我们正在新建的线程里，这个任务要扔回到主线程，所以才有了以下的代码块。\r\r getUITaskDispatcher().asyncDispatch(new Runnable() { @Override public void run() { new ToastDialog(getContext()).setText(msg).show(); } }); onActive方法： super.onActive(); //程序重新返回前台调用 //若已经登陆，则导航到个人页 String token_s = DataBaseUtil.getToken(this); if (token_s != null){ present(new UserInfoAbilitySlice(), new Intent()); } 当页面从后台返回前台时，调用的是onActive方法，比如用户在导航到个人页之后，点了一下退出键，就会返回默认页，我们不想让他再发一次http请求，检查token，若存在，直接将其导航回个人页。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"UserInfoAbilitySlice onStart方法： super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_userinfo); //能导航到此页说明用户已经登陆，向服务器请求用户的头像 String token = DataBaseUtil.getToken(this); Image image = findComponentById(ResourceTable.Id_image); if (token != null){ //建新线程 TaskDispatcher globalTaskDispatcher = this.getGlobalTaskDispatcher(TaskPriority.DEFAULT); //异步 globalTaskDispatcher.asyncDispatch(()-\u003e{ //发送请求，更新image组件 String url = \"http://8.136.83.196:8899/users/info\"; String img_url = HttpRequestUtil.sendPostRequestWithToken(this,url,token); LoadImageUtil.loadImg(this,img_url,image); }); } 导航到此页时，从本地数据库中取出token，向后端发送。 后端返回头像的url。 将url显示到image组件。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:7:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"一些瑕疵 没有退出登陆键，这个很容易实现，点击按钮，把token删掉即可，我懒得写了。 个人页太简单，懒就一个字。 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:8:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:9:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/Users ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:9:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 HarmonyOS文档 ","date":"2022-02-20","objectID":"/harmonyos_userlogin/:9:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——用户登陆及个人主页","uri":"/harmonyos_userlogin/"},{"categories":["Python"],"content":"增加token验证 书接上文 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:0:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"token是什么 简单来说，token可以认为是身份令牌，当用户登陆成功之后，获得这个令牌，当需要向服务器请求一些私密资源时，便可以提交这个令牌，以证明自己是合法用户。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:1:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"token生成及解析 使用pyjwt这个库：pip install pyjwt ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:2:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"核心代码： import jwt # 加密算法 headers = { \"alg\":\"HS256\", \"typ\":\"JWT\" } # 密钥 SECRET_KEY = \"leeshy\" '''生成一个token''' def token_encode(user_id) -\u003e str: if user_id: payload = { \"user_id\":user_id } token = jwt.encode(payload=payload, key=SECRET_KEY,algorithm='HS256',headers=headers) return token else: return None '''解码token''' def token_decode(token) -\u003e str: payload = jwt.decode(jwt=token,key=SECRET_KEY,verify=False,algorithms='HS256') info = payload[\"user_id\"] return info headers声明加密算法 SECRET_KEY密钥是编码解码的关键 payload项中，有一些官方声明项，除官方声明项外还可以存一些自定义信息。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:2:1","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"用户登陆 如果登陆成功，就返回信息和token，如果不成功，就只返回提示信息。 较上一个版本只有一点改变，核心代码： '''生成一个返回体''' def response_body_login(msg,user_id=None): response_msg = { \"msg\":msg, \"token\":token_encode(user_id) } return jsonify(response_msg) @app.route('/users/login',methods=['POST']) def users_login(): if request.method == \"POST\": user_id = request.json.get(\"user_id\") user_password = request.json.get(\"user_password\") for user_dict in users_list: if user_dict[\"user_id\"] == user_id: if user_dict[\"user_password\"] == user_password: return response_body_login(\"success\",user_id) else: return response_body_login(\"password error\") return response_body_login(\"id not exist\") 规定的请求体格式是application/json ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:3:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"请求用户信息 用户向服务端提供token，验证成功则返回用户头像的url。 @app.route('/users/info',methods=['POST']) def users_info(): if request.method == \"POST\": token = request.headers[\"token\"] try: user_id = token_decode(token) except: return \"token error\" for user_dict in users_headphotos: if user_dict[\"user_id\"] == user_id: return user_dict[\"user_headphoto\"] return \"no headphoto\" token要放在请求头里，所以通过request.headers取得。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:4:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"请求体格式 在前端向后端发送请求时，必须在请求头部分声明请求体格式。 例如：connection.setRequestProperty(\"Content-Type\",\"application/json;charset=utf-8\"); 这个格式是由后端决定的，否则后端无法取到对应的信息。 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:5:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"application/x-www-form-urlencoded 这是最常见的 POST 提交数据的方式，提交时按照键值对key1=val1\u0026key2=val2的方式进行编码。 版本1时，就使用了这种方法调试，所以后端代码对应的是： user_id = request.form.get(\"user_id\") user_password = request.form.get(\"user_password\") ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:5:1","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"application/json 指示服务端消息主体是序列化的JSON字符串。 本次使用的调试方式是json，所以后端代码对应： user_id = request.json.get(\"user_id\") user_password = request.json.get(\"user_password\") ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:5:2","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"调试 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:6:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"结束语 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:7:0","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"源码 https://github.com/leeshy-tech/API_userLogin ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:7:1","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"参考文献 【记录】form-data与x-www-form-urlencoded的区别 ","date":"2022-02-20","objectID":"/pythonapi_simplelogin2/:7:2","tags":["Python","API","token","pyjwt"],"title":"Python实践——后端接口实现(2)","uri":"/pythonapi_simplelogin2/"},{"categories":["Python"],"content":"自己动手写一个API ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:0:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"相关概念 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"端口Port 这里端口指的是网络端口，利用IP+端口号可以唯一的定位一台主机上的某个应用程序，可以认为端口是APP之间交换数据的“门”，要想与某APP进行通信，就需要知道它运行在哪个主机的哪个端口上。 我们要写一个API，实质上是写了一个完成特定功能的应用程序，它的接口暴露在外，以供其他程序员调用。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"URL (Uniform Resource Locator) 统一资源定位符，是互联网上标准资源的地址。而互联网上的每个文件都有唯一的一个的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。格式为protocol :// ip[:port] / path / [;parameters][?query]#fragment 一个应用程序可以暴露多个接口，比如用户登陆、用户注册，url可以是/user/userlogin、/user/usersignup。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"HTTP、HTTPS、POST、GET 超文本传输协议（HTTP）的设计目的是保证客户端与服务器之间的通信。客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。 HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包，更加安全。 POST和GET都是HTTP协议的请求方法，除了它们还有HEAD、PUT等方法。 GET方法将查询字符串放在请求的URL中： /test/demo_form.php?name1=value1\u0026name2=value2 POST方法将查询字符串放在HTTP消息主体中： POST /test/demo_form.php HTTP/1.1\rHost: runoob.com\rname1=value1\u0026name2=value2\r 总的来说，POST方法更加安全，详细区别可参考结尾文章。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:3","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"JSON JSON: JavaScript Object Notation(JavaScript 对象表示法) 它采用完全独立于编程语言的文本格式来存储和表示数据。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 将API看作函数，请求体就是参数，响应体就是返回值，按照JSON格式设计请求体和响应体，前后端程序就能通过JSON解析器互相沟通。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:1:4","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"准备 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"安装库 pip install flask,flask_cors,gevent ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"功能设计 设计一个简单的用户登陆功能，前端提供账号密码，服务端返回提示消息。 账号密码正确，返回success 密码错误，返回password error 账号不存在，返回id not exist ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"参数 协议：HTTP（HTTPS会涉及到一些复杂的设置，下次再说。） 方法：POST 请求体示例： { {\"user_id\":\"2019210777\"}, {\"user_password\":\"123456\"} } 响应体示例： { {\"msg\":\"success\"} } ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:2:3","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"核心代码 关于端口\r\r程序里的端口号自主选择，不与其他服务冲突即可。如果冲突会报错：地址(‘0.0.0.0’,port)已被使用，被使用的不是IP地址，而是端口号。要么更换端口，要么杀死该端口的服务（Google相关的命令即可）。\r\r from flask import Flask,request,jsonify from flask_cors import CORS from gevent import pywsgi port = 8899 app = Flask(__name__) CORS(app,resource=r'/*') users_list = [ {\"user_id\":\"2019210777\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210778\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210779\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210780\",\"user_password\":\"123456\"}, {\"user_id\":\"2019210781\",\"user_password\":\"123456\"} ] '''生成一个返回体''' def response_body(msg): response_msg = [ {\"msg\":msg} ] return jsonify(response_msg) @app.route('/login',methods=['POST']) def func(): if request.method == \"POST\": user_id = request.form.get(\"user_id\") user_password = request.form.get(\"user_password\") for user_dict in users_list: if user_dict[\"user_id\"] == user_id: if user_dict[\"user_password\"] == user_password: return response_body(\"success\") else: return response_body(\"password error\") return response_body(\"id not exist\") if __name__ == \"__main__\": server = pywsgi.WSGIServer(('0.0.0.0',port),app) server.serve_forever() print(\"end\") ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:3:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"调试 使用Postman进行调试，新建一个请求，填入相关参数。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:4:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"部署 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:5:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"为什么要部署 写好这个API之后，我尝试写了一个鸿蒙应用来调用，但是始终连接超时，原因如下： 鸿蒙模拟器应当是运行在华为的某台服务器上，它与我的电脑不在同一局域网内，我的电脑的局域网IP，它肯定是访问不到的。 而我用Postman调试，自己访问自己，处于局域网内，所以是没有问题的。 要是想在局域网外进行访问，还是要部署到有公网IP的服务器上。 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:5:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"云服务器 我使用的是阿里云服务器 防火墙设置 默认情况下，8899端口的进出流量是不能通过阿里云防火墙的，我们新建一条安全组规则。 运行代码 远程到服务器，执行以下命令： 安装git：yum install git 下载代码：git clone https://github.com/leeshy-tech/API_userLogin 进入目录：cd API_userLogin 执行代码：python user_login.py 调试 在Postman里，url里的IP改为服务器的公网IP，发送请求，调试成功。 服务器也有相应的输出： ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:5:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"结束语 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:6:0","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"项目源码 https://github.com/leeshy-tech/API_userLogin ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:6:1","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["Python"],"content":"参考文献 HTTP 方法：GET 对比 POST_菜鸟教程 JSON教程_菜鸟教程 https://www.bilibili.com/video/BV1TJ411G7po?spm_id_from=333.999.0.0 使用nodejs编写api接口并部署到服务器上 ","date":"2022-02-15","objectID":"/pythonapi_simplelogin/:6:2","tags":["Python","API"],"title":"Python实践——后端接口实现","uri":"/pythonapi_simplelogin/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-02-12","objectID":"/harmonyos_api/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"项目结构 └─ entry\r├─src.main\r├─ java.com.example.api\r├─beans\r├─ requestBody API请求体\r└─ returnBody API返回体\r├─slice\r└─ MainAbilitySlice 主页面Slice\r├─utils\r├─ baiduApi 百度API调用\r├─ HttpRequestUtil 一般API调用，本项目没用到，但是很重要\r└─ LoadImageUtil 网络图片加载到image组件\r├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r└─ ability_main.xml 主页面布局文件\r└─ build.gradle 添加外部依赖\r","date":"2022-02-12","objectID":"/harmonyos_api/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"效果 单击按钮，将输入框内的文字转换为二维码显示在下方。 用手机扫码，解码的信息与文字相同。 ","date":"2022-02-12","objectID":"/harmonyos_api/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"铺垫 ","date":"2022-02-12","objectID":"/harmonyos_api/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"HTTP 注意\r\r本项目中调用API使用的是https方式，这部分仅作笔记。\r\r 在鸿蒙应⽤中默认只允许访问https接⼝，如果要访问http接⼝，需要在config.json的deviceConfig项中添加如下配置： \"deviceConfig\": { \"default\": { \"network\": { \"cleartextTraffic\": true } } } ","date":"2022-02-12","objectID":"/harmonyos_api/:2:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"JSON API请求体的传入和响应体的解析需要JSON格式的字符串、把JSON字符串转换为对象，虽然也可以用转义符等方式实现，但还是用外部依赖比较方便，常用的依赖有Gson、FastJson、Jackson，本项目使用的是FastJson。 借助转义符传递JSON be like： String jsonBody = \"{\\n \\\"data\\\" : \\\"https://apis.baidu.com/\\\",\\n\" + \" \\\"size\\\" : 20,\\n\" + \" \\\"level\\\" : \\\"L\\\",\\n\" + \" \\\"format\\\" : \\\"jpg\\\",\\n\" + \" \\\"logo\\\" : \\\"https://apisown-test.bj.bcebos.com/qr-code-api-store.png\\\"\\n}\"; 我的老天，它实在是太丑陋了。 ","date":"2022-02-12","objectID":"/harmonyos_api/:2:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"引入外部依赖 添加依赖库fastjson，以及百度的依赖库api-explorer-sdk。 在entry \u003e build.gradle中添加：implementation ('com.baidubce:api-explorer-sdk:1.0.3.1','com.alibaba:fastjson:1.2.47') 技巧\r\r添加外部依赖的方法，详见：鸿蒙开发笔记——引入外部依赖\r\r ","date":"2022-02-12","objectID":"/harmonyos_api/:2:3","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"API调用 API的功能是将字符串转化为二维码图片，这里选用的是百度的API，原因是：有例程。对于我这种啥都没学扎实的人来说，能降低点难度最好。 ","date":"2022-02-12","objectID":"/harmonyos_api/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"API需要注意的点 调用方式：HTTP or HTTPS? POST？GET？DELETE？ 请求体参数。 响应体参数：取决于你如何取到你想要的返回值。 认证密钥。 从该API的介绍中我们看到：http和https均可，POST方式，有认证密钥，请求体和响应体参数示例如下： ","date":"2022-02-12","objectID":"/harmonyos_api/:3:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"核心代码 请求体和响应体各写成一个类：requestBody 、returnBody //API的请求体，共五个参数 public class requestBody { private String data; private int size; private String level; private String format; private String logo; ... } //API的响应体类，只有一个参数 public class returnBody { private String imageUrl; ... } 调用API的过程封装成类的函数：baiduApi.sendRequest(requestBody request_body) //百度API的请求代码，由示例代码更改而来：https://apis.baidu.com/store/detail/581576df-bc52-4e4a-8a3a-2abd6035e7ae public static String sendRequest(requestBody request_body) { //填入自己的accessKey，secretKey，否则项目无法正常运行。 String accessKey = \"accessKey\"; String secretKey = \"secretKey\"; String result = null; String path = \"http://qrcode.api.bdymkt.com/qrcode/generate\"; ApiExplorerRequest request = new ApiExplorerRequest(HttpMethodName.POST, path); request.setCredentials(accessKey, secretKey); // 设置header参数 request.addHeaderParameter(\"Content-Type\", \"application/json;charset=UTF-8\"); // 设置jsonBody参数 String objStr = JSON.toJSONString(request_body); request.setJsonBody(objStr); ApiExplorerClient client = new ApiExplorerClient(new AppSigner()); try { ApiExplorerResponse response = client.sendRequest(request); // 返回结果格式为Json字符串 result = response.getResult(); } catch (Exception e) { e.printStackTrace(); } return result; } ","date":"2022-02-12","objectID":"/harmonyos_api/:3:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"按键监听 注意\r\r本部分参考官方文档 \u003e Ability框架 \u003e 线程管理\r\r 这里的按键监听与之前稍有不同，原因是调用API是一个耗时的工作，它不能在主线程中运行，需要在按键监听器中使用新的线程。 ","date":"2022-02-12","objectID":"/harmonyos_api/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"核心代码 MainAbilitySlice的onStart方法： //设置按键监听 btn1.setClickedListener(component -\u003e { //开一个新线程 TaskDispatcher globalTaskDispatcher = this.getGlobalTaskDispatcher(TaskPriority.DEFAULT); //异步 globalTaskDispatcher.asyncDispatch(()-\u003e{ //调用API生成二维码图片（网络地址） //返回字符串格式：{\"imageUrl\":\"https://bj.bcebos.com/qr-code/22021215e07535dcaa53.jpg\"} String string = tf1.getText(); requestBody request_body = new requestBody(string,20,\"L\",\"jpg\", \"https://apisown-test.bj.bcebos.com/qr-code-api-store.png\"); String request_result = baiduApi.sendRequest(request_body); //将JSON字符串转换为类，取出imageUrl returnBody returndata = JSON.parseObject(request_result, returnBody.class); String image_url = returndata.getImageUrl(); //将网络图片显示到image组件 LoadImageUtil.loadImg(this,image_url,image1); }); }); 在新线程的异步方法里写入监听逻辑：调用API并将返回的网络图片url显示到image组件。 ","date":"2022-02-12","objectID":"/harmonyos_api/:4:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"网络图片显示 注意\r\r本部分参考官方文档 \u003e 媒体 \u003e 图像 \u003e 位图操作开发指导 \u0026 图像解码开发指导。\r\r 当我们API调用成功之后，我们就需要显示这个图片，但是image组件的setImageElement()方法的输入参数类型只能是Element，而Element类型是鸿蒙的本地数据文件管理类型，也就是说通过这个方法只能让image组件显示本地的图片，我们获得的网络图片地址在这里是不能用的。 我们需要自己写接口来实现网络图片的显示：LoadImageUtil.loadImg(Context context, String netImgUrl, Image image) //将网络图片加载到context的image组件里 public static void loadImg(Context context, String netImgUrl, Image image){ //创建一个新线程 TaskDispatcher globalTaskDispatcher = context.getGlobalTaskDispatcher(TaskPriority.DEFAULT); globalTaskDispatcher.asyncDispatch(()-\u003e{ HttpURLConnection connection = null; try{ //建立与网络图片之间的http连接 URL url = new URL(netImgUrl); connection = (HttpURLConnection) url.openConnection(); connection.connect(); //从连接中获取输入流 InputStream inputStream = connection.getInputStream(); //根据数据流将图片数据缓存到ImageSouce对象，创建图片对象 ImageSource imageSource = ImageSource.create(inputStream,new ImageSource.SourceOptions()); //图片数据解码的参数 ImageSource.DecodingOptions decodingOptions = new ImageSource.DecodingOptions(); decodingOptions.desiredPixelFormat = PixelFormat.ARGB_8888; //PixelMap对象就表示一个图片 PixelMap pixelmap = imageSource.createPixelmap(decodingOptions); //将图片载入到组件中：在鸿蒙应用中将图片载入到组件，推荐在一个独立的UI线程中完成 context.getUITaskDispatcher().asyncDispatch(()-\u003e{ image.setPixelMap(pixelmap); pixelmap.release();//释放图片 }); }catch (IOException e){ e.printStackTrace(); } }); } 主要思路： 建立网络连接获得图片数据 图片数据解码 转换成位图对象pixelmap 通过image.setPixelMap(pixelmap)方法载入图片 ","date":"2022-02-12","objectID":"/harmonyos_api/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-12","objectID":"/harmonyos_api/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"项目地址 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/Api ","date":"2022-02-12","objectID":"/harmonyos_api/:6:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"参考文献 Fastjson 使用实例 Java 中 JSON 的使用 百度智能云——二维码生成识别 HarmonyOS文档 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 ","date":"2022-02-12","objectID":"/harmonyos_api/:6:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——调用API","uri":"/harmonyos_api/"},{"categories":["HarmonyOS"],"content":"Gradle 简单的说，Gradle是一个构建工具，它是用来帮助我们构建app的，构建包括编译、打包等过程。我们可以为Gradle指定构建规则，然后它就会根据我们的“命令”自动为我们构建app。Studio中默认就使用Gradle来完成应用的构建。在创建工程时，Studio自动帮我们生成了一些通用构建规则，很多时候我们甚至完全不用修改这些规则就能完成我们app的构建。 有些时候，我们会有一些个性化的构建需求，比如我们引入了第三方库，或者我们想要在通用构建过程中做一些其他的事情，这时我们就要自己在系统默认构建规则上做一些修改。这时候我们就要自己向Gradle”下命令“了，这时候我们就需要用Gradle能听懂的话了，也就是Groovy。Groovy是一种基于JVM的动态语言，关于它的具体介绍，感兴趣的同学可以文末参考”延伸阅读“部分给出的链接。 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:1:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"依赖坐标 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:2:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"什么是依赖坐标 依赖坐标的概念来源于Maven，俗称 gav：指的是使用下面三个向量子仓库中唯一定位一个 Maven 工程。 groupid:公司或组织域名倒序 com.ys.maven artifactid:模块名，也是实际项目的名称 Maven_05 version:当前项目的版本 0.0.1-SNAPSHOT ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:2:1","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"如何获取依赖坐标 https://mvnrepository.com/ 在mvnrepository官网查询 单击版本号，可以看到它的坐标信息： 各种提示： 比如我现在要调用百度公司的API，示例代码提示我要引用百度的依赖： 那么就获取了坐标信息。 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:2:2","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"在鸿蒙应用中引用依赖 注意\r\r虽然我们在坐标依赖部分一直在说Maven，但是在DevEco Studio中使用的还是gradle，这点要分清楚。\r\r 打开entry \u003e build.gradle： 在dependencies一栏添加如下语句：implementation ('依赖坐标1','依赖坐标2','依赖坐标3') 依赖坐标 = groupid:artifactid:version 例如： dependencies { implementation fileTree(dir: 'libs', include: ['*.jar', '*.har']) testImplementation 'junit:junit:4.13.1' ohosTestImplementation 'com.huawei.ohos.testkit:runner:2.0.0.200' implementation ('com.google.code.gson:gson:2.8.8','com.baidubce:api-explorer-sdk:1.0.3.1') } 打开gradle页面，刷新。 左侧工程目录能看到加入的依赖 由此，在工程中能够正常使用外部依赖。 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:3:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:4:0","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["HarmonyOS"],"content":"参考文献 十分钟理解Gradle https://mvnrepository.com/ Maven详解（五）—— 坐标的概念以及依赖管理 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 ","date":"2022-02-12","objectID":"/harmonyos_outerdependency/:4:1","tags":["HarmonyOS","Java","gradle","Maven"],"title":"鸿蒙开发笔记——引入外部依赖","uri":"/harmonyos_outerdependency/"},{"categories":["Electronic Design"],"content":"模拟开关 模拟开关，英文名Analog switches；主要是完成信号链路中的信号切换功能。采用MOS管的开关方式实现了对信号链路关断或者打开；由于其功能类似于开关，而用模拟器件的特性实现，成为模拟开关。 ","date":"2022-02-09","objectID":"/analogue_switch/:0:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"什么时候用继电器 继电器利用了电生磁原理，通电时电磁铁吸附开关使开关断开，常常应用于电子设计中作为电控开关。模拟开关是集成电路芯片，体积小、寿命高，而且能够实现较为复杂的功能，比如单刀双掷、单刀四掷、四开关集成等等。所以常见场景下还是模拟开关最为适合。 但是，集成电路芯片就决定了它有限制使用条件，信号电压、电流、频率均有一些限制，在大功率、高频场景下，可能模拟开关无法胜任，就需要使用继电器。 ","date":"2022-02-09","objectID":"/analogue_switch/:1:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"四双向模拟开关CD4066 CD4066 的引脚功能如图所示。每个封装内部有 4 个独立的模拟开关，每个模拟开关 有输入、输出、控制三个端子，其中输入端和输出端可互换。当控制端加高电平时，开关导通；当控制端加低电平时开关截止。模拟开关导通时，导通电阻为几十欧姆；模拟开关截止时，呈现很高的阻抗，可以看成为开路。模拟开关可传输数字信号和模拟信号，可传输的模拟信号的上限频率为 40MHz。各开关间的串扰很小，典型值为－50dB。 当模拟开关的电源电压采用双电源时，例如 =﹢5V， =﹣5V(均对地0V而言)，则输入电压对称于0V的正、负信号电压(﹢5V～﹣5V)均能传输。这时要求控制信号C=“1”为+5V，C=“0”为-5V，否则只能传输正极性的信号电压。 ","date":"2022-02-09","objectID":"/analogue_switch/:2:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"单八路模拟开关CD4051 CD4051 的引脚功能如图所示。CD4051 相当于一个单刀八掷开关，开关接通哪一通道，由输入的 3 位地址码 ABC 来决定。 真值表： ","date":"2022-02-09","objectID":"/analogue_switch/:3:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"同系列器件 ","date":"2022-02-09","objectID":"/analogue_switch/:4:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"双四路模拟开关CD4052 ","date":"2022-02-09","objectID":"/analogue_switch/:4:1","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"三组二路模拟开关 CD4053 ","date":"2022-02-09","objectID":"/analogue_switch/:4:2","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"十六路模拟开关 CD4067——单刀十六掷 ","date":"2022-02-09","objectID":"/analogue_switch/:4:3","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"结束语 ","date":"2022-02-09","objectID":"/analogue_switch/:5:0","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"参考文献 https://www.chip37.com/scp/CD4066 http://www.elecfans.com/dianzichangshi/20171209598886_a.html ","date":"2022-02-09","objectID":"/analogue_switch/:5:1","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["Electronic Design"],"content":"datasheet https://github.com/leeshy-tech/Electronic-Design/tree/main/analog_switches ","date":"2022-02-09","objectID":"/analogue_switch/:5:2","tags":["analog switch"],"title":"模拟开关——CD4066、CD4051","uri":"/analogue_switch/"},{"categories":["HarmonyOS"],"content":"Ability HarmonyOS文档\r\rAbility是应用所具备能力的抽象，也是应用程序的重要组成部分。一个应用可以具备多种能力，HarmonyOS支持应用以Ability为单位进行部署。Ability可以分为FA（Feature Ability）和PA（Particle Ability）两种类型，每种类型为开发者提供了不同的模板，以便实现不同的业务功能。\r\r 总的来说，Ability是功能相似的内容的集合，这种划分便于应用的编程组织，FA提供与用户交互的能力，只包含PageAbility，PA没有可视化界面，包括ServiceAbility和DataAbility。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:0:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"配置 一个应用中所有的Ability必须在config.json中注册。 如果通过新建Ability来创建Ability，Studio会自动注册，不需要手动更改config.json。 但如果通过新建Java类来创建，则需要在config.json添加相关的配置信息。 同样，当删除Ability时，需要删除config.json中对应的配置信息，否则会出现一些问题。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:1:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"生命周期 PageAbility和ServiceAbility具有复杂的生命周期，创建、隐藏到后台、从后台呼出等等都会执行相关的生命周期函数，其中onStart方法最常用，当Ability创建时调用onStart方法，所以UI的绑定、按钮事件响应器等等都需要在onStart方法中实现。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:2:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"Intent HarmonyOS文档\r\rIntent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。\r\r Intent是页面跳转及传参的关键，他包括Operation与Parameters两个属性，不传参时只需要构造默认intent，例如下： btn1.setClickedListener(component -\u003e { Intent intent = new Intent(); this.present(new SecondAbilitySlice(),intent); }); 参数通过Parameters来传递： btn1.setClickedListener(component -\u003e { Intent intent1 = new Intent(); intent1.setParam(\"productId\",\"101\"); this.present(new SecondAbilitySlice(),intent1); }); 通过设置Operation可以启动任意设备的任意应用的任意Ability： Intent intent = new Intent(); // 通过Intent中的OperationBuilder类构造operation对象，指定设备标识（空串表示当前设备）、应用包名、Ability名称 Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.demoapp\") .withAbilityName(\"com.demoapp.FooAbility\") .build(); // 把operation设置到intent中 intent.setOperation(operation); startAbility(intent); ","date":"2022-02-08","objectID":"/harmonyos_ability/:3:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"PageAbility 一个PageAbility可以包含任意个AbilitySlice，默认展示的AbilitySlice是通过**setMainRoute()**方法来指定的。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:4:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"AbilitySlice AbilitySlice相当于一个页面，其显示的内容是通过组件来声明的，其组件加载⽀持两种⽅式： Java代码 xml布局文件 在其onStart方法中通过 setUIContext 来加载视图组件，它有两个重载： setUIContext(int) : 通过布局⽂件的ID，加载resources/base/layout⽬录下的布局⽂件完成⻚⾯的渲染。 setUIContext(ComponentContainer) :通过加载⼀个使⽤Java代码创建的组件完成⻚⾯的渲染 。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:4:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"ServiceAbility HarmonyOS文档\r\r基于Service模板的Ability（以下简称“Service”）主要用于后台运行任务（如执行音乐播放、文件下载等），但不提供用户交互界面。Service可由其他应用或Ability启动，即使用户切换到其他应用，Service仍将在后台继续运行。\r\r ","date":"2022-02-08","objectID":"/harmonyos_ability/:5:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"前台Service 一般情况下，Service都是在后台运行的，后台Service的优先级都是比较低的，当资源不足时，系统有可能回收正在运行的后台Service。 在一些场景下（如播放音乐），用户希望应用能够一直保持运行，此时就需要使用前台Service。前台Service会始终保持正在运行的图标在系统状态栏显示。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:5:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"DataAbility HarmonyOS文档\r\r使用Data模板的Ability（以下简称“Data”）有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。Data既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。 数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。Data对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供 \r\r ","date":"2022-02-08","objectID":"/harmonyos_ability/:6:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"URI URI用来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。格式如下： scheme：协议方案名，固定为“dataability”，代表Data Ability所使用的协议类型。 authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。 path：资源的路径信息，代表特定资源的位置信息。 query：查询参数。 fragment：可以用于指示要访问的子资源。 URI示例： 跨设备场景：dataability://device_id/com.domainname.dataability.persondata/person/10 本地设备：dataability:///com.domainname.dataability.persondata/person/10 ","date":"2022-02-08","objectID":"/harmonyos_ability/:6:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"数据操作 DataAbility可以对文件或数据库进行数据操纵，不同类型数据管理方式写法都不一样，详见文档的数据管理一栏： ","date":"2022-02-08","objectID":"/harmonyos_ability/:6:2","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"实践工程 页面导航 ServiceAbility 电话簿 ","date":"2022-02-08","objectID":"/harmonyos_ability/:7:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"结束语 本文仅是对官方文档做一个简单的总结+个人理解，详细的内容还需参考官方文档。 ","date":"2022-02-08","objectID":"/harmonyos_ability/:8:0","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS——文档 ","date":"2022-02-08","objectID":"/harmonyos_ability/:8:1","tags":["HarmonyOS"],"title":"鸿蒙开发笔记——Ability","uri":"/harmonyos_ability/"},{"categories":["HarmonyOS"],"content":"电话簿 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"项目结构 ├─ entry.src.main\r├─ com.example.address_book\r├─slice\r├─ UserAddSlice\r├─ UserListSlice\r└─ MainAbilitySlice\r├─ DataBaseAbility ├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r├─ ability_main.xml\r├─ user_add.xml\r└─ user_list.xml\r","date":"2022-02-08","objectID":"/harmonyos_addressbook/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"效果 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"数据库结构 数据库UserStore：本地、关系型 表users 属性userId：int、主键、自增 属性userName：text、不为空 属性userTel：text、唯一 属性userAddr：text ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"MainAbilitySlice 核心代码： MainAbilitySlice的onStart方法： Button btn1 = (Button) findComponentById(ResourceTable.Id_btn1); btn1.setClickedListener(listener-\u003epresent(new UserAddSlice(),new Intent())); Button btn2 = (Button) findComponentById(ResourceTable.Id_btn2); btn2.setClickedListener(listener-\u003epresent(new UserListSlice(),new Intent())); 执行简单的页面跳转。 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"DataBaseAbility 核心代码： DataBaseAbility类： private RdbStore rdbStore; private StoreConfig config = StoreConfig.newDefaultConfig(\"UserStore.db\"); RdbStore对象：表示与数据库的连接，通过此对象可以完成对数据表中数据的CRUD操作 StoreConfig对象：关联数据⽂件配置(数据库) private RdbOpenCallback callback = new RdbOpenCallback() { @Override public void onCreate(RdbStore rdbStore) { //使⽤rdbStore对象执⾏SQL创建数据表 rdbStore.executeSql(\"create table if not exists users(\" + \"userId integer primary key autoincrement,\" + \"userName text not null,\" + \"userTel text not null unique,\" + \"userAddr text)\"); } }; RdbOpenCallback.onCreate()：数据库创建时被回调，初始化，创建数据表users（当其不存在时）。 DataBaseAbility类的onStart方法： @Override public void onStart(Intent intent) { super.onStart(intent); HiLog.info(LABEL_LOG, \"DataBaseAbility onStart\"); //初始化与数据库的连接 DatabaseHelper helper = new DatabaseHelper(this); rdbStore = helper.getRdbStore(config,1,callback); } 重写insert方法： public int insert(Uri uri, ValuesBucket value) { int i = -1; String path = uri.getLastPath(); if(\"users\".equalsIgnoreCase(path)){ i = (int)rdbStore.insert(\"users\",value); } return i; } 重写query、delete、update方法： public ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) { RdbPredicates rdbPredicates = DataAbilityUtils.createRdbPredicates(predicates, \"users\"); ResultSet resultSet = rdbStore.query(rdbPredicates, columns); return resultSet; } public int delete(Uri uri, DataAbilityPredicates predicates) { RdbPredicates rdbPredicates = DataAbilityUtils.createRdbPredicates(predicates, \"users\"); int i = rdbStore.delete(rdbPredicates); return i; } public int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) { RdbPredicates rdbPredicates = DataAbilityUtils.createRdbPredicates(predicates, \"users\"); int i = rdbStore.update(value, rdbPredicates); return i; } ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"UserAddSlice 核心代码： public class UserAddSlice extends AbilitySlice { private DataAbilityHelper dataAbilityHelper; @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_user_add); dataAbilityHelper = DataAbilityHelper.creator(this); //获取组件对象 Button btn_add = (Button) findComponentById(ResourceTable.Id_btn_add); TextField tf1 = (TextField) findComponentById(ResourceTable.Id_textField1); TextField tf2 = (TextField) findComponentById(ResourceTable.Id_textField2); TextField tf3 = (TextField) findComponentById(ResourceTable.Id_textField3); //绑定事件监听器 btn_add.setClickedListener(component -\u003e { String userName = tf1.getText(); String userTel = tf2.getText(); String userAddr = tf3.getText(); //构造VB ValuesBucket valuesBucket = new ValuesBucket(); valuesBucket.putString(\"userName\",userName); valuesBucket.putString(\"userTel\",userTel); valuesBucket.putString(\"userAddr\",userAddr); //插入数据 try{ Uri uri = Uri.parse(\"dataability:///com.example.address_book.DataBaseAbility/users\"); int i = dataAbilityHelper.insert(uri,valuesBucket); System.out.println(\"------------\u003e\u003e\u003e\u003e\u003e\u003e\"+i); }catch (DataAbilityRemoteException e){ e.printStackTrace(); } }); } } 数据库的相关操作要依靠dataAbilityHelper。 从TextField组件中获取输入的信息。 设置监听器，将获得的信息插入数据表。 插入数据通过ValuesBucket储存，指数据表的一行。 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"UserListSlice 核心代码： public class UserListSlice extends AbilitySlice { private DataAbilityHelper dataAbilityHelper; @Override protected void onStart(Intent intent) { super.onStart(intent); this.setUIContent(ResourceTable.Layout_user_list); Text text = (Text) findComponentById(ResourceTable.Id_infoText); text.setText(\"\"); dataAbilityHelper = DataAbilityHelper.creator(this); //查询所有联系⼈信息 Uri uri = Uri.parse(\"dataability:///com.example.address_book.DataBaseAbility/users\"); String[] colums = {\"userId\",\"userName\",\"userTel\",\"userAddr\"}; DataAbilityPredicates dataAbilityPredicates = new DataAbilityPredicates(); try { ResultSet rs = dataAbilityHelper.query(uri,colums,dataAbilityPredicates); //从rs中获取查询结果 int rowCount = rs.getRowCount(); if(rowCount\u003e0){ rs.goToFirstRow(); do{ int userId = rs.getInt( 0); String userName = rs.getString(1); String userTel = rs.getString(2); String userAddr = rs.getString(3); String info = \" [\"+userId+\",\"+userName+\",\"+userTel+\",\"+userAddr+\"]\"; text.setText( text.getText()+info ); }while(rs.goToNextRow()); } } catch (DataAbilityRemoteException e) { e.printStackTrace(); } } } 通过调用查询接口来查询。 ResultSet为查询结果集，类似于指针，指向结果的第一行。 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:7:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"项目源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/address_book ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:7:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS文档——关系型数据库 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 ","date":"2022-02-08","objectID":"/harmonyos_addressbook/:7:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——电话簿","uri":"/harmonyos_addressbook/"},{"categories":["HarmonyOS"],"content":"ServiceAbility实践 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"项目结构 ├─ entry.src.main\r├─ com.example.serviceability\r├─slice\r└─ MainAbilitySlice\r├─ MainAbility ├─ MyService\r└─ MyApplication\r├─ resources.base.layout\r└─ ability_main.xml\r└─ config.json\r","date":"2022-01-29","objectID":"/harmonyos_serviceability/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"效果 按钮1开启MyService。 按钮2连接到MyService。 按钮3断开与MyService的连接。 按钮4关闭MyService。 服务运行时会在状态栏显示。 不同的点击顺序，命令行输出的提示信息不同。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"铺垫 在MyService里的每个生命周期函数里都加一句sout来显示各个方法执行的顺序。 public class MyService extends Ability { private static final HiLogLabel LABEL_LOG = new HiLogLabel(3, 0xD001100, \"Demo\"); //在每个生命周期函数内加一句sout调试 @Override public void onStart(Intent intent) { super.onStart(intent); HiLog.error(LABEL_LOG, \"MyService::onStart\"); System.out.println(\"--------------------onStart\"); } @Override public void onBackground() { super.onBackground(); HiLog.info(LABEL_LOG, \"MyService::onBackground\"); System.out.println(\"--------------------onBackground\"); } @Override public void onStop() { super.onStop(); HiLog.info(LABEL_LOG, \"MyService::onStop\"); System.out.println(\"--------------------onStop\"); } @Override public void onCommand(Intent intent, boolean restart, int startId) { System.out.println(\"--------------------onCommand\"); } @Override public IRemoteObject onConnect(Intent intent) { System.out.println(\"--------------------onConnect\"); return new LocalRemoteObject() {}; } @Override public void onDisconnect(Intent intent) { System.out.println(\"--------------------onDisconnect\"); } } ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"开启和关闭ServiceAbility 此部分和”页面导航“里开启Ability的操作如出一辙，也就是说，我们只是在开启和关闭Ability，至于它是什么类型，无所谓。 核心代码： ​ MainAbilitySlice的onStart方法： //按钮1开启MyService Button btn1 = (Button) findComponentById(ResourceTable.Id_btn1); btn1.setClickedListener(component -\u003e { Intent intent1 = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.example.serviceability\") .withAbilityName(\"com.example.serviceability.MyService\") .build(); intent1.setOperation(operation); this.startAbility(intent1); }); //按钮4关闭MyService Button btn4 = (Button) findComponentById(ResourceTable.Id_btn4); btn4.setClickedListener(component -\u003e { Intent intent3 = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.example.serviceability\") .withAbilityName(\"com.example.serviceability.MyService\") .build(); intent3.setOperation(operation); this.stopAbility(intent3); }); 通过id获取Button对象，设置事件监听器。 调用startAbility和stopAbility方法，在intent对象的Operation属性里指定开启哪台设备的哪个应用的哪个Ability。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"建立连接 核心代码： ​ MainAbilitySlice的onStart方法： //按钮2连接到MyService Button btn2 = (Button) findComponentById(ResourceTable.Id_btn2); IAbilityConnection connection = new IAbilityConnection() { @Override public void onAbilityConnectDone(ElementName elementName, IRemoteObject iRemoteObject, int i) { System.out.println(\"----------------------连接MyService成功\"); } @Override public void onAbilityDisconnectDone(ElementName elementName, int i) { System.out.println(\"----------------------连接MyService失败\"); } }; btn2.setClickedListener(component -\u003e { Intent intent2 = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") .withBundleName(\"com.example.serviceability\") .withAbilityName(\"com.example.serviceability.MyService\") .build(); intent2.setOperation(operation); this.connectAbility(intent2,connection); }); 通过id获取Button对象，设置事件监听器。 新建连接对象，重写onAbilityConnectDone和onAbilityDisconnectDone方法，每个方法里都写一句sout用于调试。 onAbilityConnectDone：连接成功建立后执行。 onAbilityDisconnectDone：连接建立失败后执行。 调用connectAbility方法，传递intent和connect对象。 ​ MyService： @Override public IRemoteObject onConnect(Intent intent) { System.out.println(\"--------------------onConnect\"); return new LocalRemoteObject() {}; } 注意返回语句，返回一个LocalRemoteObject对象。 试图与Service建立连接时，触发onConnect方法，它返回一个LocalRemoteObject对象，在这个实例中它返回的是MyService这个Ability，触发回调函数onAbilityConnectDone或者onAbilityDisconnectDone。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"关闭连接 核心代码： MainAbilitySlice的onStart方法： //按钮3断开与MyService的连接 Button btn3 = (Button) findComponentById(ResourceTable.Id_btn3); btn3.setClickedListener(component -\u003e { if(connection != null){ this.disconnectAbility(connection); } }); 若connection对象存在，就调用disconnectAbility方法即可。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"前台Service 前台Service会始终保持正在运行的图标在系统状态栏显示。 核心代码： MyService的onStart方法： // 创建通知，其中1005为notificationId NotificationRequest request = new NotificationRequest(1005); NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent(); content.setTitle(\"title\").setText(\"text\"); NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content); request.setContent(notificationContent); // 绑定通知，1005为创建通知时传入的notificationId keepBackgroundRunning(1005, request); 这段进行一个简单的Ctrl+C、V就行，注意以下几个点： 1005这个notificationId不能与其他的服务重复 title和text在图中对应： config.json中还要申请常驻后台权限： \"reqPermissions\": [ {\"name\": \"ohos.permission.KEEP_BACKGROUND_RUNNING\"} ] 位置如图所示： ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"生命周期分析 整个执行过程如图所示： 启动： 若MyService已建立，执行onCommand。 若未建立，执行onStart和onCommand。 连接： 若MyService已建立，则执行onConnect。 若未建立，则执行onStart和onConnect（红字忽略）。 断开连接：当连接存在，且 MyService是手动创建的，不是由连接唤起的，只执行onDisconnect MyService是由该连接唤起的，执行onDisconnect、onBackground、onStop。 关闭：当MyService没有被连接时，才能关闭，执行onBackground和onStop。 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:7:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:8:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"项目源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/ServiceAbility ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:8:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 HarmonyOS文档——ServiceAbility ","date":"2022-01-29","objectID":"/harmonyos_serviceability/:8:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——ServiceAbility","uri":"/harmonyos_serviceability/"},{"categories":["HarmonyOS"],"content":"页面导航 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:0:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"项目简介 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:1:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"项目结构 ├─ entry.src.main\r├─ com.example.page_to_page\r├─slice\r├─ AnotherAbilitySlice\r├─ MainAbilitySlice\r└─ SecondAbilitySlice\r├─ AnotherAbility ├─ MainAbility\r└─ MyApplication\r└─ resources.base.layout\r├─ ability_another.xml\r├─ ability_main.xml\r└─ ability_second.xml\r","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:1:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"效果 点击按钮一，从MainAbilitySlice跳转到SecondAbilitySlice。 点击按钮二，从MainAbilitySlice跳转到SecondAbilitySlice，并传递参数字符串。 点击按钮三，从MainAbility的MainAbilitySlice跳转到AnotherAbility的AnotherAbilitySlice。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:1:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"intent HarmonyOS文档——intent intent是对象之间传递信息的载体，Slice之间的导航、传参以及Ability之间的导航都是基于intent。Intent的构成元素包括Operation与Parameters。Operation是执行的操作，Parameters则是携带的参数。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:2:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"Slice间导航 核心代码： MainAbilitySlice的onStart方法： Button btn1 = (Button) findComponentById(ResourceTable.Id_btn1); btn1.setClickedListener(listener-\u003epresent(new SecondAbilitySlice(),new Intent())); 通过id获取按钮对象。 给按钮绑定事件监听器，执行present方法。 这里只是导航，没有其他操作，所以传递一个默认intent即可。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:3:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"Slice间传参 核心代码： Button btn2 = (Button) findComponentById(ResourceTable.Id_btn2); btn2.setClickedListener(listener -\u003e { Intent intent1 = new Intent(); intent1.setParam(\"my_string\",\"从MainAbilitySlice传参\"); this.present(new SecondAbilitySlice(),intent1); }); 跟导航部分思路相同。 传参的关键是构造intent对象的Parameters属性，使用setParam方法存储键值对。setParam方法有很多重载，包括int，string等等，但是没有对象类型，也就是传参不能传对象。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:4:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"PageAbility间导航 核心代码： MainAbilitySlice类的onStart方法： Button btn3 = (Button) findComponentById(ResourceTable.Id_btn3); btn3.setClickedListener(listener -\u003e navigateToAnotherPage(listener)); 设置监听器的逻辑相同，不过这次我们让监听器执行我们的自定义函数navigateToAnotherPage。 MainAbilitySlice类新增: private void navigateToAnotherPage(Component component){ Intent intent = new Intent(); Operation operation = new Intent.OperationBuilder() .withDeviceId(\"\") //空字符串为本机 .withBundleName(\"com.example.page_to_page\")//本应用的标识 .withAbilityName(\"com.example.page_to_page.AnotherAbility\")//想启动的Ability .build(); intent.setOperation(operation); this.startAbility(intent); } 使用OperationBuilder构建一个Operation，设置给intent。 将intent传给监听器 页面跳转的核心是intent对象的Operation属性，这里构建Operation有三个参数DeviceId、BundleName、AbilityName，因为鸿蒙可以启动任意设备的任意应用的任意Ability，可能这就是万物互联吧。 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:5:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:6:0","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"项目源码 https://github.com/leeshy-tech/HarmonyOS_example/tree/main/page_to_page ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:6:1","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"参考文献 HarmonyOS 2.0应用开发实战教程丨锋迷商城项目 HarmonyOS文档——intent ","date":"2022-01-28","objectID":"/harmonyos_pagetopage/:6:2","tags":["HarmonyOS","Java","APP"],"title":"鸿蒙开发实践——页面导航","uri":"/harmonyos_pagetopage/"},{"categories":["HarmonyOS"],"content":"DevEco Studio HUAWEI DevEco Studio（获取工具请点击链接下载，以下简称DevEco Studio）是基于IntelliJ IDEA Community开源版本打造，面向华为终端全场景多设备的一站式集成开发环境（IDE），为开发者提供工程模板创建、开发、编译、调试、发布等E2E的HarmonyOS应用/服务开发 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:0:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"配置 DevEco是基于IDEA打造的，所以二者非常相似，有些配置不会的话可以直接google IDEA的相关配置。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"界面风格 将界面风格改为暗黑模式 打开设置：file\u003esettings Appearance \u0026 Behavior \u003e Appearance Theme：改为Darcula，点击OK。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:1","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"字体 打开设置：file\u003esettings Editor \u003e Font Font：字体风格，我个人比较喜欢Inconsolata ; Size：字号 ; Line height：行距 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:2","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"注释颜色 初始的注释颜色非常浅，还是灰色，所以想调成亮一点的绿色。 打开设置：file\u003esettings Editor \u003e Color Scheme \u003e Language Default 点开Comments，其中Block comment是块注释，Line comment是行注释，尽量二者颜色统一吧，颜色栏是可以复制的。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:3","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"输入联想——大小写不敏感 初始的输入联想是大小写敏感的，Str才能补全成String，设置大小写不敏感，使str也能补全成String。 打开设置：file\u003esettings Editor \u003e General \u003e Code Completion 去掉右侧Match case的勾 效果如下： ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:4","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"自动引包优化 打开设置：file\u003esettings Editor \u003e General \u003e Auto import 在右侧勾上如图的两句话。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:5","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"汉化 编辑器设中文其实意义不大，汉化部分很少，都是一些基础的单词，但是我看到中文有一种莫名的安心感，所以还是汉化了。 打开设置：file\u003esettings Plugins 搜索chinese，在installed里找到Chinese (Simplified) ，点击enable。 注意你会在Marketplace里找到Chinese (Simplified) Language Pack，它是IDEA的插件，适配效果没有内置的好。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:6","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"拼写检查 拼写检查默认开启，有时会提示一些莫名其妙的单词，非常难受，所以将其关掉。 打开设置：file\u003esettings Editor \u003e Inspections \u003e Spelling 将右侧的勾取消。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:7","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"同时打开多项目 默认情况下只能打开一个项目窗口，新的项目会覆盖之前打开的项目，如果要参考其他项目的代码就比较困难。 打开设置：file\u003esettings Appearance \u0026 Behavior \u003e System Settings 选择Open project in new window ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:1:8","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"项目结构 坑，待填。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:2:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"调试方法 鸿蒙项目有两种调试方式：previewer和在设备运行 Previewer previewer本质上是个页面预览器，预览的页面是工作区前台的Page。位置在： 在设备运行 设备有很多种，本地模拟器、远程模拟器、远程真机等等（细节可以看官方文档），都是将整个项目完整的打包成应用在设备上运行。推荐使用远程模拟器，因为本地模拟器会占用相当大一部分的本机资源。在右上角打开设备管理器即可进行管理。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:3:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"选择调试方式 设备：不管是远程还是本地，使用上都会有一定的卡顿，并且项目具有默认显示页面，调试非默认页面时，需要保证跳转逻辑等等无误。 预览器：工作区打开什么文件就默认预览什么文件，不需要考虑其他页面或者Ability的逻辑，但是，预览器是高度阉割的，某些逻辑不能很好的在预览器运行，比如我昨天遇到一个报错`[ClassCastException: java.lang.Object cannot be cast to java.lang.String，在预览器中运行就会报这个错误无法启动预览器，但是在设备中运行就正常。所以要灵活选择调试方式。当然，不提供页面服务的Ability的肯定要在设备上测试。 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:3:1","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"结束语 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:4:0","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["HarmonyOS"],"content":"参考文献 ","date":"2022-01-28","objectID":"/harmonyos_studioconfig/:4:1","tags":["HarmonyOS","DevEco Studio"],"title":"鸿蒙开发笔记——开发工具DevEco Studio","uri":"/harmonyos_studioconfig/"},{"categories":["Code error"],"content":"1 Bug\r\r不可转换的类型；无法将 ‘ohos.agp.components.Component’ 转换为 ‘ohos.ai.cv.text.Text’\r\r 原因：使用Tab键补全Text时，Studio自动引库引到了错误的库import ohos.ai.cv.text.Text;，实际应当是import ohos.agp.components.Text;。 ","date":"2022-01-27","objectID":"/harmonyos_application_error/:0:1","tags":["HarmonyOS","Java"],"title":"程序报错总结——HarmonyOS","uri":"/harmonyos_application_error/"},{"categories":["Code error"],"content":"2 Bug\r\rjava.lang.NullPointerException: Attempt to invoke virtual method ‘void ohos.agp.components.Button.setClickedListener(ohos.agp.components.Component$ClickedListener)’ on a null object reference\r\r 原因：在写xml文件时，误把注释写成了//，应该是\u003c!-- --\u003e。这里它不会直接报错，而是说我获得的按键对象为空，说明xml构建出了问题。 ","date":"2022-01-27","objectID":"/harmonyos_application_error/:0:2","tags":["HarmonyOS","Java"],"title":"程序报错总结——HarmonyOS","uri":"/harmonyos_application_error/"},{"categories":["Code error"],"content":"3 Bug\r\rohos.agp.window.wmc.AGPWindowManager$O000000: Can’t show toast, Looper.don’t prepare\r\r 原因：一般是因为在子线程中直接操作UI导致的，这个主要是指导致UI重绘的操作，指上图中的.show()，.setText()是可以在子线程中正常使用的。 解决办法：利用getUITaskDispatcher把UI操作返回到主线程中。 ","date":"2022-01-27","objectID":"/harmonyos_application_error/:0:3","tags":["HarmonyOS","Java"],"title":"程序报错总结——HarmonyOS","uri":"/harmonyos_application_error/"},{"categories":["Paper"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/6461198 IEEE Communications Magazine Volume 51 Issue 2 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:1:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"摘要 在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是SDN所独有的。我们探讨了在不同环境中经常出现的问题，讨论了SDN设计空间中可扩展性的权衡，并介绍了一些关于SDN可扩展性的最新研究。此外，我们还列举了在可扩展性方面的重要机遇和挑战。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:2:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"引言 普遍认为SDN中的控制是集中的，这导致了对SDN可伸缩性和弹性的关注。毕竟，无论控制器的能力如何，中央控制器都不会随着网络的增长而扩展(增加交换机、流量、带宽等的数量)，并且在提供相同的服务保证的同时也无法处理所有传入的请求。此外，由于大多数早期的SDN提议都是基于流的，额外的流启动延迟成为一个问题。 我们认为SDN的可扩展性没有固有的瓶颈;我们认为这些可扩展性限制并不局限于SDN;传统的控制协议设计也面临着同样的挑战。虽然这并没有解决这些问题，但这表明我们在SDN中不需要比在传统网络中更担心可扩展性。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:3:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"SDN中可扩展性的根源 SDN与传统数据网络的根本区别在于控制与转发平面的分离。这种解耦导致了一些有趣的特性。 然而，这种解耦也有它自己的陷阱。在这两个平面之间定义一个标准的API是绝对重要的。从技术上讲，这个API应该能够处理各种体系结构的需求，并且应该能够促进这两个平面的独立演化。此外，所有或大多数交换机供应商应该采用相同的标准API，以使其有用；否则，网络将与特定的供应商绑定，会阻碍网络的快速变化和创新。将传统的本地控制功能移动到远程控制器可能会导致新的瓶颈。它还可能导致信令开销。 在接下来的内容中，我们首先讨论SDN控制器的可扩展性，概述为什么它一直受到关注，以及最近在这个领域的工作。然后，我们回顾一些其他经常提到的SDN可扩展性问题，包括流程设置开销和故障恢复能力。我们认为，尽管这些问题不是SDN特有的，但它们可以通过另一种设计来缓解(其中一些设计现在很常见)。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:4:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"控制器可扩展性 一种可能的SDN设计是将所有的控制功能推到一个集中式控制器上。控制器有可能成为网络操作中的瓶颈，随着网络规模的增长，更多的事件和请求会被发送到控制器，并且在某个时刻，控制器无法处理所有传入的请求。缓解这种担忧的一种方法是在多核系统中提高并行性，并提高IO性能。第二种方法是减少转发到控制器的请求数量，比如DevoFlow通过底层网络约束，牺牲细粒度流级可见性（ fine-grained flow-level visibility）换来了可扩展性。 或者，还可以将控制功能的状态和/或计算分配到多个控制器上。提供一个严格一致的集中视图可能会阻碍响应时间和吞吐量。在保持可用性和分区容差的同时实现强一致性并不总是可行的。因此，选择一个合适的一致性水平是SDN中一个重要的设计权衡。 有一些解决方案，我们可以物理地分布控制平面元素，同时保持网络范围的视图。例如，Onix就是一个分布式控制平台，它促进了分布式控制平面的实现。它为控制应用程序提供了一组通用api，以方便访问分布在Onix实例上的网络状态(NIB)。另一方面，HyperFlow在多个控制器实例之间同步网络状态，使控制应用程序(在每个控制器实例上运行)产生控制整个网络的错觉。这保持了在中央控制器上开发控制平面的简单性，同时减轻了与中央控制器相关的可伸缩性问题，尽管这是针对满足某些特性的一组更受限制的控制应用程序。 Kandoo[9]采用了一种不同的方法来分配控制平面。它定义了一个操作范围，使具有不同要求的应用程序能够共存：本地作用域的应用程序（即，可以使用交换机的本地状态进行操作的应用程序）部署在数据路径附近，以处理频繁的请求并保护控制平面的其他部分免受负载。另一方面，根控制器负责需要网络范围状态的应用程序，同时也充当本地控制器之间需要的任何协调的中介。 一个有趣的观察结果是，SDN中的控制平面可扩展性挑战（例如，收敛性和一致性要求）与传统网络设计中所面临的挑战并没有本质上的不同。SDN本身既不太可能消除控制平面设计的复杂性，也不太可能使其或多或少具有可扩展性。 与传统网络不同，在SDN中，我们不需要反复解决基本但具有挑战性的问题，如拓扑发现、状态分布和恢复力。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:5:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"其他SDN可扩展性问题 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:6:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"流启动开销 让我们回顾一下流设置过程来解释瓶颈，并展示一个好的设计如何可以避免它们： 包到达但是没有匹配到流规则 交换机产生一个流请求给控制器 控制器返回一个新的流转发规则 交换机更新流表 前三个步骤和最后一个步骤的性能部分取决于交换机能力和资源(管理CPU、内存等)【？这里为什么要说前三个和最后一个】。以及其软件堆栈的性能。第三步中的延迟是由控制器的资源以及控制程序的性能来决定。最后，交换机的FIB更新时间导致了完成流程设置过程的延迟。 目前支持OpenFlow的软交换机性能远好于硬件交换机，原因是交换机上缺乏资源（管理CPU），对交换机芯片组和管理CPU之间的高频通信的支持不足，以及不佳的软件实现。可以预见，FIB更新时间将成为开关侧流设置延迟的主要因素。 While we argue that controllers and, in the near future, switches would be able to sustain sufficient throughput with negligible latency for reactive flow setup, in the end the control logic determines the scalability of a reactive design. A control program installing an end-to-end path on a per-flow basis does not scale, because the per switch memory is fixed but the number of forwarding entries in the data path grows with the number of active flows in the network. However, the control program may install aggregate rules matching a large number of micro-flows (thereby facing the same scalability challenges as a proactive design), or proactively install rules in the network core to provide end-to-end connectivity and identify quality of service (QoS) classes, while classifying and reactively labeling flows at the edge. A viable solution to the scalability challenges of the proactive designs in the former class due to data path memory scarcity is proposed in DIFANE [5]; while the scalability the latter class follows from the observation that the fanout of an edge switch and thus the number of flows initiated there is bounded (just add edge controllers as the network grows in size). 【没看懂】 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:6:1","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"故障恢复 早期的系统为单中心控制的设计树立了榜样，因此对故障的恢复能力一直是一个主要问题。一个状态同步的从控制器将足以从控制器故障中恢复，但一个网络分区将留下一半的网络无脑。在多控制器网络中，如果有适当的控制器发现机制，交换机总是可以发现一个存在于其分区中的控制器。因此，在一个可伸缩的发现机制下，控制器故障不会对SDN的可伸缩性构成挑战。 响应于链路失效的收敛有五个步骤。交换机检测到变化。然后交换机通知控制器。在收到通知后，控制程序计算修复操作，并将更新推到受影响的数据路径元素，这些元素反过来更新它们的转发表。在传统网络中，链路故障通知会在整个网络中泛滥，而在SDN中，该信息直接发送到控制器。因此，SDN网络中的信息传播时延并不比传统网络差。另外，SDN的一个优点是，计算是在更有能力的控制机器上进行的，而不是在所有交换机的弱管理cpu上进行的，无论它们是否受到故障的影响。 请注意，上述参数建立在隐含的假设之上，即故障的交换机或链路不影响交换机-控制器通信信道。如果有一个出现故障的链路或交换机是控制网络本身的一部分，则需要首先修复控制网络本身。因此，在这种角落的情况下，收敛速度可能比传统网络要慢。 总的来说，SDN中的故障恢复过程并不比传统网络中的更差。因此，存在类似的可伸缩性问题，并且在传统网络中用于最小化停机时间的相同技术也适用于SDN。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:6:2","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"不同的网络设置中的可伸缩性 采用一种不同的方法，解释不同类型网络中的可伸缩性模式和陷阱。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:7:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"数据中心 一个典型的数据中心网络有数万个交换元件，并且可以快速增长。在该规模的任何网络中生成的控制事件的绝对数量足以使任何集中式控制器过载。解决这个问题的一种方法是主动在交换机上安装规则，在它们进入控制平面之前有效地消除大多数控制请求。当然，这里的成本是控制器精度和反应性的损失。 当应用程序需要精确的流量统计和/或响应性时，可以将应用程序部署在交换机附近。例如，只要最小化对全局状态的访问，就可以将频繁的事件委托给运行在终端主机上的进程。考虑到整个数据中心网络的处理资源可用性，可以使用像Kandoo[9]这样的解决方案达到任意可伸缩性级别。分布式控制器(如HyperFlow或Onix)也可以是数据中心网络的合理解决方案。考虑到这种网络中的低延迟，状态和流设置的同步延迟将是最小的，对于大多数应用程序来说是可以接受的。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:7:1","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"服务提供商网络 通常，服务提供商网络没有数据中心网络那么多的交换机/路由器；然而，这种网络中的节点通常是在地理上分布的。这些网络的大直径加剧了控制器的可伸缩性问题、流设置和状态收敛延迟以及一致性要求。我们可以利用网络的物理分布将其划分为单独的区域；每个分区都可以由一个独立的控制器控制，这些控制器只能交换所需的状态变化事件，有效地向外部控制器隐藏了大部分事件。考虑到这种网络中固有的延迟，所有的控制应用程序都应该是容忍延迟的，并且有较弱的一致性要求。 除了高延迟外，服务提供商网络通常比其他网络有更多的流量。因此，这里也关注数据路径资源限制。流的聚合是一个简单的解决方案，它以控制中的粒度为代价。我们注意到，这些问题也存在于传统的网络中，而这并不是SDN所独有的。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:7:2","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"机遇和挑战 传统上，网络的可伸缩性是基于性能指标来研究的，也就是说，当我们沿着给定的维度扩展网络时，特定的性能指标是如何变化的。在实践中，还有其他正交的方面深刻地影响系统如何适应增长。例如,可管理性(如何方便地管理网络,在大尺度状态下添加,删除,或修改网络元素)和功能可伸缩性(是否方便将新功能添加到网络)与网络可伸缩性、性能一样重要，不应被忽视。关于行为和编程抽象、测试和验证以及SDN可扩展性的初步结果表明，我们认为SDN在这一领域提供了一个重要的机遇。显然，在我们能够充分发挥SDN的潜力之前，我们在这些方面都面临着重大挑战。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"行为和编程抽象 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:1","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"测试和验证 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:2","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"可延展性 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:8:3","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"结论 自SDN引入以来，可伸缩性一直是一个主要问题。目前关于SDN可伸缩性的研究表明： 这些担忧既不是由SDN引起的，也不是由SDN所独有的。 这些问题大多可以得到解决，而不会失去SDN的好处。 在这个领域，通常被忽视的是SDN对网络增长的其他限制因素的影响，如网络规划和管理复杂性。软件定义的网络增加了一种灵活性，可以大规模地适应网络编程和管理。传统的网络在这一领域历来都失败过。最近在这个方向上的尝试非常有希望，尽管未来仍面临许多挑战。 ","date":"2022-01-18","objectID":"/on_scalability_of_sdn_note/:9:0","tags":["SDN","Paper"],"title":"论文笔记——On Scalability of SDN","uri":"/on_scalability_of_sdn_note/"},{"categories":["Paper"],"content":"论文概况 https://ieeexplore.ieee.org/abstract/document/6739370 IEEE Communications Surveys \u0026 Tutorials Volume 16 Issue 3 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:1:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"摘要 本文综述了可编程网络的最新进展，重点介绍了SDN。我们提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:2:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"1 引言 传统网络出现的问题：网络管理和性能调优困难，网络僵化。 可编程网络具有革命性，比如软件定义网络，网络设备成为简单的包转发设备，可以通过开放的接口进行编程。 第二节：早期可编程网络 第三节：SDN及其体系结构，以及OpenFlow协议。 第四节：开发和测试SDN的平台和工具。 第五节：在数据中心和无线网络的应用。 第六节：面临的挑战和未来发展的方向。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:3:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"2 早期可编程网络 描述了一些SDN和OpenFlow概念的前身，在早期的一些项目中已经有了关于可编程网络和数控平面分离的思想。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:4:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"3 SDN体系结构 路由器和交换机通常是封闭的系统，只有很少的提供给供应商的接口。适配新版本的协议（比如Ipv6）非常困难，更不用说部署全新的协议和服务。网络僵化效应主要是由于设备的数据和控制平面紧密耦合，新的app或功能的部署需要直接实现在物理设施中。解决网络僵化的一个手段是使用中间设备，比如CDN（内容交付网络）。 软件定义网络将转发硬件和控制逻辑分离，可以更容易地部署新协议和应用程序。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 当前SDN架构 目前有两种SDN架构：ForCES和OpenFlow ForCES将单个设备中的控制元素与转发元素分开，意图实现在单一网络设备中将转发硬件与第三方控制相结合。它定义了两个逻辑实体，转发元素FE和控制元素CE，它们通过ForCES协议通信，FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能。ForCES还有一个重要功能块LFB（逻辑功能块），它安装在FE上，通过CE进行控制，实现FE的配置和数据包处理。 OpenFlow完全将控制平面从网络设备上剥离，转发设备基于流表进行转发，流表控制着转发规则。没有匹配流表时按照“table-miss”流表项执行相应的动作，比如丢弃、转发给控制器。控制平面与转发平面通过OpenFlow协议进行通信，远程控制器可以添加、删除或更新交换机的流表项。 ForCES和OpenFlow的模型不同，但是可以实现相似的功能。 OpenFlow得到了各界的大力支持，以至于被认为是SDN的官方标准。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 转发设备 底层网络中，转发设备有路由器、交换机、无线接入点等。但是在SDN中，控制逻辑和算法都由控制器维护，基本转发硬件均被称为switches——交换机。 规则空间是OpenFlow可扩展性的瓶颈，在尊重网络策略和约束的同时，优化使用规则空间来服务于一定数量的流条目是一个具有挑战性和重要的课题。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 控制器 单个控制器能够处理惊人数量的新流请求，并且应该能够管理除最大的网络之外的所有网络。 交换机控制延迟对网络的整体行为有重大影响，因为每个交换机在从控制器收到插入流表中适当规则的消息之前不能转发数据。这个间隔可能会随着链路延迟而增加，并显著影响网络应用程序的性能。 控制建模对网络的可扩展性影响很大。 集中式和分布式：软件定义的网络可能具有集中式或分布式的控制平面。OpenFlow允许多个控制器连接到一台交换机上，这将允许备份控制器在出现故障时接管。软件定义的网络还可以具有一定程度的逻辑去中心化，具有多个逻辑控制器。 粒度控制：传统网络的基本元素是包。在软件定义网络中，网络元素是远程控制的，开销是由数据平面和控制平面之间的通信引起的。控制器对每个包做决策会增加额外的延迟，对流的第一个包所做的决策可以应用于该流的所有后续包，通过将流分组可以进一步减少开销。 被动控制和主动控制：这部分没看懂 P1624。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 南向接口：控制器——交换机 OpenFlow本身就是控制器——交换机交互的一种实现。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 北向接口：控制器——服务 目前还没有公认的针对北向交互的标准，而且它们更有可能在特定应用程序的特殊基础上实现。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"F 标准化工作 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:5:6","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"4 SDN开发工具 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 仿真和仿真工具 mininet,NS-3 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 可用软交换机平台 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 实体交换机 目前在商品网络硬件中实现的SDN主要技术是OpenFlow标准。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 可用控制器平台 其中有两个特殊用途的控制器：Flowvisor、RouteFlow Flowvisor：充当交换机和多个控制器之间的透明代理，它能够创建网络片，将每个片的控制委托给不同的控制器，促进了片之间的隔离。 RouteFlow：它由一个OpenFlow控制器应用程序、一个独立的服务器和一个虚拟网络环境组成，它可以复制物理基础设施的连接并运行IP路由引擎。路由引擎根据所配置的路由协议(如OSPF、BGP)，将转发信息库(FIB)生成到LinuxIP表中。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 代码验证和调试 NICE：自动化的测试工具，用于通过模型检查和符号执行来帮助发现OpenFlow程序中的bug。 Anteater：试图检查数据平面中存在的网络不变量，如连通性或一致性。这种方法的主要优点是它与协议无关；它还将捕获由错误的交换机固件或与控制平面通信不一致而导致的错误。 VeriFlow：进一步提出了一个驻留在控制器和转发元素之间的实时验证工具。能够停止在到达网络之前会导致异常行为的规则。 OFRewind：允许以不同的粒度记录网络事件（控制和数据），然后再回放以重现特定的场景，从而提供定位和排除导致网络异常的事件的机会。 ndb：为SDN实现了断点和数据包回溯。 STS：是一个由软件定义的网络故障排除模拟器。它是用python编写的，并且依赖于POX。它模拟了给定网络中的设备，允许进行测试用例，并识别产生给定错误的输入集。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:6:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"5 SDN应用 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 企业网络 校园网也算是特殊的企业网络。适当的管理在企业环境中至关重要，SDN可以通过编程方式执行和调整网络策略，以及帮助监控网络活动和调整网络性能。使用SDN实现的中间设备包括NAT，防火墙，负载平衡器和网络访问控制。对于更复杂的中间设备，直接实现导致性能下降，可以使用SDN提供统一控制和管理。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 数据中心 在大规模数据中心中能源消耗有很重要的成本，ElasticTree是一种电源管理器，利用SDN来寻找满足当前流量条件的最小功率网络的子集。B4是谷歌提出的SDN概念应用于数据中心环境中的实际例子，它是一个连接谷歌全球数据中心的广域网。B4被证明是高效的，而且工作经验表明，控制平面到数据平面通信和硬件编程开销造成的瓶颈是今后工作中需要考虑的重要问题。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 基于基础设施的无线接入网 OpenRoads：设想了一种软件定义蜂窝网络。 Odin：在企业无线局域网环境中引入了可编程性，它在控制器上构建一个访问点抽象，将关联状态与物理访问点分离，实现主动移动管理和负载平衡。 OpenRadio：专注于部署可编程无线数据平面，在PHY和MAC层而不是第三层，提供灵活性，旨在提供一个模块化接口，能够处理使用不同协议的流量子集，基于决策平面和转发平面分离的思想，操作员可以表示由处理平面模块(如FFT模块、维特比解码等)组装而来的决策平面规则和相应的动作。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 光网络 将SDN和OpenFlow标准应用于光传输网络的好处包括：提高光传输网络控制和管理灵活性，支持部署第三方管理和控制系统，以及通过利用虚拟化和SDN部署新的服务。 文献[88]-[93] ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 家庭和小型企业 随着低成本网络设备的广泛可用性，这些环境变得越来越复杂和普遍，对更仔细的网络管理和更严格的安全性的需求也相应地增加了。但是，在每个家庭和办公室都有一个专门的网络管理员是不现实的。 Calvert建议将控制器作为“家庭网络数据记录器”，创建可用于故障排除或其他目的日志。 Feamster建议外包第三方专家，通过远程控制可编程交换机和分布式网络监控和推理算法，来检测可能的安全问题。 文献[94]-[97] ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:7:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"5 研究所面临的挑战和未来的发展方向 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"A 控制器和交换机设计 可扩展性、性能、鲁棒性、安全性 DIFANE：流被主动推到交换机上，试图减少向控制器的请求数量。 Devoflow：建议处理交换机中的短寿命流和控制器中的长寿流，以减少流设置延迟和控制器开销。 [28]：主张用一系列规则匹配记录来替换ASIC上的计数器，并在CPU中处理它们，以允许高效访问计数器。 FLARE：专注于“深度可编程网络”的新型网络节点模型，它为数据平面、控制平面以及它们之间的接口提供了可编程性。 为了提高可扩展性，特别是为了可靠性和鲁棒性，人们已经认识到逻辑集中的控制器必须是物理分布的。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:1","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"B 软件定义互联网 目前许多关于SDN的工作都是在单个管理域的上下文中检查或提出解决方案。然而，那些管理本质上是分散的环境，比如互联网，需要一个逻辑分布的控制平面。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:2","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"C 控制器——服务交互 目前南向接口定义的相当好，但是北向接口却没有统一的标准，一种可能的解释是，北向接口完全是在软件中定义的，而南向接口必须支持硬件实现。 如果我们认为控制器是一个“网络操作系统”，那么应该有一个明确定义的接口，应用程序可以访问底层硬件（交换机），与其他应用程序共存和交互，并利用系统服务（例如拓扑发现、转发），而不需要应用程序开发人员知道控制器的实现细节。 此外，北向的API应该允许应用程序对同一流应用不同的策略(例如，通过目的地进行转发和通过源IP进行监控)。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:3","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"D 虚拟化和云服务 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:4","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"E 以信息为中心的网络 信息中心网络(ICN)是针对未来互联网架构提出的一种新的范式，它旨在提高内容交付的效率和内容可用性。他们的驱动动机是，当前的互联网是信息驱动的，但网络技术仍然专注于基于位置的寻址和主机对主机的通信的想法。通过提出一种处理命名数据而不是命名主机的体系结构，内容分发可以直接实现到网络结构中，而不是依赖于目前用于将内容映射到单个位置的复杂映射、可用性和安全机制。 ICN中信息处理和转发的分离与SDN中数据平面和控制平面的解耦相一致。然后，问题就变成了如何将ICN和SDN结合起来。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:5","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"F 异构网络支持 未来网络面临的一个主要挑战是资源的有效利用；在无线多跳自组网中尤其如此，因为可用的无线容量本质上是有限的。这是由于许多因素，包括共享物理介质的使用、无线信道损坏和受管理基础设施的缺乏。自组织网络缺乏专用资源，而且连接性的变化使容量共享变得困难。底层网络的异构特性（例如，物理介质、拓扑结构、稳定性）和节点（例如，缓冲区大小、功率限制、移动性）在考虑路由和资源分配时也增加了另一个重要的因素。 迄今为止的SDN技术，如OpenFlow，主要针对基于基础设施的网络。它们促进了一种不适合在无基础设施环境中出现的分散、中断和延迟级别的集中控制机制。虽然之前的工作已经研究了SDN在无线环境中的使用，但其范围主要集中在基于基础设施的部署。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:8:6","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"7 结束语 在本文中，我们提供了一个可编程网络的概述，并在此背景下，考察了软件定义网络(SDN)的新兴领域。我们来看看可编程网络的历史，从早期的想法到最近的发展。我们特别详细描述了SDN体系结构以及OpenFlow[2]标准。我们介绍了当前的SDN实现和测试平台，并检查了基于SDN范式开发的网络服务和应用程序。最后，我们讨论了SDN所支持的未来发展方向，从支持异构网络到信息中心网络(ICN)。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:9:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["Paper"],"content":"语句摘录 As a result, network management and performance tuning is quite challenging and thus error-prone. 因此，网络管理和性能调优非常具有挑战性，所以很容易出错。 Because of its huge deployment base and the fact it is considered part of our society’s critical infrastructure (just like transportation and power grids), the Internet has become extremely difficult to evolve both in terms of its physical infrastructure as well as its protocols and performance. 由于其庞大的部署基础，且被视为我们社会关键基础设施(就像交通和电网)的一部分，所以互联网在其物理基础设施、协议和性能方面的发展已经变得极其困难。 As SDN becomes more widely adopted and protocols such as OpenFlow are further defined, new solutions are proposed and new challenges arise. 随着SDN被广泛采用，并且OpenFlow等协议被进一步定义，新的解决方案被提出，新的挑战出现. The Internet has revolutionized the way we, as individuals and as a society, live, work, conduct business, socialize, get entertainment, etc. As a result, the Internet is now considered part of our society’s critical infrastructure much like the power, water, and transportation grids. 互联网已经彻底改变了我们作为个人和社会、生活、工作、做生意、社交、获得娱乐等方面的方式。因此，互联网现在被认为是我们社会关键基础设施的一部分，就像电力、水和交通电网一样。 ","date":"2022-01-11","objectID":"/a_survey_of_sdn_note/:10:0","tags":["SDN","Paper"],"title":"论文笔记——A Survey of SDN","uri":"/a_survey_of_sdn_note/"},{"categories":["SDN"],"content":"自学习交换机 交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。 SDN的自学习交换机跟传统交换机不一样的点有： 帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。 自学习的过程中可能会有流表的变化。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:1:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"ping命令过程 ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。 局域网ping命令的执行过程： 网络模型为：h1 —- s1 —- h2，两台主机连接到同一个交换机。 假设h1 ping h2 首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。 交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。 h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。 h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。 h2收到报文后应答，ping完成。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:2:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验分析 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验内容 通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：ryu源码解读——simple_switch.py。 使用OVS搭建网络模型：h1 —- s1 —- h2，将s1连接到控制器。 h1 ping h2，观察PacketIn消息。 查看s1的流表变化。 这里不用mininet平台搭建网络的原因是：mininet主机会定时检查与交换机的连接，导致出现很多的冗余PacketIn消息，不利于观察。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:1","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"实验结果 当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。 使用ovs-ofctl dump-flows s1命令观察流表，结果如下： 执行完ping命令后多了两条流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:2","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"流程分析 日志的输出格式是：packet in \u003c交换机标号\u003e \u003c源mac\u003e \u003c目的mac\u003e \u003c输入端口\u003e h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。 h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。 控制器学习到mac1--端口1，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。 s1广播，h2收到并学习到h1的mac地址，发送\u003csrc = mac2，dst = mac1\u003e的ARP应答报文，s1流表为空，发送PacketIn消息。 控制器学习到mac2--端口2，查找到mac1的对应端口为1，此时下发一条流表in_port=2,output:1，发送PacketOut消息指示s1把这个应答报文转发到端口1。 h1收到应答报文，学习到h2的mac地址，发送\u003csrc = mac1，dst = mac2\u003e的ICMP报文。 此时s1中只有一条流表in_port=2,output:1，仍然发送PacketIn消息。 控制器查找到mac2的对应端口为2，下发一条流表in_port=1,output:2，发送PacketOut消息指示s1把这个报文转发到端口2。 之后略 所以，整个过程中一共上传了三次PacketIn消息，分别是ma1 ff:ff:ff:ff 1，mac2 mac1 2，mac1 mac2 1。 过程结束s1中有两条流表，分别是in_port=2,src=mac2,dst=mac1,action=output:1,in_port=1,src=mac1,dst=mac2,action=output:2。 有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:3:3","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:0","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"总结 要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。 ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:1","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"参考文献 Ping过程 详解 ryu源码解读——simple_switch.py ","date":"2022-01-10","objectID":"/simple_switch_analyse/:4:2","tags":["Ryu","SDN","OVS"],"title":"SDN自学习交换机工作原理分析","uri":"/simple_switch_analyse/"},{"categories":["SDN"],"content":"什么是集线器 集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。 ","date":"2022-01-09","objectID":"/simple_hub/:1:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"实现代码 # simple_hub.py from ryu.base import app_manager from ryu.controller import ofp_event from ryu.controller.handler import MAIN_DISPATCHER from ryu.controller.handler import set_ev_cls class L2Switch(app_manager.RyuApp): def __init__(self, *args, **kwargs): super(L2Switch, self).__init__(*args, **kwargs) @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def packet_in_handler(self, ev): msg = ev.msg datapath = msg.datapath ofp = datapath.ofproto ofp_parser = datapath.ofproto_parser actions = [ofp_parser.OFPActionOutput(ofp.OFPP_FLOOD)] out = ofp_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions) datapath.send_msg(out) ","date":"2022-01-09","objectID":"/simple_hub/:2:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"实现逻辑 当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。 ","date":"2022-01-09","objectID":"/simple_hub/:3:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-09","objectID":"/simple_hub/:4:0","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"参考文献 RYU入门教程 ","date":"2022-01-09","objectID":"/simple_hub/:4:1","tags":["ryu","SDN","Python"],"title":"ryu开发——集线器","uri":"/simple_hub/"},{"categories":["SDN"],"content":"总览 文件位置：ryu/ryu/app/simple_switch.py simple_switch.py共110行 1-18：注释 21-29：引库 32-110：继承类RyuApp ","date":"2022-01-08","objectID":"/simple_switch_note/:1:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"32-37 继承类RyuApp，并调用构造函数 class SimpleSwitch(app_manager.RyuApp): OFP_VERSIONS = [ofproto_v1_0.OFP_VERSION] # 声明支持的Open Flow版本 # 继承，调用构造函数并添加一个新属性 mac_to_port def __init__(self, *args, **kwargs): super(SimpleSwitch, self).__init__(*args, **kwargs) self.mac_to_port = {} 编写的程序实际上是Ryu控制器的APP，需要继承类RyuApp。 自学习交换机需要控制器来维护交换机的帧交换表，帧交换便就是mac地址与端口号的对应关系，所以添加一个新属性mac_to_port。 ","date":"2022-01-08","objectID":"/simple_switch_note/:2:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"39-51 实现一个添加流表的函数 # 函数：添加流表 def add_flow(self, datapath, in_port, dst, src, actions): ofproto = datapath.ofproto match = datapath.ofproto_parser.OFPMatch( in_port=in_port, dl_dst=haddr_to_bin(dst), dl_src=haddr_to_bin(src)# 源和目的mac地址 ) mod = datapath.ofproto_parser.OFPFlowMod( datapath=datapath, match=match, cookie=0, command=ofproto.OFPFC_ADD, # 命令：添加新流表 idle_timeout=0, hard_timeout=0, priority=ofproto.OFP_DEFAULT_PRIORITY, # 优先级：默认 flags=ofproto.OFPFF_SEND_FLOW_REM, actions=actions) datapath.send_msg(mod) #控制器下发消息 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"datapath 控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"协议细节 OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。 OFPMatch：流匹配规则。 flags：以下三个值之一 | OFPFF_SEND_FLOW_REM 当流过期或删除时，发送删除流消息。 | OFPFF_CHECK_OVERLAP 首先检查重叠的条目。 | OFPFF_EMERG 标记为紧急情况。 ","date":"2022-01-08","objectID":"/simple_switch_note/:3:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"53-94 PacketIn消息的处理逻辑： @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): # 解析数据包 msg = ev.msg datapath = msg.datapath ofproto = datapath.ofproto pkt = packet.Packet(msg.data) eth = pkt.get_protocol(ethernet.ethernet) if eth.ethertype == ether_types.ETH_TYPE_LLDP: # 忽略LLDP类型的包 return dst = eth.dst src = eth.src # 初始化mac_port对应规则 dpid = datapath.id self.mac_to_port.setdefault(dpid, {}) # 打印消息 self.logger.info(\"packet in %s%s%s%s\", dpid, src, dst, msg.in_port) # 记录此包对应的mac_port对应规则 self.mac_to_port[dpid][src] = msg.in_port # 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛 if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD # 封装一个OFPActionOutput类型动作：从out_port端口输出 actions = [datapath.ofproto_parser.OFPActionOutput(out_port)] # 如果已经明确了目的mac的输出端口，那么就下发一条流表 if out_port != ofproto.OFPP_FLOOD: self.add_flow(datapath, msg.in_port, dst, src, actions) # 如果交换机没有缓存该包，那么就把该包还回去 data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data # 发送PacketOut消息 out = datapath.ofproto_parser.OFPPacketOut( datapath=datapath, buffer_id=msg.buffer_id, in_port=msg.in_port, actions=actions, data=data) datapath.send_msg(out) 细节分析： ","date":"2022-01-08","objectID":"/simple_switch_note/:4:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"LLDP ","date":"2022-01-08","objectID":"/simple_switch_note/:4:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"PacketIn与PacketOut 当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。 所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。 PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"处理逻辑 解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。 如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。 如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。 封装PacketOut消息，下发。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:3","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"buffer_id与data 交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。 如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。 如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。 ","date":"2022-01-08","objectID":"/simple_switch_note/:4:4","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"96-110 如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息。 这个部分不是自学习交换机必需的。 @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER) def _port_status_handler(self, ev): # 解析消息 msg = ev.msg reason = msg.reason port_no = msg.desc.port_no # 打印 ofproto = msg.datapath.ofproto if reason == ofproto.OFPPR_ADD: self.logger.info(\"port added %s\", port_no) elif reason == ofproto.OFPPR_DELETE: self.logger.info(\"port deleted %s\", port_no) elif reason == ofproto.OFPPR_MODIFY: self.logger.info(\"port modified %s\", port_no) else: self.logger.info(\"Illeagal port state %s%s\", port_no, reason) ","date":"2022-01-08","objectID":"/simple_switch_note/:5:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"结束语 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:0","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"参考文献 RYU入门教程 ","date":"2022-01-08","objectID":"/simple_switch_note/:6:1","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN"],"content":"备注 ryu官方：https://github.com/faucetsdn/ryu 本人注释版：https://github.com/leeshy-tech/ryu ","date":"2022-01-08","objectID":"/simple_switch_note/:6:2","tags":["ryu","SDN","Python"],"title":"ryu源码解读——simple_switch.py","uri":"/simple_switch_note/"},{"categories":["SDN","Network"],"content":"导入 在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 OVS：OpenvSwitch的简称，它是一种支持OpenFlow协议的软交换机。 ryu：基于Python开发的SDN开源控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:1:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"准备工作 树莓派搭载linux操作系统，有无线网卡，利用ifconfig命令查得无线网卡名称。 树莓派之间先组成adhoc网络，参考文章：在树莓派上搭建ad-hoc网络教程 在两台树莓派上安装OVS，参考文章：Open vSwitch系列之二 安装指定版本ovs 在其中一台树莓派上安装ryu控制器。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:2:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"组网步骤 假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"控制节点 IP = 10.0.0.1 开启控制器（进入ryu/ryu/app/文件夹执行）： ryu-manager simple_switch.py\rOVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.1\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"普通节点 IP = 10.0.0.2 OVS的相关操作需要进入管理员模式： sudo su\r开启OVS export PATH=$PATH:/usr/local/share/openvswitch/scripts\rovs-ctl start 创建交换机： ovs-vsctl add-br s1\r将无线网卡挂接到交换机的一个端口： ovs-vsctl add-port s1 wlan0\r网卡设置，此部分详解见下方解释： ifconfig wlan0 0\rifconfig s1 10.0.0.2\rifconfig s1 up\r交换机连接控制器： ovs-vsctl set-controller s1 tcp:10.0.0.1:6653\r","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"关于网卡设置的解释 将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下： 无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。 对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。 创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令： 取消wlan0设置的IP地址：ifconfig wlan0 0 设置网卡s1的IP地址为原主机地址：ifconfig s1 10.0.0.1 开启网卡s1：ifconfig s1 up ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:3:3","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"测试 如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？ 注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。 查询两个交换机的流表信息： ovs-ofctl dump-flows s1 输出为空，此时交换机中没有流表。 在控制节点ping普通节点： ping 10.0.0.2 发现可以ping通，同时可以在控制器窗口看到PacketIn消息。 再次查询流表：ovs-ofctl dump-flows s1 发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:4:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"应用 模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序： 控制节点：python3 SDN_on_Raspberry_pi/client.py 普通节点：python3 SDN_on_Raspberry_pi/sever.py 从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:5:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"结束语 因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:0","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"参考文献 在树莓派上搭建ad-hoc网络教程 OVS初级教程：使用Open vSwitch构建虚拟网络 Open vSwitch系列之二 安装指定版本ovs ovs之组网实验 SDN系列学习课程-OpenFlow-Ryu-Mininet TCP/IP网络通信之Socket编程入门 ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:1","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["SDN","Network"],"content":"备注 本文依赖代码文件：https://github.com/leeshy-tech/SDN_on_Raspberry_pi ","date":"2022-01-08","objectID":"/sdn_on_raspberrypi/:6:2","tags":["OVS","SDN","树莓派"],"title":"在树莓派上构建SDWN网络教程","uri":"/sdn_on_raspberrypi/"},{"categories":["Note"],"content":"查看信息 查看openvswitch的状态：ovs-vsctl show 查看openvswitch中的所有网桥：ovs-vsctl list-br 查看网桥的信息：ovs-ofctl show br0 查看网桥中的所有端口：ovs-vsctl list-ports br0 查看网桥各端口状态：ovs-ofctl dump-ports br0 查看网桥上的流表：ovs-ofctl dump-flows br0 查看网桥故障模式：ovs-vsctl get-fail-mode br0 查看网桥是否开启stp协议：ovs-vsctl get bridge br0 stp_enable 查看网桥所有配置信息：ovs-vsctl list bridge br0 查看端口所有特性信息：ovs-vsctl list port br0 port1 ","date":"2022-01-07","objectID":"/ovs_cli/:1:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"网桥操作 添加网桥：ovs-vsctl add-br br0 删除网桥：ovs-vsctl del-br br0 将网桥连接到控制器：ovs-vsctl set-controller br0 tcp:\u003ccontroller IP\u003e:\u003cport\u003e 设置网桥的故障模式：ovs-vsctl set-fail-mode br0 \u003csecure or standalone\u003e 给网桥开启stp协议：ovs-vsctl set bridge br0 stp_enable=true ","date":"2022-01-07","objectID":"/ovs_cli/:2:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"端口操作 增加端口：ovs-vsctl add-port br0 port1 删除端口：ovs-vsctl del-port br0 port1 设置端口号：ovs-vsctl set Interface port1 ofport_request=\u003cnumber\u003e 设置端口类型：ovs-vsctl set Interface p4 type=\u003ctype\u003e 端口类型 描述 Normal 普通端口 Internal 这个端口相当于一个虚拟网卡 Patch 用于连接两个网桥的端口 Tunne 隧道端口是一种虚拟端口，支持使用gre或vxlan等隧道技术与位于网络上其他位置的远程端口通讯。 ","date":"2022-01-07","objectID":"/ovs_cli/:3:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"网卡操作 将物理网卡挂接到网桥：ovs-vsctl add-port br0 eth0 列出所有挂接到网卡的网桥：ovs-vsctl port-to-br eth0 删除网桥上已经挂接的网卡：ovs-vsctl del-port br0 eth0 ","date":"2022-01-07","objectID":"/ovs_cli/:4:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"流表操作 添加流表：ovs-ofctl add-flow br0 \u003cmatch\u003e,\u003caction\u003e 删除流表：ovs-ofctl add-flow br0 \u003cmatch\u003e ","date":"2022-01-07","objectID":"/ovs_cli/:5:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"流表动作 action 从端口转发：actions=output:\u003cnumber\u003e 丢弃数据包：actions=drop 广播：actions=NORMAL ","date":"2022-01-07","objectID":"/ovs_cli/:5:1","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"匹配项 match 如有多个匹配项，之间用逗号隔开。 匹配项 描述 in_port=port 网桥端口号 dl_vlan=vlan 数据包的 VLAN Tag 值 dl_vlan_pcp=priority VLAN 优先级，改值取值区间为[0-7]。数字越大，优先级越高。 dl_src=,dl_dst= 匹配源或者目标的 MAC 地址 dl_type=ethertype 匹配以太网协议类型 ,IPv4:0x0800,IPv6:0x086dd,ARP:0x0806 nw_src=,nw_dst= 匹配源或目的IP，前提要设定dl_type table=number 指定流表编号 reg=value[/mask] 网桥中寄存器的值 tp_src=number,tp_dst=number TCP协议源或目的端口 ","date":"2022-01-07","objectID":"/ovs_cli/:5:2","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Note"],"content":"参考文献 OpenvSwitch系列 ","date":"2022-01-07","objectID":"/ovs_cli/:6:0","tags":["OVS"],"title":"OVS命令笔记","uri":"/ovs_cli/"},{"categories":["Electronic Design","Course"],"content":" 注：本项目来自BUPT课程《电子工艺实习》 ","date":"2022-01-04","objectID":"/electronic_dog/:0:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"导入 电子狗是声控、光控、磁控机电一体化电动玩具。主要工作原理：利用555构成的单稳态触发器，在三种不同的控制方法下，均给以低电平触发，促使电机转动，从而达到了机器狗停走的目的。即：拍手即走、光照即走、磁铁靠近即走，但都只是持续一段时间后就停会下，再满足其中一条件时将继续行走。 原理图如下： 整个系统可分为信号转化、单稳态触发器以及电机驱动三个部分。 ","date":"2022-01-04","objectID":"/electronic_dog/:1:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"单稳态触发器 这部分的功能是：将持续时间很短的低电平信号转换为固定时间间隔（1.1RC）的高电平信号以控制电子狗走路持续时间（控制R和C的数值）。 关于单稳态触发器的原理分析可参考以下文章： 555定时器 ","date":"2022-01-04","objectID":"/electronic_dog/:2:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"信号转换 这部分的功能是将磁、光、声信号转换为低电平电信号。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"磁信号 磁信号向电信号的转换通过干簧管传感器实现，干簧管的电路模型类似于一个磁控开关，外加磁场时开关闭合，常态开关断开（也有常态是闭合的干簧管），详细原理如下： 干簧片相当于一个磁通导体，在尚未操作时，两片簧片并未接触；在通过永久磁铁或电磁线圈产生的磁场时，外加的磁场使两片簧片端点位置附近产生不同的极性, 当磁力超过簧片本身的弹力时，这两片簧片会吸合导通电路；当磁场减弱或消失后,干簧片由于本身的弹性而释放，触面就会分开从而打开电路。 接上拉电阻即可实现常驻高电平，外加磁场时开关闭合输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"光信号 光信号向电信号的转变通过光敏三极管实现，电路模型相当于光控开关，光照相当于开关闭合，详细原理如下： 光敏三极管的发射极具有光敏特性。它的集电极则与普通晶体管一样，可以获得电流增益，基极一般没有引线。当受到光照时CE两极导通，相当于开关闭合。 同样使用上拉电阻，不再赘述。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"声信号 声信号向电信号的转变通过麦克风实现，目前常用的麦克风有驻极体电容麦克风（ECM）和微机电麦克风（MEMS Micphone）。在电子狗实验中使用的是ECM，声波压力推动极板后退使得电容两极电压升高，从而将声信号转换为了电压信号。 因需要对电压放大，驻极体麦克风内部有一个场效应管，正常工作需要加一个直流偏置，其驱动电路之一为： 电容的作用是隔直流。 应用于电子狗的电路设计如下： 左侧为驱动电路，中间加一级共射放大器，右侧是二极管反相器，当麦克风接收到声音信号时，产生交流电压，放大到二级管基极，二极管截止，输出接地，即输出低电平。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"仿真 干簧管和光敏二极管的电路模型都很简单，没有仿真的必要，以电阻分压的瞬间变化模拟麦克风输出的交流电压，仿真电路如下： 仿真结果显示，开关闭合产生的电压波动输出了约50ms左右的低电平，这是非常不合适的，因为实际的麦克风产生的电压波动情况远远复杂于我们的模拟，会产生持续时间更长的低电平信号，而后级的单稳态触发器，当输入低电平信号持续时间大于1.1RC时，输出高电平的时间会相应的延长，我们想要的应当是一个持续时间很短的电平信号。 解决方法是加入负反馈： 图中绿色部分为增加的负反馈电路，当555定时器输出高电平时，C5充电将Q2 B极电位拉高，使其截止，相当于开关闭合，从而将Q3的B极电位拉低，使得Q3的C极低电位只持续很短的时间。 重新仿真结果如下： 低电平的持续时间变为500us左右。 ","date":"2022-01-04","objectID":"/electronic_dog/:3:4","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"电机驱动 此部分的功能是利用555定时器输出的高电平信号驱动电机转动 电动机是怎么驱动的？非常简单，电池分别接正负极即可。 但是，在已有的场景下，不能使用这种方式，即把555定时器的输出端3号管脚接到电动机正极，地接电动机负极。 原因是：555定时器的驱动能力不足。 查询555定时器（NE555P）的数据手册可知，输出电流最大只有225mA左右，常见的电动玩具马达空载驱动电流在600mA左右，555定时器是远不足以驱动马达的。 最简单的放大电流的方法就是晶体管反相器，所以电机驱动的电路原理图如下： 并联两个三极管增大放大倍数，二极管是防止电机反转，注意这是一个反相器，所以要接到电动机的负极。 用灯泡代替电动机，简单仿真如下： 注意此处输入端用单刀双掷开关，单开关断开是悬空状态，不是输入低电平。 电源两端并联电容是为了稳压和滤波。 ","date":"2022-01-04","objectID":"/electronic_dog/:4:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"总体仿真 将以上模块合并，仿真图如下（光敏二极管用光耦合器代替）： 仿真结果： 电路启动时触发一次电子狗，三种信号各触发一次，注意这里光信号和磁信号使用的是回弹式开关，为下文埋下了伏笔。 ","date":"2022-01-04","objectID":"/electronic_dog/:5:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改进 学校提供的原理图的分析就到这里了，但实际做实验的时候有一些不方便的地方，比如实验室是常亮状态，光照就会一直触发电子狗，必须遮住光，暴露一下就要马上再遮住，在仿真中使用回弹式开关也是这个原因，还是在于单稳态触发器的输入信号不能持续太长时间，我提出的改进方法如下： ","date":"2022-01-04","objectID":"/electronic_dog/:6:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为黑暗触发 这种改进方案很简单，在光信号转化模块后面加一个二极管反相器就可以。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"改为边沿触发 改进方案与仿真结果如图所示： 开关关闭和开启会被转化为一个短暂的低电平信号，这个信号的持续时间可以通过调整R和C的值来改变。 原理：利用一阶RC电路将原输入信号做一个短暂延时，再与原信号做同或运算，延时的部分就被计算为了0，其他时刻为1。 当初写实验报告的时候只简单写了一个“用边沿触发器实现即可”，现在想想还真不是这么回事。 ","date":"2022-01-04","objectID":"/electronic_dog/:6:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"结束语 ","date":"2022-01-04","objectID":"/electronic_dog/:7:0","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"体会 这门课我还是学到了很多东西的。但是我看了看实验报告的标题“电子狗组装”，实在是很让人难蚌。 ","date":"2022-01-04","objectID":"/electronic_dog/:7:1","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"参考文献 555定时器_Leeshy’s Blog 小马达电机_淘宝网 干簧管_华壬电子 光电三极管_百度百科 一文看懂咪头的工作原理及结构（驻极体话筒） ","date":"2022-01-04","objectID":"/electronic_dog/:7:2","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design","Course"],"content":"备注 本文仿真使用的是Multisim，原理图绘制使用的是立创EDA。 本文依赖文件：https://github.com/leeshy-tech/Electronic-Design/tree/main/e-dog NE555P数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-04","objectID":"/electronic_dog/:7:3","tags":["555 timer","MIC"],"title":"三控电子狗原理分析——光控、磁控、声控","uri":"/electronic_dog/"},{"categories":["Electronic Design"],"content":"什么是555定时器 555定时器是一种集成电路芯片，常被用于定时器、脉冲产生器和振荡电路。555可被作为电路中的延时器件、触发器或起振元件。 内部组成如下：由比较器C1C2、RS触发器、缓冲非门G、放电二极管T组成 ","date":"2022-01-02","objectID":"/555timer/:1:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"芯片分析 电压比较器：一种模拟输入、数字输出的接口电路，输出特性如下： in out Vp \u003e Vn 1 Vp \u003c Vn 0 在555定时器内部，左侧是纯电阻分压电路，将比较器阈值设置为 $$ V_{P1}=\\frac{2}{3} V_{cc}, V_{N2}=\\frac{1}{3} V_{cc} $$ C1C2的输出特性如下： C1 C2 in out in out Vp \u003e 2/3Vcc 0 Vn \u003e 1/3Vcc 1 Vp \u003e 2/3Vcc 1 Vn \u003c 1/3Vcc 0 结合RS触发器的真值表可得555定时器的真值表如下： Ui1 Ui2 复位Rd Uo 放电管T x x 0 0 导通 \u003c2/3Vcc \u003c1/3Vcc 1 1 截止 \u003e2/3Vcc \u003e1/3Vcc 1 0 导通 \u003c2/3Vcc \u003e1/3Vcc 1 不变 不变 ","date":"2022-01-02","objectID":"/555timer/:2:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"典型应用 单稳态电路 多谐振荡器 施密特触发器 ","date":"2022-01-02","objectID":"/555timer/:3:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"555定时器为核心的单稳态电路 ","date":"2022-01-02","objectID":"/555timer/:4:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"理论分析 应用电路如下： 稳定状态时，管脚2输入信号为高电平，管脚6跨电容与地相连，相当于输入低电平，复位引脚4接高电平，故输出保持低电平不变，放电二极管保持导通不变。 当输入信号的下降沿到来，输出变为高电平，放电二极管截止，管脚7向外放电，电容C开始充电，直到$ u_C=\\frac{2}{3} V_{cc}$ 若忽略晶体管的饱和压降，则充电时间为 $t_w=RCln \\frac{\\mathrm{Vcc}}{Vcc-\\frac{2}{3} Vcc} =RCln 3 \\approx 1.1 RC$ 当输入信号回到高电平且电容充电完毕后，输出回到低电平，放电二极管截止。 ","date":"2022-01-02","objectID":"/555timer/:4:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"仿真验证 使用Multisim仿真，电路如下： 选用回弹式开关使输入信号在电容充电完毕之前回到高电平，以便于从示波器图形上测得充电时间。 仿真结果： 电路行为与理论分析一致，根据理论分析公式 $\\mathrm{t}_{\\mathrm{w}}=1.1 \\times 10 \\mathrm{k} \\times 4.7 \\mathrm{u}=51.7 \\mathrm{~ms} $,仿真测得充电时间为50.94ms，且充满后电压为2.985V，与理论分析相符的很好。 ","date":"2022-01-02","objectID":"/555timer/:4:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"总结 该单稳态触发器的功能总结为：将低电平脉冲信号（持续时间小于1.1RC）转化为持续时间为1.1RC的高电平信号，持续时间大于1.1RC的话，就只是由低电平转化为高电平。 ","date":"2022-01-02","objectID":"/555timer/:4:3","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"结束语 ","date":"2022-01-02","objectID":"/555timer/:5:0","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"参考文献 555定时器及应用 电压比较器_百度百科 555定时器_百度百科 NE555P_立创商城 ","date":"2022-01-02","objectID":"/555timer/:5:1","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":["Electronic Design"],"content":"备注 仿真文件及数据手册：https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer ","date":"2022-01-02","objectID":"/555timer/:5:2","tags":["555 timer"],"title":"555定时器","uri":"/555timer/"},{"categories":null,"content":"关于我是谁 20岁 北京邮电大学19级信息工程专业本科生 技能点主要是软件定义网络（SDN，software defined network）、电子设计以及Python ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"多说几句 博客内容呢，能否转载和是否署名都不是我能控制的事情，毕竟现在的网络时代就是这样。 你们这些学法的到底保护了些什么啊ちくしょう 但是我会永远遵守开源精神，附上我的博客参考的一切。 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"友链 lgt：https://ayamir.github.io/ 黄鸡：https://hyiker.com/ ClSlaid：https://clslaid.icu/ liCheng前辈：http://www.muzixing.com/ Fine：https://ffa2000.github.io/ 广告位招租 ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"听首歌 ","date":"0001-01-01","objectID":"/about/:4:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"引个流 \r","date":"0001-01-01","objectID":"/about/:5:0","tags":null,"title":"","uri":"/about/"}]