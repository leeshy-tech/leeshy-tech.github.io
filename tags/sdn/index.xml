<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>SDN - 标签 - Leeshy&#39;s Blog | To be humble</title>
        <link>https://leeshy-tech.github.io/tags/sdn/</link>
        <description>SDN - 标签 - Leeshy&#39;s Blog | To be humble</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>saili@bupt.edu.cn (Leeshy)</managingEditor>
            <webMaster>saili@bupt.edu.cn (Leeshy)</webMaster><lastBuildDate>Tue, 18 Jan 2022 23:09:06 &#43;0800</lastBuildDate><atom:link href="https://leeshy-tech.github.io/tags/sdn/" rel="self" type="application/rss+xml" /><item>
    <title>论文笔记——On Scalability of SDN</title>
    <link>https://leeshy-tech.github.io/on_scalability_of_sdn_note/</link>
    <pubDate>Tue, 18 Jan 2022 23:09:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/on_scalability_of_sdn_note/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6461198" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/6461198</a><br>
IEEE Communications Magazine  <br>
Volume 51 Issue 2</p>
<h2 id="摘要">摘要</h2>
<p>在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是SDN所独有的。我们探讨了在不同环境中经常出现的问题，讨论了SDN设计空间中可扩展性的权衡，并介绍了一些关于SDN可扩展性的最新研究。此外，我们还列举了在可扩展性方面的重要机遇和挑战。</p>
<h2 id="引言">引言</h2>
<p>普遍认为SDN中的控制是集中的，这导致了对SDN可伸缩性和弹性的关注。毕竟，无论控制器的能力如何，中央控制器都不会随着网络的增长而扩展(增加交换机、流量、带宽等的数量)，并且在提供相同的服务保证的同时也无法处理所有传入的请求。此外，由于大多数早期的SDN提议都是基于流的，额外的流启动延迟成为一个问题。  <br>
我们认为SDN的可扩展性没有固有的瓶颈;我们认为这些可扩展性限制并不局限于SDN;传统的控制协议设计也面临着同样的挑战。虽然这并没有解决这些问题，但这表明我们在SDN中不需要比在传统网络中更担心可扩展性。</p>
<h2 id="sdn中可扩展性的根源">SDN中可扩展性的根源</h2>
<p>SDN与传统数据网络的根本区别在于控制与转发平面的分离。这种解耦导致了一些有趣的特性。  <br>
然而，这种解耦也有它自己的陷阱。在这两个平面之间定义一个标准的API是绝对重要的。从技术上讲，这个API应该能够处理各种体系结构的需求，并且应该能够促进这两个平面的独立演化。此外，所有或大多数交换机供应商应该采用相同的标准API，以使其有用；否则，网络将与特定的供应商绑定，会阻碍网络的快速变化和创新。将传统的本地控制功能移动到远程控制器可能会导致新的瓶颈。它还可能导致信令开销。  <br>
在接下来的内容中，我们首先讨论SDN控制器的可扩展性，概述为什么它一直受到关注，以及最近在这个领域的工作。然后，我们回顾一些其他经常提到的SDN可扩展性问题，包括流程设置开销和故障恢复能力。我们认为，尽管这些问题不是SDN特有的，但它们可以通过另一种设计来缓解(其中一些设计现在很常见)。</p>
<h2 id="控制器可扩展性">控制器可扩展性</h2>
<p>一种可能的SDN设计是将所有的控制功能推到一个集中式控制器上。控制器有可能成为网络操作中的瓶颈，随着网络规模的增长，更多的事件和请求会被发送到控制器，并且在某个时刻，控制器无法处理所有传入的请求。缓解这种担忧的一种方法是在多核系统中提高并行性，并提高IO性能。第二种方法是减少转发到控制器的请求数量，比如DevoFlow通过底层网络约束，牺牲细粒度流级可见性（ fine-grained flow-level visibility）换来了可扩展性。<br>
或者，还可以将控制功能的状态和/或计算分配到多个控制器上。提供一个严格一致的集中视图可能会阻碍响应时间和吞吐量。在保持可用性和分区容差的同时实现强一致性并不总是可行的。因此，选择一个合适的一致性水平是SDN中一个重要的设计权衡。 <br>
有一些解决方案，我们可以物理地分布控制平面元素，同时保持网络范围的视图。例如，Onix就是一个分布式控制平台，它促进了分布式控制平面的实现。它为控制应用程序提供了一组通用api，以方便访问分布在Onix实例上的网络状态(NIB)。另一方面，HyperFlow在多个控制器实例之间同步网络状态，使控制应用程序(在每个控制器实例上运行)产生控制整个网络的错觉。这保持了在中央控制器上开发控制平面的简单性，同时减轻了与中央控制器相关的可伸缩性问题，尽管这是针对满足某些特性的一组更受限制的控制应用程序。<br>
Kandoo[9]采用了一种不同的方法来分配控制平面。它定义了一个操作范围，使具有不同要求的应用程序能够共存：本地作用域的应用程序（即，可以使用交换机的本地状态进行操作的应用程序）部署在数据路径附近，以处理频繁的请求并保护控制平面的其他部分免受负载。另一方面，根控制器负责需要网络范围状态的应用程序，同时也充当本地控制器之间需要的任何协调的中介。<br>
一个有趣的观察结果是，SDN中的控制平面可扩展性挑战（例如，收敛性和一致性要求）与传统网络设计中所面临的挑战并没有本质上的不同。SDN本身既不太可能消除控制平面设计的复杂性，也不太可能使其或多或少具有可扩展性。 <br>
与传统网络不同，在SDN中，我们不需要反复解决基本但具有挑战性的问题，如拓扑发现、状态分布和恢复力。</p>
<h2 id="其他sdn可扩展性问题">其他SDN可扩展性问题</h2>
<h3 id="流启动开销">流启动开销</h3>
<p>让我们回顾一下流设置过程来解释瓶颈，并展示一个好的设计如何可以避免它们：</p>
<ul>
<li>包到达但是没有匹配到流规则</li>
<li>交换机产生一个流请求给控制器</li>
<li>控制器返回一个新的流转发规则</li>
<li>交换机更新流表
前三个步骤和最后一个步骤的性能部分取决于交换机能力和资源(管理CPU、内存等)【？这里为什么要说前三个和最后一个】。以及其软件堆栈的性能。第三步中的延迟是由控制器的资源以及控制程序的性能来决定。最后，交换机的FIB更新时间导致了完成流程设置过程的延迟。 <br>
目前支持OpenFlow的软交换机性能远好于硬件交换机，原因是交换机上缺乏资源（管理CPU），对交换机芯片组和管理CPU之间的高频通信的支持不足，以及不佳的软件实现。可以预见，FIB更新时间将成为开关侧流设置延迟的主要因素。
While we argue that controllers and, in the near future, switches would be able to sustain sufficient throughput with negligible latency for reactive flow setup, in the end the control logic determines the scalability of a reactive design. A control program installing an end-to-end path on a per-flow basis does not scale, because the per switch memory is fixed but the number of forwarding entries in the data path grows with the number of active flows in the network. However,  the control program may install aggregate rules matching a large number of micro-flows (thereby facing the same scalability challenges as a proactive design), or proactively install rules in the network core to provide end-to-end connectivity and identify quality of service (QoS) classes, while classifying and reactively labeling flows at the edge.  A viable solution to the scalability challenges of the proactive designs in the former class due to data path memory scarcity is proposed in DIFANE [5]; while the scalability  the latter class follows from the observation that the fanout of an edge switch and thus the number of flows initiated there is bounded (just add edge controllers as the network grows in size).  【没看懂】</li>
</ul>
<h3 id="故障恢复">故障恢复</h3>
<p>早期的系统为单中心控制的设计树立了榜样，因此对故障的恢复能力一直是一个主要问题。一个状态同步的从控制器将足以从控制器故障中恢复，但一个网络分区将留下一半的网络无脑。在多控制器网络中，如果有适当的控制器发现机制，交换机总是可以发现一个存在于其分区中的控制器。因此，在一个可伸缩的发现机制下，控制器故障不会对SDN的可伸缩性构成挑战。 
响应于链路失效的收敛有五个步骤。交换机检测到变化。然后交换机通知控制器。在收到通知后，控制程序计算修复操作，并将更新推到受影响的数据路径元素，这些元素反过来更新它们的转发表。在传统网络中，链路故障通知会在整个网络中泛滥，而在SDN中，该信息直接发送到控制器。因此，SDN网络中的信息传播时延并不比传统网络差。另外，SDN的一个优点是，计算是在更有能力的控制机器上进行的，而不是在所有交换机的弱管理cpu上进行的，无论它们是否受到故障的影响。 <br>
请注意，上述参数建立在隐含的假设之上，即故障的交换机或链路不影响交换机-控制器通信信道。如果有一个出现故障的链路或交换机是控制网络本身的一部分，则需要首先修复控制网络本身。因此，在这种角落的情况下，收敛速度可能比传统网络要慢。<br>
总的来说，SDN中的故障恢复过程并不比传统网络中的更差。因此，存在类似的可伸缩性问题，并且在传统网络中用于最小化停机时间的相同技术也适用于SDN</p>
]]></description>
</item>
<item>
    <title>论文笔记——A Survey of SDN</title>
    <link>https://leeshy-tech.github.io/a_survey_of_sdn_note/</link>
    <pubDate>Tue, 11 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/a_survey_of_sdn_note/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6739370" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/6739370</a> <br>
IEEE Communications Surveys &amp; Tutorials  <br>
Volume 16 Issue 3</p>
<h2 id="摘要">摘要</h2>
<p>本文综述了可编程网络的最新进展，重点介绍了SDN。我们提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。</p>
<h2 id="1-引言">1 引言</h2>
<p>传统网络出现的问题：网络管理和性能调优困难，网络僵化。
可编程网络具有革命性，比如软件定义网络，网络设备成为简单的包转发设备，可以通过开放的接口进行编程。
第二节：早期可编程网络 <br>
第三节：SDN及其体系结构，以及OpenFlow协议。  <br>
第四节：开发和测试SDN的平台和工具。<br>
第五节：在数据中心和无线网络的应用。 <br>
第六节：面临的挑战和未来发展的方向。</p>
<h2 id="2-早期可编程网络">2 早期可编程网络</h2>
<p>描述了一些SDN和OpenFlow概念的前身，在早期的一些项目中已经有了关于可编程网络和数控平面分离的思想。</p>
<h2 id="3-sdn体系结构">3 SDN体系结构</h2>
<p>路由器和交换机通常是封闭的系统，只有很少的提供给供应商的接口。适配新版本的协议（比如Ipv6）非常困难，更不用说部署全新的协议和服务。网络僵化效应主要是由于设备的数据和控制平面紧密耦合，新的app或功能的部署需要直接实现在物理设施中。解决网络僵化的一个手段是使用中间设备，比如CDN（内容交付网络）。<br>
软件定义网络将转发硬件和控制逻辑分离，可以更容易地部署新协议和应用程序。</p>
<h3 id="a-当前sdn架构">A 当前SDN架构</h3>
<p>目前有两种SDN架构：ForCES和OpenFlow      <br>
</p>
<ul>
<li>ForCES将单个设备中的控制元素与转发元素分开，意图实现在单一网络设备中将转发硬件与第三方控制相结合。它定义了两个逻辑实体，转发元素FE和控制元素CE，它们通过ForCES协议通信，FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能。ForCES还有一个重要功能块LFB（逻辑功能块），它安装在FE上，通过CE进行控制，实现FE的配置和数据包处理。</li>
<li>OpenFlow完全将控制平面从网络设备上剥离，转发设备基于流表进行转发，流表控制着转发规则。没有匹配流表时按照“table-miss”流表项执行相应的动作，比如丢弃、转发给控制器。控制平面与转发平面通过OpenFlow协议进行通信，远程控制器可以添加、删除或更新交换机的流表项。</li>
<li>ForCES和OpenFlow的模型不同，但是可以实现相似的功能。</li>
<li>OpenFlow得到了各界的大力支持，以至于被认为是SDN的官方标准。</li>
</ul>
<h3 id="b-转发设备">B 转发设备</h3>
<p>底层网络中，转发设备有路由器、交换机、无线接入点等。但是在SDN中，控制逻辑和算法都由控制器维护，基本转发硬件均被称为switches——交换机。<br>
规则空间是OpenFlow可扩展性的瓶颈，在尊重网络策略和约束的同时，优化使用规则空间来服务于一定数量的流条目是一个具有挑战性和重要的课题。</p>
<h3 id="c-控制器">C 控制器</h3>
<p>单个控制器能够处理惊人数量的新流请求，并且应该能够管理除最大的网络之外的所有网络。<br>
交换机控制延迟对网络的整体行为有重大影响，因为每个交换机在从控制器收到插入流表中适当规则的消息之前不能转发数据。这个间隔可能会随着链路延迟而增加，并显著影响网络应用程序的性能。 <br>
控制建模对网络的可扩展性影响很大。 <br>
集中式和分布式：软件定义的网络可能具有集中式或分布式的控制平面。OpenFlow允许多个控制器连接到一台交换机上，这将允许备份控制器在出现故障时接管。软件定义的网络还可以具有一定程度的逻辑去中心化，具有多个逻辑控制器。<br>
粒度控制：传统网络的基本元素是包。在软件定义网络中，网络元素是远程控制的，开销是由数据平面和控制平面之间的通信引起的。控制器对每个包做决策会增加额外的延迟，对流的第一个包所做的决策可以应用于该流的所有后续包，通过将流分组可以进一步减少开销。
被动控制和主动控制：这部分没看懂 P1624。</p>
<h3 id="d-南向接口控制器交换机">D 南向接口：控制器——交换机</h3>
<p>OpenFlow本身就是控制器——交换机交互的一种实现。</p>
<h3 id="e-北向接口控制器服务">E 北向接口：控制器——服务</h3>
<p>目前还没有公认的针对北向交互的标准，而且它们更有可能在特定应用程序的特殊基础上实现。</p>
<h3 id="f-标准化工作">F 标准化工作</h3>
<h2 id="4-sdn开发工具">4 SDN开发工具</h2>
<h3 id="a-仿真和仿真工具">A 仿真和仿真工具</h3>
<p>mininet,NS-3</p>
<h3 id="b-可用软交换机平台">B 可用软交换机平台</h3>
<p></p>
<h3 id="c-实体交换机">C 实体交换机</h3>
<p>目前在商品网络硬件中实现的SDN主要技术是OpenFlow标准。<br>
</p>
<h3 id="d-可用控制器平台">D 可用控制器平台</h3>
<p><br>
其中有两个特殊用途的控制器：Flowvisor、RouteFlow <br>
Flowvisor：充当交换机和多个控制器之间的透明代理，它能够创建网络片，将每个片的控制委托给不同的控制器，促进了片之间的隔离。<br>
RouteFlow：它由一个OpenFlow控制器应用程序、一个独立的服务器和一个虚拟网络环境组成，它可以复制物理基础设施的连接并运行IP路由引擎。路由引擎根据所配置的路由协议(如OSPF、BGP)，将转发信息库(FIB)生成到LinuxIP表中。</p>
<h3 id="e-代码验证和调试">E 代码验证和调试</h3>
<p>NICE：自动化的测试工具，用于通过模型检查和符号执行来帮助发现OpenFlow程序中的bug。<br>
Anteater：试图检查数据平面中存在的网络不变量，如连通性或一致性。这种方法的主要优点是它与协议无关；它还将捕获由错误的交换机固件或与控制平面通信不一致而导致的错误。<br>
VeriFlow：进一步提出了一个驻留在控制器和转发元素之间的实时验证工具。能够停止在到达网络之前会导致异常行为的规则。 <br>
OFRewind：允许以不同的粒度记录网络事件（控制和数据），然后再回放以重现特定的场景，从而提供定位和排除导致网络异常的事件的机会。   <br>
ndb：为SDN实现了断点和数据包回溯。<br>
STS：是一个由软件定义的网络故障排除模拟器。它是用python编写的，并且依赖于POX。它模拟了给定网络中的设备，允许进行测试用例，并识别产生给定错误的输入集。</p>
<h2 id="5-sdn应用">5 SDN应用</h2>
<h3 id="a-企业网络">A 企业网络</h3>
<p>校园网也算是特殊的企业网络。适当的管理在企业环境中至关重要，SDN可以通过编程方式执行和调整网络策略，以及帮助监控网络活动和调整网络性能。使用SDN实现的中间设备包括NAT，防火墙，负载平衡器和网络访问控制。对于更复杂的中间设备，直接实现导致性能下降，可以使用SDN提供统一控制和管理。</p>
<h3 id="b-数据中心">B 数据中心</h3>
<p>在大规模数据中心中能源消耗有很重要的成本，ElasticTree是一种电源管理器，利用SDN来寻找满足当前流量条件的最小功率网络的子集。B4是谷歌提出的SDN概念应用于数据中心环境中的实际例子，它是一个连接谷歌全球数据中心的广域网。B4被证明是高效的，而且工作经验表明，控制平面到数据平面通信和硬件编程开销造成的瓶颈是今后工作中需要考虑的重要问题。</p>
<h3 id="c-基于基础设施的无线接入网">C 基于基础设施的无线接入网</h3>
<p>OpenRoads：设想了一种软件定义蜂窝网络。  <br>
Odin：在企业无线局域网环境中引入了可编程性，它在控制器上构建一个访问点抽象，将关联状态与物理访问点分离，实现主动移动管理和负载平衡。 <br>
OpenRadio：专注于部署可编程无线数据平面，在PHY和MAC层而不是第三层，提供灵活性，旨在提供一个模块化接口，能够处理使用不同协议的流量子集，基于决策平面和转发平面分离的思想，操作员可以表示由处理平面模块(如FFT模块、维特比解码等)组装而来的决策平面规则和相应的动作。</p>
<h3 id="d-光网络">D 光网络</h3>
<p>将SDN和OpenFlow标准应用于光传输网络的好处包括：提高光传输网络控制和管理灵活性，支持部署第三方管理和控制系统，以及通过利用虚拟化和SDN部署新的服务。   <br>
文献[88]-[93]</p>
<h3 id="e-家庭和小型企业">E 家庭和小型企业</h3>
<p>随着低成本网络设备的广泛可用性，这些环境变得越来越复杂和普遍，对更仔细的网络管理和更严格的安全性的需求也相应地增加了。但是，在每个家庭和办公室都有一个专门的网络管理员是不现实的。   <br>
Calvert建议将控制器作为“家庭网络数据记录器”，创建可用于故障排除或其他目的日志。  <br>
Feamster建议外包第三方专家，通过远程控制可编程交换机和分布式网络监控和推理算法，来检测可能的安全问题。   <br>
文献[94]-[97]</p>
<h2 id="5-研究所面临的挑战和未来的发展方向">5 研究所面临的挑战和未来的发展方向</h2>
<h3 id="a-控制器和交换机设计">A 控制器和交换机设计</h3>
<p>可扩展性、性能、鲁棒性、安全性
DIFANE：流被主动推到交换机上，试图减少向控制器的请求数量。   <br>
Devoflow：建议处理交换机中的短寿命流和控制器中的长寿流，以减少流设置延迟和控制器开销。   <br>
[28]：主张用一系列规则匹配记录来替换ASIC上的计数器，并在CPU中处理它们，以允许高效访问计数器。    <br>
FLARE：专注于“深度可编程网络”的新型网络节点模型，它为数据平面、控制平面以及它们之间的接口提供了可编程性。    <br>
为了提高可扩展性，特别是为了可靠性和鲁棒性，人们已经认识到逻辑集中的控制器必须是物理分布的。</p>
<h3 id="b-软件定义互联网">B 软件定义互联网</h3>
<p>目前许多关于SDN的工作都是在单个管理域的上下文中检查或提出解决方案。然而，那些管理本质上是分散的环境，比如互联网，需要一个逻辑分布的控制平面。</p>
<h3 id="c-控制器服务交互">C 控制器——服务交互</h3>
<p>目前南向接口定义的相当好，但是北向接口却没有统一的标准，一种可能的解释是，北向接口完全是在软件中定义的，而南向接口必须支持硬件实现。     <br>
如果我们认为控制器是一个“网络操作系统”，那么应该有一个明确定义的接口，应用程序可以访问底层硬件（交换机），与其他应用程序共存和交互，并利用系统服务（例如拓扑发现、转发），而不需要应用程序开发人员知道控制器的实现细节。 <br>
此外，北向的API应该允许应用程序对同一流应用不同的策略(例如，通过目的地进行转发和通过源IP进行监控)。</p>
<h3 id="d-虚拟化和云服务">D 虚拟化和云服务</h3>
<h3 id="e-以信息为中心的网络">E 以信息为中心的网络</h3>
<p>信息中心网络(ICN)是针对未来互联网架构提出的一种新的范式，它旨在提高内容交付的效率和内容可用性。他们的驱动动机是，当前的互联网是信息驱动的，但网络技术仍然专注于基于位置的寻址和主机对主机的通信的想法。通过提出一种处理命名数据而不是命名主机的体系结构，内容分发可以直接实现到网络结构中，而不是依赖于目前用于将内容映射到单个位置的复杂映射、可用性和安全机制。    <br>
ICN中信息处理和转发的分离与SDN中数据平面和控制平面的解耦相一致。然后，问题就变成了如何将ICN和SDN结合起来。</p>
<h3 id="f-异构网络支持">F 异构网络支持</h3>
<p>未来网络面临的一个主要挑战是资源的有效利用；在无线多跳自组网中尤其如此，因为可用的无线容量本质上是有限的。这是由于许多因素，包括共享物理介质的使用、无线信道损坏和受管理基础设施的缺乏。自组织网络缺乏专用资源，而且连接性的变化使容量共享变得困难。底层网络的异构特性（例如，物理介质、拓扑结构、稳定性）和节点（例如，缓冲区大小、功率限制、移动性）在考虑路由和资源分配时也增加了另一个重要的因素。   <br>
迄今为止的SDN技术，如OpenFlow，主要针对基于基础设施的网络。它们促进了一种不适合在无基础设施环境中出现的分散、中断和延迟级别的集中控制机制。虽然之前的工作已经研究了SDN在无线环境中的使用，但其范围主要集中在基于基础设施的部署。</p>
<h2 id="7-结束语">7 结束语</h2>
<p>在本文中，我们提供了一个可编程网络的概述，并在此背景下，考察了软件定义网络(SDN)的新兴领域。我们来看看可编程网络的历史，从早期的想法到最近的发展。我们特别详细描述了SDN体系结构以及OpenFlow[2]标准。我们介绍了当前的SDN实现和测试平台，并检查了基于SDN范式开发的网络服务和应用程序。最后，我们讨论了SDN所支持的未来发展方向，从支持异构网络到信息中心网络(ICN)。</p>
<h2 id="语句摘录">语句摘录</h2>
<blockquote>
<p>As a result, network management and performance tuning is quite challenging and thus error-prone.<br>
因此，网络管理和性能调优非常具有挑战性，所以很容易出错。</p>
</blockquote>
<blockquote>
<p>Because of its huge deployment base and the fact it is considered part of our society’s critical infrastructure (just like transportation and power grids), the Internet has become extremely difficult to evolve both in terms of its physical infrastructure as well as its protocols and performance.<br>
由于其庞大的部署基础，且被视为我们社会关键基础设施(就像交通和电网)的一部分，所以互联网在其物理基础设施、协议和性能方面的发展已经变得极其困难。</p>
</blockquote>
<blockquote>
<p>As SDN becomes more widely adopted and protocols such as OpenFlow are further defined, new solutions are proposed and new challenges arise.<br>
随着SDN被广泛采用，并且OpenFlow等协议被进一步定义，新的解决方案被提出，新的挑战出现.</p>
</blockquote>
<blockquote>
<p>The Internet has revolutionized the way we, as individuals and as a society, live, work, conduct business, socialize, get entertainment, etc. As a result, the Internet is now considered part of our society’s critical infrastructure much like the power, water, and transportation grids.<br>
互联网已经彻底改变了我们作为个人和社会、生活、工作、做生意、社交、获得娱乐等方面的方式。因此，互联网现在被认为是我们社会关键基础设施的一部分，就像电力、水和交通电网一样。</p>
</blockquote>
]]></description>
</item>
<item>
    <title>SDN自学习交换机工作原理分析</title>
    <link>https://leeshy-tech.github.io/simple_switch_analyse/</link>
    <pubDate>Mon, 10 Jan 2022 17:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_analyse/</guid>
    <description><![CDATA[<h2 id="自学习交换机">自学习交换机</h2>
<p>交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。</p>
<p>SDN的自学习交换机跟传统交换机不一样的点有：</p>
<ol>
<li>帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。</li>
<li>自学习的过程中可能会有流表的变化。</li>
</ol>
<h2 id="ping命令过程">ping命令过程</h2>
<p>ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。<br>
局域网ping命令的执行过程：<br>
网络模型为：h1  &mdash;-  s1  &mdash;-  h2，两台主机连接到同一个交换机。
假设h1 ping h2</p>
<ul>
<li>首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。</li>
<li>交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。</li>
<li>h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。</li>
<li>h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。</li>
<li>h2收到报文后应答，ping完成。</li>
</ul>
<h2 id="实验分析">实验分析</h2>
<h3 id="实验内容">实验内容</h3>
<ul>
<li>通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a>。</li>
<li>使用OVS搭建网络模型：h1  &mdash;-  s1  &mdash;-  h2，将s1连接到控制器。</li>
<li>h1 ping h2，观察PacketIn消息。</li>
<li>查看s1的流表变化。</li>
</ul>
<p>这里不用mininet平台搭建网络的原因是：mininet主机会定时检查与交换机的连接，导致出现很多的冗余PacketIn消息，不利于观察。</p>
<h3 id="实验结果">实验结果</h3>
<p><br>
当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。<br>
使用<code>ovs-ofctl dump-flows s1</code>命令观察流表，结果如下：  <br>
<br>
执行完ping命令后多了两条流表。</p>
<h3 id="流程分析">流程分析</h3>
<p>日志的输出格式是：packet in &lt;交换机标号&gt; &lt;源mac&gt; &lt;目的mac&gt; &lt;输入端口&gt;<br>
h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 <br>
h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。</p>
<ol>
<li>h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac1--端口1</code>，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。</li>
<li>s1广播，h2收到并学习到h1的mac地址，发送<code>&lt;src = mac2，dst = mac1&gt;</code>的ARP应答报文，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac2--端口2</code>，查找到mac1的对应端口为1，此时下发一条流表<code>in_port=2,output:1</code>，发送PacketOut消息指示s1把这个应答报文转发到端口1。</li>
<li>h1收到应答报文，学习到h2的mac地址，发送<code>&lt;src = mac1，dst = mac2&gt;</code>的ICMP报文。</li>
<li>此时s1中只有一条流表<code>in_port=2,output:1</code>，仍然发送PacketIn消息。</li>
<li>控制器查找到mac2的对应端口为2，下发一条流表<code>in_port=1,output:2</code>，发送PacketOut消息指示s1把这个报文转发到端口2。</li>
<li>之后略</li>
</ol>
<p>所以，整个过程中一共上传了三次PacketIn消息，分别是<code>ma1 ff:ff:ff:ff 1</code>，<code>mac2 mac1 2</code>，<code>mac1 mac2 1</code>。<br>
过程结束s1中有两条流表，分别是<code>in_port=2,src=mac2,dst=mac1,action=output:1</code>,<code>in_port=1,src=mac1,dst=mac2,action=output:2</code>。 
有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。</p>
<h2 id="结束语">结束语</h2>
<h3 id="总结">总结</h3>
<p>要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.51cto.com/wanicy/335207" target="_blank" rel="noopener noreffer">Ping过程 详解 </a><br>
<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a></p>
]]></description>
</item>
<item>
    <title>ryu开发——集线器</title>
    <link>https://leeshy-tech.github.io/simple_hub/</link>
    <pubDate>Sun, 09 Jan 2022 20:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_hub/</guid>
    <description><![CDATA[<h2 id="什么是集线器">什么是集线器</h2>
<p>集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。</p>
<h2 id="实现代码">实现代码</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># simple_hub.py</span>
<span class="kn">from</span> <span class="nn">ryu.base</span> <span class="kn">import</span> <span class="n">app_manager</span>
<span class="kn">from</span> <span class="nn">ryu.controller</span> <span class="kn">import</span> <span class="n">ofp_event</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">MAIN_DISPATCHER</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">set_ev_cls</span>
 
<span class="k">class</span> <span class="nc">L2Switch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2Switch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
 
    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">ofp</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">ofp_parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>
 
        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">ofp</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
            <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
            <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><h2 id="实现逻辑">实现逻辑</h2>
<p>当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。</p>
<h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
]]></description>
</item>
<item>
    <title>ryu源码解读——simple_switch.py</title>
    <link>https://leeshy-tech.github.io/simple_switch_note/</link>
    <pubDate>Sat, 08 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_note/</guid>
    <description><![CDATA[<h2 id="总览">总览</h2>
<p>文件位置：ryu/ryu/app/simple_switch.py
simple_switch.py共110行<br>
1-18：注释<br>
21-29：引库<br>
32-110：继承类RyuApp</p>
<h2 id="32-37">32-37</h2>
<blockquote>
<p>继承类RyuApp，并调用构造函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">SimpleSwitch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="n">OFP_VERSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofproto_v1_0</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">]</span>   <span class="c1"># 声明支持的Open Flow版本</span>
    <span class="c1"># 继承，调用构造函数并添加一个新属性 mac_to_port</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSwitch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div><ul>
<li>编写的程序实际上是Ryu控制器的APP，需要继承类RyuApp。</li>
<li>自学习交换机需要控制器来维护交换机的帧交换表，帧交换便就是mac地址与端口号的对应关系，所以添加一个新属性mac_to_port。</li>
</ul>
<h2 id="39-51">39-51</h2>
<blockquote>
<p>实现一个添加流表的函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># 函数：添加流表</span>
<span class="k">def</span> <span class="nf">add_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span>
        <span class="n">in_port</span><span class="o">=</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">dl_dst</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">dl_src</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="c1"># 源和目的mac地址</span>
        <span class="p">)</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">cookie</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_ADD</span><span class="p">,</span> <span class="c1"># 命令：添加新流表</span>
        <span class="n">idle_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hard_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">priority</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_DEFAULT_PRIORITY</span><span class="p">,</span> <span class="c1"># 优先级：默认</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFF_SEND_FLOW_REM</span><span class="p">,</span> 
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>      <span class="c1">#控制器下发消息</span>
</code></pre></div><h3 id="datapath">datapath</h3>
<p>控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。</p>
<h3 id="协议细节">协议细节</h3>
<dl>
<dt>OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。</dt>
<dt>OFPMatch：流匹配规则。</dt>
<dt>flags：以下三个值之一</dt>
<dd>| OFPFF_SEND_FLOW_REM   当流过期或删除时，发送删除流消息。</dd>
<dd>| OFPFF_CHECK_OVERLAP   首先检查重叠的条目。</dd>
<dd>| OFPFF_EMERG           标记为紧急情况。</dd>
</dl>
<h2 id="53-94">53-94</h2>
<blockquote>
<p>PacketIn消息的处理逻辑：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析数据包</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">pkt</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">Packet</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">eth</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">.</span><span class="n">get_protocol</span><span class="p">(</span><span class="n">ethernet</span><span class="o">.</span><span class="n">ethernet</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eth</span><span class="o">.</span><span class="n">ethertype</span> <span class="o">==</span> <span class="n">ether_types</span><span class="o">.</span><span class="n">ETH_TYPE_LLDP</span><span class="p">:</span>
        <span class="c1"># 忽略LLDP类型的包</span>
        <span class="k">return</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">dst</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">src</span>

    <span class="c1"># 初始化mac_port对应规则</span>
    <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>  

    <span class="c1"># 打印消息</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;packet in </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">dpid</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">)</span> 

    <span class="c1"># 记录此包对应的mac_port对应规则</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span>

    <span class="c1"># 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span>

    <span class="c1"># 封装一个OFPActionOutput类型动作：从out_port端口输出</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">out_port</span><span class="p">)]</span>

    <span class="c1"># 如果已经明确了目的mac的输出端口，那么就下发一条流表</span>
    <span class="k">if</span> <span class="n">out_port</span> <span class="o">!=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

    <span class="c1"># 如果交换机没有缓存该包，那么就把该包还回去</span>
    <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_NO_BUFFER</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># 发送PacketOut消息</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><p>细节分析：</p>
<h3 id="lldp">LLDP</h3>
<h3 id="packetin与packetout">PacketIn与PacketOut</h3>
<p>当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。<br>
所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。<br>
PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。</p>
<h3 id="处理逻辑">处理逻辑</h3>
<ul>
<li>解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。</li>
<li>如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。</li>
<li>如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。</li>
<li>封装PacketOut消息，下发。</li>
</ul>
<h3 id="buffer_id与data">buffer_id与data</h3>
<p>交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。</p>
<ul>
<li>如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。</li>
<li>如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。</li>
</ul>
<h2 id="96-110">96-110</h2>
<blockquote>
<p>如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息。
这个部分不是自学习交换机必需的。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPortStatus</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_port_status_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析消息</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">reason</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">reason</span>
    <span class="n">port_no</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">port_no</span>

    <span class="c1"># 打印</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="k">if</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_ADD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port added </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_DELETE</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port deleted </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_MODIFY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port modified </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;Illeagal port state </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
</code></pre></div><h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
<h3 id="备注">备注</h3>
<p>ryu官方：<a href="https://github.com/faucetsdn/ryu" target="_blank" rel="noopener noreffer">https://github.com/faucetsdn/ryu</a><br>
本人注释版：<a href="https://github.com/leeshy-tech/ryu" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/ryu</a></p>
]]></description>
</item>
<item>
    <title>在树莓派上构建SDWN网络教程</title>
    <link>https://leeshy-tech.github.io/sdn_on_raspberrypi/</link>
    <pubDate>Sat, 08 Jan 2022 16:31:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/sdn_on_raspberrypi/</guid>
    <description><![CDATA[<h2 id="导入">导入</h2>
<p>在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 <br>
OVS：OpenvSwitch的简称，他是一种支持OpenFlow协议的软交换机。 <br>
ryu：基于Python开发的SDN开源控制器。</p>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>树莓派搭载linux操作系统，有无线网卡，利用<code>ifconfig</code>命令查得无线网卡名称。</li>
<li>树莓派之间先组成adhoc网络，参考文章：<a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a></li>
<li>在两台树莓派上安装OVS，参考文章：<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a></li>
<li>在其中一台树莓派上安装ryu控制器。</li>
</ul>
<h2 id="组网步骤">组网步骤</h2>
<p>假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： 
</p>
<h3 id="控制节点-ip--10001">控制节点 IP = 10.0.0.1</h3>
<p>开启控制器（进入ryu/ryu/app/文件夹执行）：</p>
<pre tabindex="0"><code>ryu-manager simple_switch.py
</code></pre><p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.1
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="普通节点-ip--10002">普通节点 IP = 10.0.0.2</h3>
<p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.2
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="关于网卡设置的解释">关于网卡设置的解释</h3>
<blockquote>
<p>将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下：</p>
</blockquote>
<p>无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。</p>
<p>对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。  <br>
创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令：<br>
取消wlan0设置的IP地址：<code>ifconfig wlan0 0</code><br>
设置网卡s1的IP地址为原主机地址：<code>ifconfig s1 10.0.0.1</code><br>
开启网卡s1：<code>ifconfig s1 up</code></p>
<h2 id="测试">测试</h2>
<blockquote>
<p>如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？</p>
</blockquote>
<p>注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。   <br>
查询两个交换机的流表信息：   <br>
<code>ovs-ofctl dump-flows s1</code>    <br>
输出为空，此时交换机中没有流表。 <br>
在控制节点ping普通节点： <br>
<code>ping 10.0.0.2</code><br>
发现可以ping通，同时可以在控制器窗口看到PacketIn消息。<br>
再次查询流表：<code>ovs-ofctl dump-flows s1</code>  <br>
发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。</p>
<h2 id="应用">应用</h2>
<p>模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序：<br>
控制节点：<code>python3 SDN_on_Raspberry_pi/client.py</code><br>
普通节点：<code>python3 SDN_on_Raspberry_pi/sever.py</code> <br>
从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。</p>
<h2 id="结束语">结束语</h2>
<p>因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a><br>
<a href="https://www.sdnlab.com/sdn-guide/14747.html" target="_blank" rel="noopener noreffer">OVS初级教程：使用Open vSwitch构建虚拟网络</a><br>
<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a><br>
<a href="https://www.cnblogs.com/mrwuzs/p/10242737.html" target="_blank" rel="noopener noreffer">ovs之组网实验</a><br>
<a href="https://www.bilibili.com/video/BV1ft4y1a7ip?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">SDN系列学习课程-OpenFlow-Ryu-Mininet</a><br>
<a href="https://www.bilibili.com/video/BV1eg411G7pW?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">TCP/IP网络通信之Socket编程入门</a></p>
<h3 id="备注">备注</h3>
<p>本文依赖代码文件：<a href="https://github.com/leeshy-tech/SDN_on_Raspberry_pi" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/SDN_on_Raspberry_pi</a></p>
]]></description>
</item>
</channel>
</rss>
