<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>SDN - 标签 - Leeshy&#39;s Blog | To be humble</title>
        <link>https://leeshy-tech.github.io/tags/sdn/</link>
        <description>SDN - 标签 - Leeshy&#39;s Blog | To be humble</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>saili@bupt.edu.cn (Leeshy)</managingEditor>
            <webMaster>saili@bupt.edu.cn (Leeshy)</webMaster><lastBuildDate>Fri, 06 Jan 2023 17:32:06 &#43;0800</lastBuildDate><atom:link href="https://leeshy-tech.github.io/tags/sdn/" rel="self" type="application/rss+xml" /><item>
    <title>可编程网络前世今生</title>
    <link>https://leeshy-tech.github.io/overview_of_programmable_networks/</link>
    <pubDate>Fri, 06 Jan 2023 17:32:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/overview_of_programmable_networks/</guid>
    <description><![CDATA[<h1 id="可编程网络技术及发展趋势综述">可编程网络技术及发展趋势综述</h1>
<blockquote>
<p>本文为BUPT课程“个人发展规划与创新创业”课程论文，仅在此记录，并不是一篇学术论文。</p>
</blockquote>
<h2 id="1-引言">1 引言</h2>
<p>互联网极大地影响着人们的生活和工作方式，经过 40 多年的发展，已经成为人类社会的重要基础设施和各国的重要战略资源。在互联网过去几十年的发展过程中，涌现出一系列优秀的技术和标准，如 TCP（transmission control protocol）/IP（Internetprotocol）、OSPF（open shortest path first）、BGP （ border gateway protocol ） MPLS（ multi-protocol label switching ） 、 IPv6（ Internet protocol version 6 ） 、 BBR（bottleneck bandwidth and RTT）等，以及移动通信网络领域的 3G/4G/5G 网络相关技术等，这些技术为互联网的发展演进提供了重要支撑，做出了历史性贡献。然而，随着新时代的到来，新型网络应用不断涌现，现有的网络结构已难以满足需要，其弊端暴露的越来越明显。</p>
<p>在技术挑战的角度上，未来互联网在可扩展性、移动性、安全性、服务质量保障、高效服务分发、绿色节能等方面、仍面临巨大挑战[1]。关于未来网络技术的发展，学术界涌现了很多新的思想和尝试，比如内容中心网络（content centric network，CCN）、软件定义网络（software-defined network，SDN）、云网络（Nebula）、命名数据网络（named data network，NDN）、可表述网络（expressive internet architecture，XIA）、可选网络（ChoiceNet）等。</p>
<p>对于新型网络技术，主要有两种研究思路，第一种是对于传统网络的分层设计协议，设计更多的协议补丁（如组播、MPLS）；或者设计全新的未来网络协议（如 CCN、NDN）。第二种则是可编程思想，它认为再好的新协议也不能跟上应用和需求的不断变化。因此，从系统设计的角度，利用灵活定制的思想定制未来的网络。</p>
<h2 id="2-现有网络的问题和挑战">2 现有网络的问题和挑战</h2>
<h3 id="21-部署管理困难">2.1 部署管理困难</h3>
<p>网络中有多种设备，从路由器和交换机到防火墙、网络地址转换器、服务器负载平衡器和入侵检测系统等中间设备。这些专用设备通常是&quot;封闭&quot;系统。具有有限的并且特定于供应商的配置接口。一旦部署并投入生产，当前的网络基础设施很难演进。部署协议的新版本（例如 IPv6）非常困难，更不用说部署全新的协议和服务，几乎是不可完成的任务。</p>
<h3 id="22-分布式架构瓶颈">2.2 分布式架构瓶颈</h3>
<p>传统网络在设计之初就采用分布式的结构，无中心节点，设备之间采用口口相传的方式传递信息，每台设备都有自己的 CPU、独立决定转发逻辑，造成无法从全局的角度进行资源分配和流量调度[2]。同时，为了协调各个设备的相互沟通，诞生了无数的网络协议，带来了新旧兼容、更新缓慢的问题。</p>
<h3 id="23-可扩展性问题">2.3 可扩展性问题</h3>
<p>当前网络规模不断扩大，互联网流量爆炸，网络流量超线性增长，然而芯片处理性能的增长受摩尔定律的限制，硬件处理性能越来越跟不上流量的提升速度，域间路由收敛变慢，网络稳定性下降。根据 APNIC 提供的数据：BGP（边界网关协议）更新频率平均达到 6 次/s，一天累计 50 万次以上，峰值高达 1000 次/s。所以网络可持续发展面临严峻挑战。</p>
<h3 id="24-不可控qos难以保证">2.4 不可控、QoS难以保证</h3>
<p>从需求驱动角度来看，新的业务将对未来网络提出更多的要求。例如，在消费型业务领域，AR（augmented reality）/VR（virtualreality）/3D 通话、全息传送、交互式游戏等沉浸式业务将对网络低时延、大带宽性能提出更高要求；在工业互联网领域，精仪制造、远程工控、数字孪生等生产性业务则要求网络具备更好的低时延、低抖动能力；在车联网领域，自动驾驶、车路协同、无人车、无人机、无人船等新兴业务则会对网络提出低时延、高可靠的双重需求。</p>
<p>而传统 TCP/IP 网络遵循&quot;尽力而为&quot;的转发，网络侧重公平性原则，缺少提供差异性服务的能力，对于新时代对于网络容量、实时性、可靠性的差异化需要，传统网络结构是无能为力的。</p>
<h2 id="3-早期可编程网络">3 早期可编程网络</h2>
<p>软件定义网络以数控分离、可编程等主要特点受到广泛认可，特别是 OpenFlow 被吹捧为&quot;网络中的激进新思想&quot;。然而，科学研究不是一蹴而就的，SDN 也是受早期可编程网络工作的影响，它们是当前 SDN 范式的前身，为当前的许多思想奠定了基础。</p>
<h3 id="31-open-signaling">3.1 Open Signaling</h3>
<p>开放信令 (OPENSIG) 工作组于 1995年开始举办一系列研讨会，致力于&quot;使 ATM、互联网和移动网络更加开放、可扩展和可编程&quot;。 他们认为通信硬件和控制软件之间的分离是必要的，但实现起来具有挑战性；这主要是由于垂直集成的交换机和路由器，其封闭性使得快速部署新的网络服务和环境变得不可能。他们提议的核心是通过开放、可编程的网络接口提供对网络硬件的访问；这将允许通过分布式编程环境部署新服务。</p>
<p>在这些想法的推动下，IETF 工作组应运 而 生 ， 随后导致了通用交换管理协议(GSMP)的诞生，这是一种控制标签交换的通用协议。GSMP 允许控制器在交换机上建立和释放连接、添加和删除多播连接上的叶子、管理交换机端口、请求配置信息、请求和删除交换机资源的预留以及请求统计信息。</p>
<h3 id="32-active-networking">3.2 Active Networking</h3>
<p>同 样 在 1990 年 代 中 期 ， ActiveNetworking 倡议提出了一种网络基础设施的想法，该网络基础设施可以为定制服务进行编程。有两种主要方法正在考虑中，即：(1)用户可编程交换机，具有带内数据传输和带外管理通道；(2)胶囊，可以在用户消息中携带的程序片段；然后程序片段将由路由器解释和执行。尽管它激发了相当多的活动，但 Active Networking 并获得广泛使用和行业部署，主要是由于实际的安全和性能问题。</p>
<h3 id="33-dcan">3.3 DCAN</h3>
<p>1990 年代中期发生的另一项举措是 ATM 网络下放控制 (DCAN)。 该项目的目的是为 ATM 网络的可扩展控制和管理设计和开发必要的基础设施。前提是许多设备的控制和管理功能（ 在 DCAN 的情况下是 ATM 交换机）应该与设备本身分离，并委托给专用的外部实体，这基本上是 SDN 背后的概念。</p>
<h3 id="34-4d-project">3.4 4D Project</h3>
<p>从 2004 年开始，4D 项目提倡一种全新的设计，强调路由决策逻辑和管理网络元素之间交互的协议之间的分离。它建议为&quot;决策&quot;平面提供网络的全局视图，由&quot;传播&quot;和&quot;发现&quot;平面提供服务，以控制用于转发流量的&quot;数据&quot;平面。这些想法为后来的工作提供了直接的灵感 ， 例如 NOX ， 它在支持 OpenFlow 的网络的背景下提出了&quot;网络操作系统&quot;。</p>
<h3 id="35-netconf">3.5 NETCONF</h3>
<p>2006年，IETF网络配置工作组提出 NETCONF作为修改网络设备配置的管理协议。该协议允许网络设备公开一个API，通过该API可以发送和检索可扩展的配置数据。</p>
<p>尽管NETCONF协议实现了简化设备（重新）配置的目标并充当管理的构建块，但数据平面和控制平面之间没有分离。具有NETCONF的网络不应被视为完全可编程，因为任何新功能都必须在网络设备和管理器上实现，以便可以提供任何新功能。</p>
<h3 id="36-ethane">3.6 Ethane</h3>
<p>OpenFlow的直接前身是SANE / Ethane 项目，该项目在 2006 年为企业网络定义了一种新架构。Ethane的重点是使用集中式控制器来管理网络中的策略和安全性。一个值得注意的例子是提供基于身份的访问控制。与SDN类似，Ethane使用两个组件：一个控制器来决定是否应该转发数据包，以及一个由流表和到控制器的安全通道组成的Ethane交换机。</p>
<h2 id="4-软件定义网络">4 软件定义网络</h2>
<p>软件定义网络在可编程网络中无疑是里程碑式的发展。它旨在促进创新并实现对网络数据路径的简单编程控制。如图1所示，转发硬件与控制逻辑的分离允许更轻松地部署新协议和应用程序、直接的网络可视化和管理，以及将各种中间盒整合到软件控制中。网络不是在分散设备的集合上执行策略和运行协议，而是简化为“单一”的转发硬件和决策网络控制器。</p>
<p></p>
<h3 id="41-openflow">4.1 OpenFlow</h3>
<p>OpenFlow[3]项目第一次完整阐述并实践了软件定义网络的思想，它的影响之大以至于许多人几乎将OpenFlow等同于狭义上的SDN。</p>
<p>在OpenFlow架构中，传统转发设备中的控制功能被彻底抽象出来，交换机成为功能单一的转发设备，只按照流表项匹配转发，控制器与交换机通过OpenFlow协议进行安全通信。</p>
<p>交换机中的流表决定了对于一条流的处理动作，当到达交换机的包不能匹配已存在的流表时，交换机将包转发到控制器，由控制器决定转发逻辑并下发流表。并且，控制器开放了北向接口，可以通过编程的方式控制转发逻辑。由此便实现了对网络的灵活控制。</p>
<p></p>
<p>开放网络基金会(ONF)及其SDN提案 OpenFlow 获得了来自工业、研究和学术界的大力支持。来自这些不同部门的支持最终以研究论文、参考软件实现甚至硬件的形式产生了大量可交付成果。以至于有些人认为OpenFlow架构是SDN的事实标准。</p>
<h3 id="42-forces">4.2 ForCES</h3>
<p>IETF ForCES（Forwarding and Control Element Separation，转发和控制元素分离）工作组提出的方法重新定义了控制元素与转发元素分离的网络设备的内部架构。然而，网络设备仍被表示为单个实体。工作组提供的例子在单个网络设备中将新的转发硬件与第三方控制相结合。因此，控制平面和数据平面在物理上非常接近（例如，相同的盒子或房间）。</p>
<p>ForCES定义了两个逻辑实体，分别称为转发元素(FE)和控制元素(CE)，它们都实现了 ForCES 协议进行通信。FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能，并使用 ForCES 协议来指示 FE 如何处理数据包。该协议基于主从模型工作，其中FE是从站CE是主站。</p>
<p>ForCES架构的一个重要组成部分是 LFB（Logical Function Block，逻辑功能块）。LFB是驻留在FE上的定义明确的功能块，由CE通过 ForCES 协议控制。LFB使CE能够控制FE的配置以及FE如何处理数据包。</p>
<h2 id="5-数据平面可编程">5 数据平面可编程</h2>
<h3 id="51-数据平面功能">5.1 数据平面功能</h3>
<p>设备的数据平面通过执行一系列操作来处理网络数据包，包括解析数据包，确定需要应用的处理操作的顺序，并根据这些操作的结果进行转发。数据包处理需要以下基本功能步骤：解析、分类、修改、解析和转发。除了基本功能之外，大多数数据包处理系统还可以提供附加服务，例如调度、过滤、计量或流量整形[4]。</p>
<p>随着SDN范式的出现和采用，设备功能变得更加灵活和动态。但是，在传统的网络设备中，数据平面功能深深植根于设备硬件和软件中，因此通常在设备的生命周期内无法更改[5]。对于基于软件的数据包处理系统，需要主要供应商软件更新来更改数据平面功能。此固定功能几乎影响所有数据平面操作。可以加载到匹配动作表中的条目的格式和语义是固定的；设备只能理解一组有限的协议头和字段。例如，以太网交换机不处理第3层字段，过时的路由器将不支持IPv6。可以应用的处理操作的类型以及执行这些操作的顺序由设备供应商设置。</p>
<h3 id="52-p4">5.2 P4</h3>
<p>P4（Programming Protocol-independent Packet Processors）[6]即“独立于协议的可编程数据包处理器”。P4的设计目标如下：</p>
<ol>
<li>可重配置。交换机的数据包处理方式能被重新配置，可以通过编程的方式灵活定义数据平面的报文处理流程，在不更换交换机硬件的前提下，适应快速更迭的网络协议。</li>
<li>协议无关性。交换机支持的数据包处理行为不受协议类型局限，并且管理员可以定制交换机本身支持的协议。</li>
<li>平台无关性。网络管理员能够独立于特定的底层平台来描述报文处理功能，类似于C或者C++程序，管理员编程时不用关注底层架构。</li>
</ol>
<p></p>
<p>P4交换机将流水线处理数据的过程进行抽象和重定义，数据处理单元对数据的处理抽象成匹配和执行匹配-动作表的过程，包头的解析抽象成P4中的解析器，数据处理流程抽象成流控制。</p>
<h3 id="53-其他数据平面编程语言">5.3 其他数据平面编程语言</h3>
<p>P4作为数据平面的领域特定语言（Domain Specific Language，DSL），虽然能够显著提升数据平面的可编程能力，实现一些以前未曾实现过的数据平面功能，为网络数据包处理带来很大的便利，但是由于其表达能力有限以及数据平面本身的局限性，P4并不能成为网络问题的万能解决方案。</p>
<p>除了P4语言，其他数据平面DSL也可以描述数据平面的报文处理逻辑，比如POF，P4和POF的目标都是使底层设备可编程性更强，但是POF的语法更贴近于原来的 OpenFlow 协议规范，并使用类似汇编语言的语法对网络设备进行编程，对不同设备的编程目前采用基于解释翻译而并非编译的方式实现[7]。</p>
<h3 id="p4-相关研究的最新进展">P4 相关研究的最新进展</h3>
<p>自定义数据平面报文处理逻辑，增强数据平面可编程能力，使网络设备灵活支持各种新协议和新功能是学术界和工业界的美好愿景与努力的方向[8]，P4语言与可编程数据平面正是朝该目标迈进的一大步．但是，对于如何使硬件平台或者软件平台支持现有的P4语言、如何设计并优化编译器、如何对P4程序进行调试与性能测试等问题，P4语言联盟和P4语言规范并没有给出相应的解决方案，学术界和工业界也纷纷对可编程数据平面的落地和优化做出了一系列相关研究。</p>
<p>在硬件平台和后端编译器上，文献[9]针对P4语言首次为PMT、Intel、Flexpipe以及Cavium XPliant等可编程交换机提出了编译器设计方法，该工作主要解决了可编程交换机芯片中的匹配动作表配置问题。针对FPGA使用低级语言编程、难移植、调试复杂的问题，文献[10]设计了报文解析器生成模型以及相应的转换算法，可以将P4的解析表述图转化为适合在FPGA上部署的合成VHDL代码。</p>
<p>在软件平台与数据平面虚拟化上，文献[]基于如今最流行的软件交换机Open vSwitch（OVS）提出了可编程的，协议无关的软件交换机架构PISCES，使得软件交换机的数据包转发行为可以使用P4语言进行描述。文献[12]利用了预取和批处理两种方式对基于P4程序编译生成的软件交换机性能进行了优化，使得P4软件交换机编译器生成的代码的执行效率能够接近经过手工代码优化的软件交换机。</p>
<p>对P4进行进一步的扩展上，CacheP4[13]从缓存机制的角度出发，加快P4数据平面的数据包转发处理操作，节省了时间和数据平面资源。P4-CoDel[14]利用P4实现最新的AQM（Active Queue Management，主动队列管理）算法，以便通过AQM算法轻易的增强通信效率。</p>
<p>在应用方面，Order P4-66[15]将P4应用于网络安全领域，分析了受损的可编程设备对于网络性能下降的影响，并提出了降低损害的有效建议。MP-HULA[16]通过数据平面编程，实现传输层多路径感知负载平衡。</p>
<h2 id="6-结束语">6 结束语</h2>
<p>传统网络转发设备种类多样但彼此标准不同，网络受到功能固定的分组转发处理硬件和芯片硬件厂商不兼容协议的限制，存在网络设备更新缓慢、运行成本增加等问题。面对快速升级的网络需求和不断更新的网络业务，网络可编程的能力成为未来网络服务和应用的关键。</p>
<p>网络可编程性的概念始于主动网络研究，随着控制平面和数据平面分离等相关研究经历了几个不同的发展阶段。在SDN兴起时，网络可编程主要体现在软件定义网络的控制平面，面对超大规模网络及大流量，基于SDN控制器对网络节点提供的开放接口进行管理，实现对网络功能和行为的按需管控和新业务的快速部署。控制面可编程催生了一些新应用的产生，比如与人工智能技术结合的DDos检测[17]，以及结合深度学习技术的路由优化[18]，移动通信技术的最新发展也应用了SDN，比如基于SDN的5G[19]、6G[20]移动通信网络架构。</p>
<p>随着新一代高性能可编程数据分组处理芯片及数据平面高级编程语言的出现，以软件编程方式设定数据分组的处理流程并在芯片中编译执行成为现实。</p>
<p>当前，随着数据中心、云计算等场景的兴起，服务器端 CPU（central processing unit）的负担逐渐加重，网络接口卡（NIC, network interface card）可编程[21]成为一个新的趋势，智能网络接口卡（即Smart NIC）可以将网络虚拟化、负载均衡等功能从服务器 CPU 中卸载，从而为应用提供更多的处理能力。因此，当前网络可编程主要集中在编程语言、可编程芯片、智能网络接口卡的研究上。</p>
<p>本文回顾了可编程网络的主要发展过程，涉及早期可编程思想的来源、软件定义网络的主要架构、数据平面可编程以及可编程网络的新发展方向，在网络问题日益突出的今天，可编程网络无疑是解决各种问题的利器。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1]	黄韬,刘江,霍如,魏亮,刘韵洁.未来网络体系架构研究综述[J].通信学报,2014,35(08):184-197.</p>
<p>[2]	任高明.软件定义网络研究综述[J].信息与电脑(理论版),2020,32(04):167-169.</p>
<p>[3]	McKeown N, Anderson T, Balakrishnan H, et al. OpenFlow: enabling innovation in campus networks[J]. ACM SIGCOMM computer communication review, 2008, 38(2): 69-74.</p>
<p>[4]	Michel O, Bifulco R, Retvari G, et al. The programmable data plane: abstractions, architectures, algorithms, and applications[J]. ACM Computing Surveys (CSUR), 2021, 54(4): 1-36.</p>
<p>[5]	耿俊杰,颜金尧.基于可编程数据平面的网络体系架构综述[J].中国传媒大学学报(自然科学版),2019,26(05):38-43.DOI:10.16196/j.cnki.issn.1673-4793.2019.05.007.</p>
<p>[6]	Bosshart P, Daly D, Gibb G, et al. P4: Programming protocol-independent packet processors[J]. ACM SIGCOMM Computer Communication Review, 2014, 44(3): 87-95.</p>
<p>[7]	赵敏,田野.P4与POF协议无关可编程网络技术比较研究[J].网络新媒体技术,2018,7(01):54-58.</p>
<p>[8]	林耘森箫,毕军,周禹,张程,吴建平,刘争争,张乙然.基于P4的可编程数据平面研究及其应用[J].计算机学报,2019,42(11):2539-2560.</p>
<p>[9]	Jose L, Yan L, Varghese G, et al. Compiling packet programs to reconfigurable switches[C]//12th USENIX Symposium on Networked Systems Design and Implementation (NSDI 15). 2015: 103-115.</p>
<p>[10]	Benácek P, Pu V, Kubátová H. P4-to-vhdl: Automatic generation of 100 gbps packet parsers[C]//2016 IEEE 24th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM). IEEE, 2016: 148-155.</p>
<p>[11]	Shahbaz M, Choi S, Pfaff B, et al. Pisces: A programmable, protocol-independent software switch[C]//Proceedings of the 2016 ACM SIGCOMM Conference. 2016: 525-538.</p>
<p>[12]	Bhardwaj A, Shree A, Reddy V B, et al. A preliminary performance model for optimizing software packet processing pipelines[C]//Proceedings of the 8th Asia-Pacific Workshop on Systems. 2017: 1-7.</p>
<p>[13]	Ma Z, Bi J, Zhang C, et al. Cachep4: A behavior-level caching mechanism for p4[M]//Proceedings of the SIGCOMM Posters and Demos. 2017: 108-110.</p>
<p>[14]	Kundel R, Blendin J, Viernickel T, et al. P4-CoDel: Active queue management in programmable data planes[C]//2018 IEEE Conference on Network Function Virtualization and Software Defined Networks (NFV-SDN). IEEE, 2018: 1-4.</p>
<p>[15]	Kassing S, Abbas H, Vanbever L, et al. Order P4-66: Characterizing and mitigating surreptitious programmable network device exploitation[J]. arXiv preprint arXiv:2103.16437, 2021.</p>
<p>[16]	Benet C H, Kassler A J, Benson T, et al. Mp-hula: Multipath transport aware load balancing using programmable data planes[C]//Proceedings of the 2018 Morning Workshop on In-Network Computing. 2018: 7-13.</p>
<p>[17]	孙妍姑.SDN下基于人工智能算法的DDoS攻击检测研究[J].淮南师范学院学报,2019,21(05):135-138.</p>
<p>[18]	王桂芝,吕光宏,贾吾财,贾创辉,张建申.机器学习在SDN路由优化中的应用研究综述[J].计算机研究与发展,2020,57(04):688-698.</p>
<p>[19]	范娟.基于SDN的5G移动通信网络架构研究[J].通讯世界,2018(07):118-119.</p>
<p>[20]	王旭亮,全硕,刘增义,章军.面向6G的新型可编程网络架构研究[J].电信科学,2021,37(12):84-92.</p>
<p>[21]	Stephens B, Akella A, Swift M M. Your programmable NIC should be a programmable switch[C]//Proceedings of the 17th ACM Workshop on Hot Topics in Networks. 2018: 36-42.</p>
]]></description>
</item>
<item>
    <title>论文笔记——OpenFlow: Enabling Innovation in Campus Networks</title>
    <link>https://leeshy-tech.github.io/openflow/</link>
    <pubDate>Tue, 28 Jun 2022 17:30:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/openflow/</guid>
    <description><![CDATA[<h1 id="openflow-enabling-innovation-in-campus-networks">OpenFlow: Enabling Innovation in Campus Networks</h1>
<p>OpenFlow：实现校园网络的创新</p>
<h2 id="论文概况">论文概况</h2>
<p><a href="https://dl.acm.org/toc/sigcomm-ccr/2008/38/2" target="_blank" rel="noopener noreffer">ACM SIGCOMM Computer Communication Review</a><a href="https://dl.acm.org/toc/sigcomm-ccr/2008/38/2" target="_blank" rel="noopener noreffer">Volume 38</a><a href="https://dl.acm.org/toc/sigcomm-ccr/2008/38/2" target="_blank" rel="noopener noreffer">Issue 2</a></p>
<p>April 2008 pp 69–74</p>
<p>自翻：<a href="https://github.com/leeshy-tech/PaperTranslate/blob/main/OpenFlow.md" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/PaperTranslate/blob/main/OpenFlow.md</a></p>
<h2 id="摘要">摘要</h2>
<p>本白皮书提出了 OpenFlow：一种供研究人员在他们每天使用的网络中运行实验协议的方法。 OpenFlow 基于以太网交换机，具有内部流表和用于添加和删除流条目的标准化接口。我们的目标是鼓励网络供应商将 OpenFlow 添加到他们的交换机产品中，以部署在大学校园骨干网和配线间中。我们认为 OpenFlow 是一种务实的折衷方案：一方面，它允许研究人员以统一的方式以线速和高端口密度在异构交换机上运行实验；另一方面，供应商不需要公开其交换机的内部工作原理。除了允许研究人员在现实世界的流量设置中评估他们的想法外，OpenFlow 还可以作为一个有用的校园组件，用于提议的大规模测试平台（如 GENI）。斯坦福大学的两座建筑物将很快使用商用以太网交换机和路由器运行 OpenFlow 网络。我们将努力鼓励在其他学校部署；我们鼓励您也考虑在您的大学网络中部署 OpenFlow。</p>
<h2 id="1-对可编程网络的需求">1. 对可编程网络的需求</h2>
<p>今天，几乎没有实用的方法可以在足够现实的环境（例如，大规模承载真实流量）中试验新的网络协议（例如，新的路由协议或 IP 的替代方案）以获得广泛部署所需的信心。 结果是来自网络研究社区的大多数新想法都未经尝试和测试。 因此，人们普遍认为网络基础设施已经“僵化”。</p>
<p>认识到这个问题后，网络社区正在努力开发可编程网络，例如 GENI [1]，这是一个提议的全国性研究机构，用于试验新的网络架构和分布式系统。 这些可编程网络需要可编程交换机和路由器（使用虚拟化）可以同时处理多个隔离实验网络的数据包。</p>
<p>虚拟化可编程网络可以降低新想法的进入门槛，提高网络基础设施的创新速度。 但全国性设施的计划雄心勃勃（而且成本高昂），部署起来需要数年时间。 本白皮书关注一个离家更近的短期问题：作为研究人员，我们如何在校园网络中进行实验？ 如果我们能弄清楚这个问题，我们可以很快开始并将该技术扩展到其他校园，以造福整个社区。</p>
<p>我们的目标是提出一种新的交换机功能，可以帮助将可编程性扩展到大学校园的配线间。</p>
<ul>
<li>
<p>一种我们不采用的方法是说服商业设备供应商在他们的交换机和路由器上提供一个开放的、可编程的、虚拟化平台，以便研究人员可以部署新协议，而网络管理员不用担心设备的支持问题。这种结果在短期内不太可能发生。</p>
</li>
<li>
<p>一些开放的软件平台已经存在，但没有我们需要的性能或端口密度。</p>
</li>
<li>
<p>具有用于线速处理的专用硬件的现有平台也不太适合大学布线室。</p>
</li>
</ul>
<p>因此，商业解决方案过于封闭和不灵活，研究解决方案要么性能不足或扇出，要么过于昂贵。具有完全通用性的研究解决方案似乎不太可能克服其性能或成本限制。一种更有希望的方法是在通用性上妥协并寻求一定程度的开关灵活性，即：</p>
<ul>
<li>适合高性能和低成本的实施。</li>
<li>能够支持广泛的研究。</li>
<li>确保将实验流量与生产流量隔离开来。</li>
<li>符合供应商对封闭平台的需求。</li>
</ul>
<p>本文描述了 OpenFlow 交换机 — 一种最初尝试满足这四个目标的规范。</p>
<h2 id="2-openflow交换机">2. OpenFlow交换机</h2>
<p>基本思想很简单：我们利用大多数现代以太网交换机和路由器包含以线速运行的流表（通常由 TCAM 构建）来实现防火墙、NAT、QoS 和收集统计数据。虽然每个供应商的流表都不同，但我们已经确定了一组有趣的通用功能，可在许多交换机和路由器中运行。</p>
<p>OpenFlow 利用了这组通用功能。 OpenFlow 提供了一个开放协议来对不同交换机和路由器中的流表进行编程。网络管理员可以将流量划分为生产和研究流。研究人员可以通过选择他们的数据包遵循的路线和他们接收的处理来控制他们自己的流量。通过这种方式，研究人员可以尝试新的路由协议、安全模型、寻址方案，甚至是 IP 的替代方案。在同一个网络上，生产流量被隔离并以与今天相同的方式进行处理。</p>
<p>OpenFlow 交换机的数据路径由流表和与每个流条目关联的操作组成。 OpenFlow 交换机支持的操作集是可扩展的，但下面我们描述了所有交换机的最低要求。为了实现高性能和低成本，数据路径必须具有精心规定的灵活性。这意味着放弃指定任意处理每个数据包的能力，并寻求更有限但仍然有用的操作范围。因此，在本文后面，为所有 OpenFlow 交换机定义一组基本的必需操作。</p>
<p>一个 OpenFlow 交换机至少由三部分组成：（1）流表，与每个流条目相关联的动作，用于告诉交换机如何处理流，（2）将交换机连接到远程控制程序（称为控制器）的安全通道，它在控制器和交换机之间发送命令和数据包，使用 (3) OpenFlow 协议，该协议为控制器与交换机通信提供了一种开放和标准的方式。 通过指定一个标准接口（开放流协议），流表中的条目可以通过该接口在外部定义，开放流交换机避免了研究人员对交换机进行编程的需要。</p>
<p><strong>专用OpenFlow交换机。</strong> 专用 OpenFlow 交换机是在端口之间转发数据包的哑数据路径元素，由远程控制程序定义。 图 1 显示了 OpenFlow 交换机的示例。</p>
<p></p>
<p>在这种情况下，流被广泛定义，并且仅受流表的特定实现的能力的限制。 例如，一个流可以是一个 TCP 连接，或来自特定 MAC 地址或 IP 地址的所有数据包，或具有相同 VLAN 标记的所有数据包，或来自同一交换机端口的所有数据包。 对于涉及非 IPv4 数据包的实验，可以将流定义为与特定（但非标准）标头匹配的所有数据包。</p>
<p>每个流条目都有一个与之关联的简单动作； 三个基本的（所有专用 OpenFlow 交换机都必须支持）是：</p>
<ol>
<li>将此流的数据包转发到给定端口（或多个端口）。 这允许数据包通过网络进行路由。 在大多数交换机中，这预计将在线性速率下发生。</li>
<li>封装此流的数据包并将其转发给控制器。 数据包被传递到安全通道，在那里它被封装并发送到控制器。 通常用于新流中的第一个数据包，因此控制器可以决定是否应将流添加到流表中。 或者在某些实验中，它可以用于将所有数据包转发到控制器进行处理。</li>
<li>丢弃该流的数据包。 可用于安全、遏制拒绝服务攻击或减少来自终端主机的虚假广播发现流量。</li>
</ol>
<p>Flow-Table 中的条目具有三个字段：（1）定义流的数据包头，（2）定义应如何处理数据包的操作，以及（3）统计数据，跟踪数据包的数量。 每个流的数据包和字节，以及自最后一个数据包与流匹配的时间（以帮助删除非活动流）。</p>
<p>在第一代“Type 0”交换机中，流标头是一个 10 元组，如表 1 所示。TCP 流可以由所有十个字段指定，而 IP 流可能不包括其定义中的传输端口。 每个标头字段可以是通配符，以允许聚合流，例如仅定义 VLAN ID 的流将应用于特定 VLAN 上的所有流量。</p>
<p></p>
<p><strong>OpenFlow使能的交换机。</strong> 一些商用交换机、路由器和接入点将通过添加流表、安全通道和 OpenFlow 协议来增强 OpenFlow 功能（我们在第 5 节中列出了一些示例）。 通常，流表将重用现有硬件，例如 TCAM； 安全通道和协议将被移植以在交换机的操作系统上运行。 图 2 显示了支持 OpenFlow 的商业交换机和接入点网络。 在这个例子中，所有的流表都由同一个控制器管理； OpenFlow 协议允许交换机由两个或多个控制器控制，以提高性能或鲁棒性。</p>
<p></p>
<p>我们的目标是使实验能够在现有的生产网络中与常规流量和应用程序一起进行。 因此，为了赢得网络管理员的信任，启用 OpenFlow 的交换机必须将实验流量（由 Flow Table 处理）与将由交换机的正常第 2 层和第 3 层管道处理的生产流量隔离开来。 有两种方法可以实现这种分离。 一种是添加第四个动作：</p>
<ol start="4">
<li>通过交换机的正常处理管道转发此流的数据包。</li>
</ol>
<p>另一种是为实验和生产流量定义单独的 VLAN 集。 这两种方法都允许交换机以通常的方式处理不属于实验的正常生产流量。 所有启用 OpenFlow 的交换机都需要支持一种方法或另一种方法； 有些人会同时支持两者。</p>
<p><strong>额外的特性。</strong> 如果交换机支持报头格式和上面提到的四个基本操作（在 OpenFlow 交换机规范中有详细说明），那么我们称其为“Type 0”交换机。 我们预计许多交换机将支持其他操作，例如重写部分数据包头（例如，用于 NAT，或混淆中间链路上的地址），并将数据包映射到优先级类别。 同样，一些流表将能够匹配数据包头中的任意字段，从而可以使用新的非 IP 协议进行实验。 随着一组特定功能的出现，我们将定义一个“Type 1”开关。</p>
<p><strong>控制器。</strong> 控制器代表实验从流表中添加和删除流条目。 例如，静态控制器可能是在 PC 上运行的简单应用程序，用于在实验期间静态建立流以互连一组测试计算机。 在这种情况下，流类似于当前网络中的 VLAN——提供一种简单的机制来将实验流量与生产网络隔离。 从这个角度来看，OpenFlow 是 VLAN 的泛化。</p>
<p>人们还可以想象更复杂的控制器，它们会随着实验的进行动态地添加/删除流。 在一个使用模型中，研究人员可以控制整个 OpenFlow 交换机网络，并可以自由决定如何处理所有流。 更复杂的控制器可能支持多个研究人员，每个研究人员具有不同的帐户和权限，使他们能够在不同的流程集上运行多个独立的实验。 识别为在特定研究人员控制下的流（例如，通过在控制器中运行的策略表）可以传送到研究人员的用户级控制程序，然后由该程序决定是否应将新的流条目添加到交换机网络 .</p>
<h2 id="3-使用openflow">3. 使用OpenFlow</h2>
<p>例子略</p>
<p>关于随着实验的进行动态添加和删除流的控制器的性能、可靠性和可扩展性，有一些合理的问题要问：这样的集中式控制器能否足够快地处理新流和对流开关进行编程？当控制器发生故障时会发生什么？在某种程度上，这些问题在 Ethane 原型的背景下得到解决，该原型使用简单的流量交换机和中央控制器 [7]。初步结果表明，基于低成本台式 PC 的 Ethane 控制器每秒可以处理超过 10,000 个新流量，足以满足大型大学校园的需求。当然，新流的处理速度将取决于研究人员实验所需的处理复杂性。但这让我们相信可以进行有意义的实验。通过使控制器（和实验）无状态，可以实现可扩展性和冗余，允许在多个单独的设备上进行简单的负载平衡。</p>
<h2 id="31-生产网络上的实践">3.1 生产网络上的实践</h2>
<p>很有可能，Amy正在许多其他人使用的网络中测试她的新协议。 因此，我们希望网络具有两个额外的属性：</p>
<ol>
<li>属于 Amy 以外的用户的数据包应该使用在交换机或路由器中运行的标准且经过测试的路由协议进行路由，该协议运行在“知名品牌”供应商的交换机或路由器中。</li>
<li>Amy 应该只能为她的流量或她的网络管理员允许她控制的任何流量添加流条目。</li>
</ol>
<p>属性 1 是通过启用 OpenFlow 的交换机实现的。在 Amy 的实验中，所有不是来自 Amy 的 PC 的数据包的默认操作可能是通过正常的处理管道转发它们。 Amy 自己的数据包将直接转发到传出端口，而无需经过正常管道处理。</p>
<p>属性 2 取决于控制器。控制器应该被视为一个平台，使研究人员能够进行各种实验，而Property 2的限制可以通过适当使用权限或其他方式来限制单个研究人员控制流入口的权力来实现。这些类似权限的机制的确切性质将取决于控制器的实现方式。我们预计会出现各种各样的控制器。作为控制器具体实现的一个例子，一些作者正在开发一种称为 NOX 的控制器，作为 Ethane 工作的后续[8]。通过将 GENI 管理软件扩展到 OpenFlow 网络，可能会出现一个完全不同的控制器。</p>
<h2 id="32-更多实例">3.2 更多实例</h2>
<p>与任何实验平台一样，这组实验将超过我们可以预先想到的那些——OpenFlow 网络中的大多数实验还有待考虑。 在这里，为了说明，我们提供了一些示例，说明如何使用支持 OpenFlow 的网络来试验新的网络应用程序和架构。</p>
<ul>
<li>实验1：网络管理和接入控制。</li>
<li>实验2:VLAN。</li>
<li>实验3：移动无线VOIP客户端。</li>
<li>实验4：无IP网络。</li>
<li>实验5：处理包而不是流。</li>
</ul>
<p>在支持 OpenFlow 的网络中处理数据包有两种基本方法。 首先，也是最简单的，是强制所有流的数据包通过控制器。 为此，控制器不会将新的流条目添加到流交换机中——它只是允许交换机默认将每个数据包转发到控制器。 这具有灵活性的优势，但以性能为代价。 它可能为测试新协议的功能提供了一种有用的方法，但对于在大型网络中的部署不太可能引起人们的兴趣。</p>
<p>处理数据包的第二种方法是将它们路由到进行数据包处理的可编程交换机——例如，基于 NetFPGA 的可编程路由器。 优点是可以以用户定义的方式以线速处理数据包； 图 3 显示了如何做到这一点的示例，其中支持 OpenFlow 的交换机本质上作为一个接线板运行，以允许数据包到达 NetFPGA。 在某些情况下，NetFPGA 板（插入 Linux PC 的 PCI 板）可能会放置在支持 OpenFlow 的交换机旁边的配线柜中，或者（更有可能）放在实验室中。</p>
<p></p>
<h2 id="4--openflow联盟">4.  OpenFlow联盟</h2>
<h2 id="5-部署openflow交换机">5. 部署OpenFlow交换机</h2>
<h2 id="6-结论">6. 结论</h2>
<p>我们认为 OpenFlow 是一种务实的折衷方案，它允许研究人员以统一的方式在异构交换机和路由器上运行实验，而无需供应商公开其产品的内部工作原理，也无需研究人员编写供应商特定的控制软件。</p>
<p>如果我们在校园中成功部署 OpenFlow 网络，我们希望 OpenFlow 将逐渐在其他大学中流行起来，增加支持实验的网络数量。 我们希望出现新一代的控制软件，让研究人员能够重复使用控制器和实验，并在他人工作的基础上再接再厉。 随着时间的推移，我们希望不同大学的 OpenFlow 网络孤岛将通过隧道和覆盖网络相互连接，也许还可以通过在连接大学彼此的骨干网络中运行的新 OpenFlow 网络相互连接。</p>
]]></description>
</item>
<item>
    <title>SDN十篇推荐论文</title>
    <link>https://leeshy-tech.github.io/sdn_paper_recom/</link>
    <pubDate>Mon, 27 Jun 2022 17:31:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/sdn_paper_recom/</guid>
    <description><![CDATA[<h1 id="sdn十篇推荐论文">SDN十篇推荐论文</h1>
<blockquote>
<p>推荐论文来自BUPT课程“软件定义网络”</p>
</blockquote>
<h2 id="1988the-design-philosophy-of-the-darpa-internet-protocols">(1988)The Design Philosophy of the DARPA Internet Protocols</h2>
<p>DARPA互联网协议的设计哲学</p>
<p>​	Internet 协议套件 TCP/IP 于 15 年前首次提出。 它由国防高级研究计划局 (DARPA) 开发，并已广泛用于军事和商业系统。 虽然有描述协议如何工作的论文和规范，但有时很难从中推断出协议为何如此。 例如，Internet 协议基于无连接或数据报服务模式。 这样做的动机被大大误解了。 本文试图捕捉形成 Internet 协议的一些早期推理。</p>
<h2 id="2005overcoming-the-internet-impasse-through-virtualization">(2005)Overcoming the Internet Impasse through Virtualization</h2>
<p>通过虚拟化克服互联网僵化</p>
<p>当前的互联网陷入僵局，因为新架构无法部署，甚至无法进行充分评估。 本文敦促社区正视这一僵局，并提出一种可以使用虚拟化来克服它的方法。 在这个过程中，我们讨论了建筑的本质以及纯粹主义者和多元主义者之间的争论。</p>
<p>提出使用网络虚拟化技术改变互联网技术革新模式。</p>
<h2 id="2005a-clean-slate-4d-approach-to-network-control-and-management">(2005)A Clean Slate 4D Approach to Network Control and Management</h2>
<p>网络控制和管理的全新 4D 方法</p>
<p>​	当今的数据网络异常脆弱且难以管理。我们认为，这些问题的根源在于控制和管理平面的复杂性——协调网络元素的软件和协议——尤其是决策逻辑和分布式系统问题不可避免地交织在一起的方式。我们提倡对功能进行完全重构，并提出三个关键原则——网络级目标、网络范围的视图和直接控制——我们认为这些原则应该是新架构的基础。遵循这些原则，我们在架构的四个平面（决策、传播、发现和数据）之后确定了一个我们称之为“4D”的极端设计点。 4D 架构将 AS 的决策逻辑与管理网络元素之间交互的协议完全分开。 AS 级目标在决策平面中指定，并通过直接配置驱动数据平面如何转发数据包的状态来强制执行。在 4D 架构中，路由器和交换机只是按照决策平面的要求转发数据包，并收集测量数据以帮助决策平面控制网络。尽管 4D 会对当今的控制和管理平面进行重大更改，但数据包的格式不需要更改；这简化了 4D 架构的部署路径，同时仍然实现了网络控制和管理方面的重大创新。我们希望探索一个极端的设计点将有助于将研究和工业界的注意力集中在这个至关重要且具有智力挑战性的领域上。</p>
<ul>
<li>
<p>解决现有互联网问题的最大困难是分布式系统问题和决策逻辑缠绕在一起。</p>
</li>
<li>
<p>4D技术路线的要义就是分离<strong>分布式计算问题(Distributed Computing Issue)</strong></p>
<p>和<strong>组网逻辑问题(Networking Issue)。</strong></p>
</li>
</ul>
<h2 id="2007ethane-taking-control-of-the-enterprise">(2007)Ethane: Taking Control of the Enterprise</h2>
<p>早期SDN原型</p>
<p>本文介绍了 Ethane，一种适用于企业的新网络架构。 Ethane 允许管理人员定义一个单一的网络范围的细粒度策略，然后直接执行它。 Ethane 将极其简单的基于流的以太网交换机与管理流的准入和路由的集中控制器相结合。 虽然激进，但这种设计向后兼容现有的主机和交换机。 我们已经在硬件和软件中实现了 Ethane，支持有线和无线主机。 在过去的四个月里，我们运营的 Ethane 网络在斯坦福大学的网络中支持了 300 多台主机，这种部署经验对 Ethane 的设计产生了重大影响。</p>
<h2 id="2008openflow-enabling-innovation-in-campus-networks">(2008)OpenFlow: Enabling Innovation in Campus Networks</h2>
<p>​	本白皮书提出了 OpenFlow：一种供研究人员在他们每天使用的网络中运行实验协议的方法。 OpenFlow 基于以太网交换机，具有内部流表和用于添加和删除流条目的标准化接口。我们的目标是鼓励网络供应商将 OpenFlow 添加到他们的交换机产品中，以部署在大学校园骨干网和配线间中。我们认为 OpenFlow 是一种务实的折衷方案：一方面，它允许研究人员以统一的方式以线速和高端口密度在异构交换机上运行实验；另一方面，供应商不需要公开其交换机的内部工作原理。除了允许研究人员在现实世界的流量设置中评估他们的想法外，OpenFlow 还可以作为一个有用的校园组件，用于提议的大规模测试平台（如 GENI）。斯坦福大学的两座建筑物将很快使用商用以太网交换机和路由器运行 OpenFlow 网络。我们将努力鼓励在其他学校部署；我们鼓励您也考虑在您的大学网络中部署 OpenFlow。</p>
<h2 id="2013on-scalability-of-software-defined-networking">(2013)On Scalability of Software-Defined Networking</h2>
<p>论软件定义网络的可扩展性</p>
<p>在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是 SDN 独有的。 我们探讨了不同环境中经常出现的问题，讨论了 SDN 设计空间中的可扩展性权衡，并介绍了一些关于 SDN 可扩展性的最新研究。 此外，我们列举了超出常用性能指标的可扩展性方面被忽视但重要的机遇和挑战。</p>
<h2 id="2013improving-network-management-with-software-defined-networking">(2013)Improving Network Management with Software Defined Networking</h2>
<p>使用软件定义网络改进网络管理</p>
<p>​	网络管理具有挑战性。为了操作、维护和保护通信网络，网络运营商必须处理低级别的供应商特定配置，以实施复杂的高级网络策略。尽管之前提出了许多使网络更易于管理的建议，但由于难以改变底层基础设施，许多网络管理问题的解决方案都只是权宜之计。底层基础设施的僵化几乎没有创新或改进的可能性，因为网络设备通常是封闭的、专有的和垂直集成的。一种新的网络范式，软件定义网络（SDN），主张将数据平面和控制平面分离，使数据平面中的网络交换机成为简单的数据包转发设备，并留下一个逻辑集中的软件程序来控制整个网络的行为。 SDN 为网络管理和配置方法引入了新的可能性。在本文中，我们确定了当前最先进的网络配置和管理机制存在的问题，并介绍了改进网络管理各个方面的机制。我们关注网络管理中的三个问题：实现网络条件和状态的频繁更改，以高级语言提供网络配置支持，以及为执行网络诊断和故障排除的任务提供更好的可见性和控制。我们描述的技术使网络运营商能够以高级策略语言实施广泛的网络策略，并轻松确定性能问题的根源。除了系统本身，我们还描述了校园和家庭网络中的各种原型部署，展示了 SDN 如何改进常见的网络管理任务。</p>
<h2 id="2014a-survey-of-software-defined-networking-past-present-and-future-of-programmable-networks">(2014)A Survey of Software-Defined Networking: Past, Present, and Future of Programmable Networks</h2>
<p>软件定义网络调查：可编程网络的过去、现在和未来</p>
<p>综述了可编程网络的最新进展，重点介绍了SDN。提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。</p>
<h2 id="2014software-defined-networking-a-comprehensive-survey">(2014)Software-Defined Networking: A Comprehensive Survey</h2>
<p>在本文中，我们对 SDN 进行了全面调查。我们首先介绍 SDN 的动机，解释它的主要概念以及它与传统网络的区别、它的根源以及关于这种新颖范式的标准化活动。接下来，我们使用自下而上的分层方法展示 SDN 基础设施的关键构建块。我们对硬件基础设施、南向和北向 API、网络虚拟化层、网络操作系统（SDN 控制器）、网络编程语言和网络应用程序进行了深入分析。我们还研究了调试和故障排除等跨层问题。为了预测这种新范式的未来发展，我们讨论了 SDN 的主要正在进行的研究工作和挑战。特别是，我们解决了交换机和控制平台的设计——重点关注弹性、可扩展性、性能、安全性和可靠性等方面——以及运营商传输网络和云提供商的新机遇。最后但同样重要的是，我们分析了 SDN 作为软件定义环境的关键推动者的地位。</p>
<h2 id="2014p4-programming-protocol-independent-packet-processors">(2014)P4: Programming Protocol-Independent Packet Processors</h2>
<p>P4：编写协议无关的包处理器</p>
<p>​	P4 是一种用于编程独立于协议的包处理器的高级语言。 P4 与 OpenFlow 等 SDN 控制协议结合使用。 在目前的形式中，OpenFlow 明确指定了它所操作的协议头。 这组在几年内从 12 个字段增长到 41 个字段，增加了规范的复杂性，同时仍然不能提供添加新标头的灵活性。 在本文中，我们提出 P4 作为 OpenFlow 未来应该如何发展的草案建议。 我们有三个目标： (1) 现场可重构性：一旦部署，程序员应该能够改变交换机处理数据包的方式。 (2) 协议独立性：交换机不应与任何特定的网络协议绑定。 (3) 目标独立性：程序员应该能够独立于底层硬件的细节来描述数据包处理功能。 作为示例，我们描述了如何使用 P4 来配置交换机以添加新的分层标签。</p>
]]></description>
</item>
<item>
    <title>论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.</title>
    <link>https://leeshy-tech.github.io/paper_wireless_sdn_mobile/</link>
    <pubDate>Thu, 03 Mar 2022 14:18:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/paper_wireless_sdn_mobile/</guid>
    <description><![CDATA[<h1 id="wireless-sdn-mobile-ad-hoc-networkfrom-theory-to-practice">Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.</h1>
<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/7996340" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/7996340</a></p>
<p><a href="https://ieeexplore.ieee.org/xpl/conhome/7985734/proceeding" target="_blank" rel="noopener noreffer">2017 IEEE International Conference on Communications (ICC)</a></p>
<p>自翻：<a href="https://github.com/leeshy-tech/PaperTranslate/blob/main/wireless_SDN_mobile.md" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/PaperTranslate/blob/main/wireless_SDN_mobile.md</a></p>
<h2 id="重要的名词">重要的名词</h2>
<p>D2D （device to device） MANET （移动自组织网络）   VANET（车辆自组织网络）</p>
<p>本地流量：信息流的源和目的距离很近的数据连接。</p>
<h2 id="引言">引言</h2>
<p>根据思科[1]最近的一份报告，通过无线网络传输的数据流量正在不断增加，不久将超过有线流量。在未来的5G场景中，无线流量的模式将对本地流量产生越来越大的需求。</p>
<p>使用当前的网络标准，即使是本地数据也要通过蜂窝网络传输到一个集中的实体，然后再重新分发。对于本地流量的交换来说，这种方法显然不是最优的。一种更有前途的方法依赖于设备到设备(D2D)技术[4]，其中设备可以在MANET或者VANET[6]中以分布式方式组织。</p>
<p>在没有集中控制的情况下，每个节点必须独立行动，做出路由决策，并在移动网络中动态地适应快速变化的拓扑结构。前人提出了一些解决方案：</p>
<ul>
<li>按需距离矢量(AODV)协议，它仅在需要时才寻找路由路径，适合流量偶发的场景。</li>
<li>优化的链路状态路由（OLSR）协议，当几个源-目的对之间的流量比较正常的情况下，预先定义网络中每个可能的节点对之间的路由的主动协议。</li>
<li>区域路由（ZRP）协议，将网络划分为多个集群，如果源节点和目的节点在同一个集群中，则使用OLSR等主动路由策略;否则，采用反应性策略，如AODV。</li>
</ul>
<p>OLSR的主要问题：它需要节点之间频繁的控制消息交换，以维护每个节点上更新的网络拓扑。ZRP能够显著减少控制消息的数量，因为更新的拓扑信息只需要在每个集群中的节点之间进行维护，但是当一个包被发送到一个属于不同集群的节点时，会引入显著的延迟，因为新的路径应该以响应式的方式搜索。</p>
<p>在节点具有移动性的条件下，必须在减少开销（网络中交换的控制信息）和完全掌握网络拓扑之间做出权衡，如果要设计更好的传输路线，则要更频繁地交换控制信息，不仅耗费了更多的带宽资源，而且也增加了设备的处理压力。</p>
<p>为了适应这种网络不断变化的移动特性，我们参考SDN范例，将数据平面（包括节点之间本地交换的所有数据流量）与控制平面（包括所有的控制报文和本地路由决策）隔开。他们实现的结构是，设备中有两个用于 DP （data plane）和 CP（control plane） 的无线接口，设备以星形拓扑结构与集中式单元CU连接，CU以集中的方式做出路由决策，几乎实时地了解拓扑。这个框架的两个主要优点：</p>
<ul>
<li>ad hoc网络中引入的开销是最小的,每个节点只需要知道它的邻居并且把该信息传给CU。</li>
<li>根本上减少了每个节点的复杂性,因为路由算法运行在CU。</li>
</ul>
<h2 id="sdn-manet的结构">SDN MANET的结构</h2>
<ul>
<li>
<p>DP MAC协议：采用了ieee802.11的P2P模式独立基本服务集(IBSS)[16]，这是ieee802.11的特设模式标准，根据我们的方法的需要，将交换能力完全控制给上层。</p>
</li>
<li>
<p>SDN协议：OpenFlow。</p>
</li>
<li>
<p>无线交换机：Open vSwitch (OVS)。</p>
</li>
<li>
<p>控制器：ON开发的Open Network Operating System (ONOS)。</p>
</li>
<li>
<p>平台：Rasp berry Pi(树莓派)Model B+，Linux操作系统</p>
</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="修改mac头">修改MAC头</h3>
<p>为了实现SDN架构，需要修改交换机设备的Linux内核，允许CU直接控制节点的路由。</p>
<p></p>
<p>图中左侧为标准 Linux 内核协议栈中从物理层 (PHY) 到应用层 (APP) 的逻辑数据流，</p>
<p>以太网帧通过铜缆（在 PHY 层）到达设备，并被发送到以太网驱动程序（在 MAC 层），在删除 PHY 标头并将它们发送到以太网堆栈之前检查它们的完整性。 在以太网堆栈中，在将数据包发送到路由所在的 NET 层之前，MAC 标头也被删除。</p>
<p>如果从无线接口接收到 Wi-Fi 数据包，则数据包首先被发送到 Wi-Fi 驱动程序，在那里去除 PHY 包头，然后由特定模块处理，将 Wi-Fi 数据包转换为以太网数据包，随后被发送到以太网堆栈。</p>
<p>在 SDN 块中，数据报可以根据从 SDN 控制器接收到的规则进行修改。 特别是，为了控制路由路径，SDN控制器强加的规则涉及修改相应数据报的MAC头。 在这些修改之后，数据报将被发送回 SDN 网桥，并转发到以太网堆栈进行与左侧情况相同的处理。</p>
<h3 id="多跳过程分析">多跳过程分析</h3>
<p>如图所示，涉及从源节点（S）到目的地 (D)的两跳传输。 数据包由 S 生成。它首先传输到辅助节点 (H)，然后由 H 中继到 D。</p>
<p></p>
<ul>
<li>数据包由主机 S (hS) 生成，它在 IP 报头和 MAC 报头中指定目标主机 D (hD) 的地址。 hS 不知道到达 hD 所需的任何路由信息。 它只是通过有线信道将数据包传输到节点 S (sS) 的交换机，该交换机负责无线传输它。</li>
<li>sS 正在运行 SDN 模块，该模块根据从 SDN 控制器接收到的指令修改 MAC 层的源地址和目标地址。 MAC头中的源和目的地分别变成sS和sH（节点H的交换机）。 然后，数据包可以被 sS 发送，也可以被 sH 接收。</li>
<li>由于数据包中的目的MAC地址为sH，因此数据包由sH进一步处理，并向sS发回确认（ACK）。sH 执行类似的过程，修改目的MAC地址，数据包可以被转发到目的节点（sD）的交换机。</li>
<li>最后，sD 根据来自 SDN 控制器的另一条规则，将源 MAC 地址和目标 MAC 地址分别修改为 hS 和 hD。 这个过程，称为 MAC 恢复，是必要的，以便 hD 识别数据包是由 hS 发送的，而不需要来自 SDN 框架的任何进一步信息。</li>
</ul>
<blockquote>
<p>对于大多数 Wi-Fi 适配器，如果 固件的MAC 和目的地不匹配，则固件中会丢弃数据包，因此修改 MAC 地址是多跳传送数据包的必要步骤。</p>
</blockquote>
<h2 id="平台测试性能比较">平台测试：性能比较</h2>
<h3 id="网络设置">网络设置</h3>
<p></p>
<p>实验场景由具有三个 SDN 节点的 SDN MANET 组成，标记为 S、H 和 D，如上一节所示，部署如图所示。每个节点由一个 RPi Model B+ 和一个 Wi -Fi 适配器（Ralink RT5370 USB）组成，DP 中的传输使用 IEEE 802.11g ad-hoc 模式。 三个 SDN 节点配备了 OVS-2.4.0，并连接到运行 ONOS 控制器的 CU 和我们的 MANET 应用程序 [12]。</p>
<p>第二个网络名为 OLSR MANET，它使用相同位置和相同拓扑的相同三个节点（S、H 和 D）进行比较。 实际上，在第二个网络中，节点没有配备我们的 SDN 框架，但它们正在运行分布式路由策略 OLSR。</p>
<p>在这两个网络中，数据流量都是在节点 S 使用流量生成器 iPerf3 [35] 生成的，该流量生成器会创建一个随机 TCP 流，流向目的地节点 D。实验时间为 N 秒，时间间隔为 1秒。 对于每个间隔 τn，n = 1,&hellip;,N，端到端吞吐量以每秒比特 (bps) 为单位测量为：
$$
T\left(\tau_{n}\right)=\frac{\text { TCP } \text { RWND } \times 8}{\text { RTT }}
$$
其中 TCP RWND 是间隔 τi 期间 TCP 会话的平均接收窗口大小，RTT 是平均往返时间，即从发送的 TCP 段的第一个比特传输到接收到该 TCP 段的 TCP ACK的最后一个比特所经过的时间。</p>
<p>为了比较 SDN MANET 和 OLSR MANET 在拓扑突然变化的情况下的行为，我们改变了图a的全连接拓扑为图b的多跳拓扑（S和D之间没有直接连接）。实现的方法是，在节点的 MAC 层设计一个模块来模拟 S 和 D 之间的链路故障，该模块可以拒绝来自 S 的所有数据包（对于 节点 D），或来自 D（对于节点 S）。 这样，我们可以在我们的实验中完美地控制 S 和 D 之间的链路何时发生故障，或者何时重新启动。</p>
<p>对于 SDN MANET 和 OLSR MANET，每个实验重复 M = 20 次。 结果中显示的平均吞吐量为：
$$
\bar{T}\left(\tau_{n}\right)=\frac{\sum_{m=1}^{M} T_{m}\left(\tau_{n}\right)}{M}
$$
其中 Tm(τn) 是第 m 次实验在时间间隔 τn 期间获得的吞吐量。</p>
<h3 id="链路断开实验">链路断开实验</h3>
<p></p>
<p>在时间 t = 10，S 和 D 之间的直接链路发生故障。 SDN控制器立即收到此事件的通知，并迅速做出反应，将新的SDN规则强加给节点S和H。这样，节点S将所有发往D的数据包发送给H，H将这些数据包转发给D。 SDN MANET 的吞吐量立即恢复到初始吞吐量的一半，因为从 S 到 D 的新路径现在有两跳。</p>
<p>OLSR MANET 能够识别链路故障并通过仅在 t = 25 时将路径更改为 D 来对其做出反应，延迟约 15 秒，从而导致严重的吞吐量中断。 这个结果是意料之中的，因为 OLSR 有一个完全分布式的路由算法，它需要大量时间来更新。</p>
<h3 id="连接实验">连接实验</h3>
<p></p>
<p>在第二个实验中，我们观察了当初始拓扑是图b中的拓扑时，SDN MANET 和 OLSR MANET 经历的平均吞吐量，即 S 和 D 之间的两跳路径。 在 t = 10 时，S 和 D 之间的直接链接也被激活，如图a所示。 正如预期的那样，我们观察到，在 SDN MANET 的情况下，网络能够迅速对拓扑的变化做出反应，并且吞吐量在 t &gt; 10 时几乎翻了一番。另一方面，OLSR MANET 的延迟约为 20 秒。</p>
<h3 id="快速变化拓扑实验">快速变化拓扑实验</h3>
<p></p>
<p>在第三个实验中，有一系列连续的拓扑变化。 在 t = 0 时，拓扑是图a中的拓扑（S 和 D 之间有直接链路），然后在 t = 30 时，拓扑变为图b中的拓扑（两跳） ，然后在 t = 60 时再次切换到图a，最后在 t = 90 时切换到图b。</p>
<p>同样在这种情况下，实验重复 20 次，结果取所有试验的平均值。 对于每个拓扑变化，我们观察到 SDN MANET 如何能够几乎立即对拓扑变化做出反应，而 OLSR MANET 对变化的反应有一定的延迟，正如预期的那样，会导致显著的吞吐量损失。</p>
<h2 id="结论">结论</h2>
<p>在这项工作中，我们提出了一个 SDN MANET 的实际实现，它提供了 D2D 数据传输的所有优点，同时具有集中网络管理的灵活性。</p>
<p>为了展示 SDN MANET 的优势以及所提供的所有软件的有效性，我们将我们的 SDN MANET 与以分布式方式管理的 ad hoc 网络进行了比较。 我们用几个简单的例子强调了我们方法的显着优势，特别是对于快速变化的网络拓扑。</p>
<p>在未来的工作中，我们计划处理大规模的 SDN MANET，解决可能出现的可扩展性问题。</p>
]]></description>
</item>
<item>
    <title>论文笔记——On Scalability of SDN</title>
    <link>https://leeshy-tech.github.io/on_scalability_of_sdn_note/</link>
    <pubDate>Tue, 18 Jan 2022 23:09:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/on_scalability_of_sdn_note/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6461198" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/6461198</a><br>
IEEE Communications Magazine  <br>
Volume 51 Issue 2</p>
<h2 id="摘要">摘要</h2>
<p>在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是SDN所独有的。我们探讨了在不同环境中经常出现的问题，讨论了SDN设计空间中可扩展性的权衡，并介绍了一些关于SDN可扩展性的最新研究。此外，我们还列举了在可扩展性方面的重要机遇和挑战。</p>
<h2 id="引言">引言</h2>
<p>普遍认为SDN中的控制是集中的，这导致了对SDN可伸缩性和弹性的关注。毕竟，无论控制器的能力如何，中央控制器都不会随着网络的增长而扩展(增加交换机、流量、带宽等的数量)，并且在提供相同的服务保证的同时也无法处理所有传入的请求。此外，由于大多数早期的SDN提议都是基于流的，额外的流启动延迟成为一个问题。  <br>
我们认为SDN的可扩展性没有固有的瓶颈;我们认为这些可扩展性限制并不局限于SDN;传统的控制协议设计也面临着同样的挑战。虽然这并没有解决这些问题，但这表明我们在SDN中不需要比在传统网络中更担心可扩展性。</p>
<h2 id="sdn中可扩展性的根源">SDN中可扩展性的根源</h2>
<p>SDN与传统数据网络的根本区别在于控制与转发平面的分离。这种解耦导致了一些有趣的特性。  <br>
然而，这种解耦也有它自己的陷阱。在这两个平面之间定义一个标准的API是绝对重要的。从技术上讲，这个API应该能够处理各种体系结构的需求，并且应该能够促进这两个平面的独立演化。此外，所有或大多数交换机供应商应该采用相同的标准API，以使其有用；否则，网络将与特定的供应商绑定，会阻碍网络的快速变化和创新。将传统的本地控制功能移动到远程控制器可能会导致新的瓶颈。它还可能导致信令开销。  <br>
在接下来的内容中，我们首先讨论SDN控制器的可扩展性，概述为什么它一直受到关注，以及最近在这个领域的工作。然后，我们回顾一些其他经常提到的SDN可扩展性问题，包括流程设置开销和故障恢复能力。我们认为，尽管这些问题不是SDN特有的，但它们可以通过另一种设计来缓解(其中一些设计现在很常见)。</p>
<h2 id="控制器可扩展性">控制器可扩展性</h2>
<p>一种可能的SDN设计是将所有的控制功能推到一个集中式控制器上。控制器有可能成为网络操作中的瓶颈，随着网络规模的增长，更多的事件和请求会被发送到控制器，并且在某个时刻，控制器无法处理所有传入的请求。缓解这种担忧的一种方法是在多核系统中提高并行性，并提高IO性能。第二种方法是减少转发到控制器的请求数量，比如DevoFlow通过底层网络约束，牺牲细粒度流级可见性（ fine-grained flow-level visibility）换来了可扩展性。<br>
或者，还可以将控制功能的状态和/或计算分配到多个控制器上。提供一个严格一致的集中视图可能会阻碍响应时间和吞吐量。在保持可用性和分区容差的同时实现强一致性并不总是可行的。因此，选择一个合适的一致性水平是SDN中一个重要的设计权衡。 <br>
有一些解决方案，我们可以物理地分布控制平面元素，同时保持网络范围的视图。例如，Onix就是一个分布式控制平台，它促进了分布式控制平面的实现。它为控制应用程序提供了一组通用api，以方便访问分布在Onix实例上的网络状态(NIB)。另一方面，HyperFlow在多个控制器实例之间同步网络状态，使控制应用程序(在每个控制器实例上运行)产生控制整个网络的错觉。这保持了在中央控制器上开发控制平面的简单性，同时减轻了与中央控制器相关的可伸缩性问题，尽管这是针对满足某些特性的一组更受限制的控制应用程序。<br>
Kandoo[9]采用了一种不同的方法来分配控制平面。它定义了一个操作范围，使具有不同要求的应用程序能够共存：本地作用域的应用程序（即，可以使用交换机的本地状态进行操作的应用程序）部署在数据路径附近，以处理频繁的请求并保护控制平面的其他部分免受负载。另一方面，根控制器负责需要网络范围状态的应用程序，同时也充当本地控制器之间需要的任何协调的中介。<br>
一个有趣的观察结果是，SDN中的控制平面可扩展性挑战（例如，收敛性和一致性要求）与传统网络设计中所面临的挑战并没有本质上的不同。SDN本身既不太可能消除控制平面设计的复杂性，也不太可能使其或多或少具有可扩展性。 <br>
与传统网络不同，在SDN中，我们不需要反复解决基本但具有挑战性的问题，如拓扑发现、状态分布和恢复力。</p>
<h2 id="其他sdn可扩展性问题">其他SDN可扩展性问题</h2>
<h3 id="流启动开销">流启动开销</h3>
<p>让我们回顾一下流设置过程来解释瓶颈，并展示一个好的设计如何可以避免它们：</p>
<ul>
<li>包到达但是没有匹配到流规则</li>
<li>交换机产生一个流请求给控制器</li>
<li>控制器返回一个新的流转发规则</li>
<li>交换机更新流表</li>
</ul>
<p>前三个步骤和最后一个步骤的性能部分取决于交换机能力和资源(管理CPU、内存等)【？这里为什么要说前三个和最后一个】。以及其软件堆栈的性能。第三步中的延迟是由控制器的资源以及控制程序的性能来决定。最后，交换机的FIB更新时间导致了完成流程设置过程的延迟。 <br>
目前支持OpenFlow的软交换机性能远好于硬件交换机，原因是交换机上缺乏资源（管理CPU），对交换机芯片组和管理CPU之间的高频通信的支持不足，以及不佳的软件实现。可以预见，FIB更新时间将成为开关侧流设置延迟的主要因素。
While we argue that controllers and, in the near future, switches would be able to sustain sufficient throughput with negligible latency for reactive flow setup, in the end the control logic determines the scalability of a reactive design. A control program installing an end-to-end path on a per-flow basis does not scale, because the per switch memory is fixed but the number of forwarding entries in the data path grows with the number of active flows in the network. However,  the control program may install aggregate rules matching a large number of micro-flows (thereby facing the same scalability challenges as a proactive design), or proactively install rules in the network core to provide end-to-end connectivity and identify quality of service (QoS) classes, while classifying and reactively labeling flows at the edge.  A viable solution to the scalability challenges of the proactive designs in the former class due to data path memory scarcity is proposed in DIFANE [5]; while the scalability  the latter class follows from the observation that the fanout of an edge switch and thus the number of flows initiated there is bounded (just add edge controllers as the network grows in size).  【没看懂】</p>
<h3 id="故障恢复">故障恢复</h3>
<p>早期的系统为单中心控制的设计树立了榜样，因此对故障的恢复能力一直是一个主要问题。一个状态同步的从控制器将足以从控制器故障中恢复，但一个网络分区将留下一半的网络无脑。在多控制器网络中，如果有适当的控制器发现机制，交换机总是可以发现一个存在于其分区中的控制器。因此，在一个可伸缩的发现机制下，控制器故障不会对SDN的可伸缩性构成挑战。 
响应于链路失效的收敛有五个步骤。交换机检测到变化。然后交换机通知控制器。在收到通知后，控制程序计算修复操作，并将更新推到受影响的数据路径元素，这些元素反过来更新它们的转发表。在传统网络中，链路故障通知会在整个网络中泛滥，而在SDN中，该信息直接发送到控制器。因此，SDN网络中的信息传播时延并不比传统网络差。另外，SDN的一个优点是，计算是在更有能力的控制机器上进行的，而不是在所有交换机的弱管理cpu上进行的，无论它们是否受到故障的影响。 <br>
请注意，上述参数建立在隐含的假设之上，即故障的交换机或链路不影响交换机-控制器通信信道。如果有一个出现故障的链路或交换机是控制网络本身的一部分，则需要首先修复控制网络本身。因此，在这种角落的情况下，收敛速度可能比传统网络要慢。<br>
总的来说，SDN中的故障恢复过程并不比传统网络中的更差。因此，存在类似的可伸缩性问题，并且在传统网络中用于最小化停机时间的相同技术也适用于SDN。</p>
<h2 id="不同的网络设置中的可伸缩性">不同的网络设置中的可伸缩性</h2>
<p>采用一种不同的方法，解释不同类型网络中的可伸缩性模式和陷阱。</p>
<h3 id="数据中心">数据中心</h3>
<p>一个典型的数据中心网络有数万个交换元件，并且可以快速增长。在该规模的任何网络中生成的控制事件的绝对数量足以使任何集中式控制器过载。解决这个问题的一种方法是主动在交换机上安装规则，在它们进入控制平面之前有效地消除大多数控制请求。当然，这里的成本是控制器精度和反应性的损失。</p>
<p>当应用程序需要精确的流量统计和/或响应性时，可以将应用程序部署在交换机附近。例如，只要最小化对全局状态的访问，就可以将频繁的事件委托给运行在终端主机上的进程。考虑到整个数据中心网络的处理资源可用性，可以使用像Kandoo[9]这样的解决方案达到任意可伸缩性级别。分布式控制器(如HyperFlow或Onix)也可以是数据中心网络的合理解决方案。考虑到这种网络中的低延迟，状态和流设置的同步延迟将是最小的，对于大多数应用程序来说是可以接受的。</p>
<h3 id="服务提供商网络">服务提供商网络</h3>
<p>通常，服务提供商网络没有数据中心网络那么多的交换机/路由器；然而，这种网络中的节点通常是在地理上分布的。这些网络的大直径加剧了控制器的可伸缩性问题、流设置和状态收敛延迟以及一致性要求。我们可以利用网络的物理分布将其划分为单独的区域；每个分区都可以由一个独立的控制器控制，这些控制器只能交换所需的状态变化事件，有效地向外部控制器隐藏了大部分事件。考虑到这种网络中固有的延迟，所有的控制应用程序都应该是容忍延迟的，并且有较弱的一致性要求。</p>
<p>除了高延迟外，服务提供商网络通常比其他网络有更多的流量。因此，这里也关注数据路径资源限制。流的聚合是一个简单的解决方案，它以控制中的粒度为代价。我们注意到，这些问题也存在于传统的网络中，而这并不是SDN所独有的。</p>
<h2 id="机遇和挑战">机遇和挑战</h2>
<p>传统上，网络的可伸缩性是基于性能指标来研究的，也就是说，当我们沿着给定的维度扩展网络时，特定的性能指标是如何变化的。在实践中，还有其他正交的方面深刻地影响系统如何适应增长。例如,可管理性(如何方便地管理网络,在大尺度状态下添加,删除,或修改网络元素)和功能可伸缩性(是否方便将新功能添加到网络)与网络可伸缩性、性能一样重要，不应被忽视。关于行为和编程抽象、测试和验证以及SDN可扩展性的初步结果表明，我们认为SDN在这一领域提供了一个重要的机遇。显然，在我们能够充分发挥SDN的潜力之前，我们在这些方面都面临着重大挑战。</p>
<h3 id="行为和编程抽象">行为和编程抽象</h3>
<h3 id="测试和验证">测试和验证</h3>
<h3 id="可延展性">可延展性</h3>
<h2 id="结论">结论</h2>
<p>自SDN引入以来，可伸缩性一直是一个主要问题。目前关于SDN可伸缩性的研究表明：</p>
<ul>
<li>这些担忧既不是由SDN引起的，也不是由SDN所独有的。</li>
<li>这些问题大多可以得到解决，而不会失去SDN的好处。</li>
</ul>
<p>在这个领域，通常被忽视的是SDN对网络增长的其他限制因素的影响，如网络规划和管理复杂性。软件定义的网络增加了一种灵活性，可以大规模地适应网络编程和管理。传统的网络在这一领域历来都失败过。最近在这个方向上的尝试非常有希望，尽管未来仍面临许多挑战。</p>
]]></description>
</item>
<item>
    <title>论文笔记——A Survey of SDN</title>
    <link>https://leeshy-tech.github.io/a_survey_of_sdn_note/</link>
    <pubDate>Tue, 11 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/a_survey_of_sdn_note/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6739370" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/6739370</a> <br>
IEEE Communications Surveys &amp; Tutorials  <br>
Volume 16 Issue 3</p>
<h2 id="摘要">摘要</h2>
<p>本文综述了可编程网络的最新进展，重点介绍了SDN。我们提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。</p>
<h2 id="1-引言">1 引言</h2>
<p>传统网络出现的问题：网络管理和性能调优困难，网络僵化。
可编程网络具有革命性，比如软件定义网络，网络设备成为简单的包转发设备，可以通过开放的接口进行编程。
第二节：早期可编程网络 <br>
第三节：SDN及其体系结构，以及OpenFlow协议。  <br>
第四节：开发和测试SDN的平台和工具。<br>
第五节：在数据中心和无线网络的应用。 <br>
第六节：面临的挑战和未来发展的方向。</p>
<h2 id="2-早期可编程网络">2 早期可编程网络</h2>
<p>描述了一些SDN和OpenFlow概念的前身，在早期的一些项目中已经有了关于可编程网络和数控平面分离的思想。</p>
<h2 id="3-sdn体系结构">3 SDN体系结构</h2>
<p>路由器和交换机通常是封闭的系统，只有很少的提供给供应商的接口。适配新版本的协议（比如Ipv6）非常困难，更不用说部署全新的协议和服务。网络僵化效应主要是由于设备的数据和控制平面紧密耦合，新的app或功能的部署需要直接实现在物理设施中。解决网络僵化的一个手段是使用中间设备，比如CDN（内容交付网络）。<br>
软件定义网络将转发硬件和控制逻辑分离，可以更容易地部署新协议和应用程序。</p>
<h3 id="a-当前sdn架构">A 当前SDN架构</h3>
<p>目前有两种SDN架构：ForCES和OpenFlow      <br>
</p>
<ul>
<li>ForCES将单个设备中的控制元素与转发元素分开，意图实现在单一网络设备中将转发硬件与第三方控制相结合。它定义了两个逻辑实体，转发元素FE和控制元素CE，它们通过ForCES协议通信，FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能。ForCES还有一个重要功能块LFB（逻辑功能块），它安装在FE上，通过CE进行控制，实现FE的配置和数据包处理。</li>
<li>OpenFlow完全将控制平面从网络设备上剥离，转发设备基于流表进行转发，流表控制着转发规则。没有匹配流表时按照“table-miss”流表项执行相应的动作，比如丢弃、转发给控制器。控制平面与转发平面通过OpenFlow协议进行通信，远程控制器可以添加、删除或更新交换机的流表项。</li>
<li>ForCES和OpenFlow的模型不同，但是可以实现相似的功能。</li>
<li>OpenFlow得到了各界的大力支持，以至于被认为是SDN的官方标准。</li>
</ul>
<h3 id="b-转发设备">B 转发设备</h3>
<p>底层网络中，转发设备有路由器、交换机、无线接入点等。但是在SDN中，控制逻辑和算法都由控制器维护，基本转发硬件均被称为switches——交换机。<br>
规则空间是OpenFlow可扩展性的瓶颈，在尊重网络策略和约束的同时，优化使用规则空间来服务于一定数量的流条目是一个具有挑战性和重要的课题。</p>
<h3 id="c-控制器">C 控制器</h3>
<p>单个控制器能够处理惊人数量的新流请求，并且应该能够管理除最大的网络之外的所有网络。<br>
交换机控制延迟对网络的整体行为有重大影响，因为每个交换机在从控制器收到插入流表中适当规则的消息之前不能转发数据。这个间隔可能会随着链路延迟而增加，并显著影响网络应用程序的性能。 <br>
控制建模对网络的可扩展性影响很大。 <br>
集中式和分布式：软件定义的网络可能具有集中式或分布式的控制平面。OpenFlow允许多个控制器连接到一台交换机上，这将允许备份控制器在出现故障时接管。软件定义的网络还可以具有一定程度的逻辑去中心化，具有多个逻辑控制器。<br>
粒度控制：传统网络的基本元素是包。在软件定义网络中，网络元素是远程控制的，开销是由数据平面和控制平面之间的通信引起的。控制器对每个包做决策会增加额外的延迟，对流的第一个包所做的决策可以应用于该流的所有后续包，通过将流分组可以进一步减少开销。
被动控制和主动控制：这部分没看懂 P1624。</p>
<h3 id="d-南向接口控制器交换机">D 南向接口：控制器——交换机</h3>
<p>OpenFlow本身就是控制器——交换机交互的一种实现。</p>
<h3 id="e-北向接口控制器服务">E 北向接口：控制器——服务</h3>
<p>目前还没有公认的针对北向交互的标准，而且它们更有可能在特定应用程序的特殊基础上实现。</p>
<h3 id="f-标准化工作">F 标准化工作</h3>
<h2 id="4-sdn开发工具">4 SDN开发工具</h2>
<h3 id="a-仿真和仿真工具">A 仿真和仿真工具</h3>
<p>mininet,NS-3</p>
<h3 id="b-可用软交换机平台">B 可用软交换机平台</h3>
<p></p>
<h3 id="c-实体交换机">C 实体交换机</h3>
<p>目前在商品网络硬件中实现的SDN主要技术是OpenFlow标准。<br>
</p>
<h3 id="d-可用控制器平台">D 可用控制器平台</h3>
<p><br>
其中有两个特殊用途的控制器：Flowvisor、RouteFlow <br>
Flowvisor：充当交换机和多个控制器之间的透明代理，它能够创建网络片，将每个片的控制委托给不同的控制器，促进了片之间的隔离。<br>
RouteFlow：它由一个OpenFlow控制器应用程序、一个独立的服务器和一个虚拟网络环境组成，它可以复制物理基础设施的连接并运行IP路由引擎。路由引擎根据所配置的路由协议(如OSPF、BGP)，将转发信息库(FIB)生成到LinuxIP表中。</p>
<h3 id="e-代码验证和调试">E 代码验证和调试</h3>
<p>NICE：自动化的测试工具，用于通过模型检查和符号执行来帮助发现OpenFlow程序中的bug。<br>
Anteater：试图检查数据平面中存在的网络不变量，如连通性或一致性。这种方法的主要优点是它与协议无关；它还将捕获由错误的交换机固件或与控制平面通信不一致而导致的错误。<br>
VeriFlow：进一步提出了一个驻留在控制器和转发元素之间的实时验证工具。能够停止在到达网络之前会导致异常行为的规则。 <br>
OFRewind：允许以不同的粒度记录网络事件（控制和数据），然后再回放以重现特定的场景，从而提供定位和排除导致网络异常的事件的机会。   <br>
ndb：为SDN实现了断点和数据包回溯。<br>
STS：是一个由软件定义的网络故障排除模拟器。它是用python编写的，并且依赖于POX。它模拟了给定网络中的设备，允许进行测试用例，并识别产生给定错误的输入集。</p>
<h2 id="5-sdn应用">5 SDN应用</h2>
<h3 id="a-企业网络">A 企业网络</h3>
<p>校园网也算是特殊的企业网络。适当的管理在企业环境中至关重要，SDN可以通过编程方式执行和调整网络策略，以及帮助监控网络活动和调整网络性能。使用SDN实现的中间设备包括NAT，防火墙，负载平衡器和网络访问控制。对于更复杂的中间设备，直接实现导致性能下降，可以使用SDN提供统一控制和管理。</p>
<h3 id="b-数据中心">B 数据中心</h3>
<p>在大规模数据中心中能源消耗有很重要的成本，ElasticTree是一种电源管理器，利用SDN来寻找满足当前流量条件的最小功率网络的子集。B4是谷歌提出的SDN概念应用于数据中心环境中的实际例子，它是一个连接谷歌全球数据中心的广域网。B4被证明是高效的，而且工作经验表明，控制平面到数据平面通信和硬件编程开销造成的瓶颈是今后工作中需要考虑的重要问题。</p>
<h3 id="c-基于基础设施的无线接入网">C 基于基础设施的无线接入网</h3>
<p>OpenRoads：设想了一种软件定义蜂窝网络。  <br>
Odin：在企业无线局域网环境中引入了可编程性，它在控制器上构建一个访问点抽象，将关联状态与物理访问点分离，实现主动移动管理和负载平衡。 <br>
OpenRadio：专注于部署可编程无线数据平面，在PHY和MAC层而不是第三层，提供灵活性，旨在提供一个模块化接口，能够处理使用不同协议的流量子集，基于决策平面和转发平面分离的思想，操作员可以表示由处理平面模块(如FFT模块、维特比解码等)组装而来的决策平面规则和相应的动作。</p>
<h3 id="d-光网络">D 光网络</h3>
<p>将SDN和OpenFlow标准应用于光传输网络的好处包括：提高光传输网络控制和管理灵活性，支持部署第三方管理和控制系统，以及通过利用虚拟化和SDN部署新的服务。   <br>
文献[88]-[93]</p>
<h3 id="e-家庭和小型企业">E 家庭和小型企业</h3>
<p>随着低成本网络设备的广泛可用性，这些环境变得越来越复杂和普遍，对更仔细的网络管理和更严格的安全性的需求也相应地增加了。但是，在每个家庭和办公室都有一个专门的网络管理员是不现实的。   <br>
Calvert建议将控制器作为“家庭网络数据记录器”，创建可用于故障排除或其他目的日志。  <br>
Feamster建议外包第三方专家，通过远程控制可编程交换机和分布式网络监控和推理算法，来检测可能的安全问题。   <br>
文献[94]-[97]</p>
<h2 id="5-研究所面临的挑战和未来的发展方向">5 研究所面临的挑战和未来的发展方向</h2>
<h3 id="a-控制器和交换机设计">A 控制器和交换机设计</h3>
<p>可扩展性、性能、鲁棒性、安全性
DIFANE：流被主动推到交换机上，试图减少向控制器的请求数量。   <br>
Devoflow：建议处理交换机中的短寿命流和控制器中的长寿流，以减少流设置延迟和控制器开销。   <br>
[28]：主张用一系列规则匹配记录来替换ASIC上的计数器，并在CPU中处理它们，以允许高效访问计数器。    <br>
FLARE：专注于“深度可编程网络”的新型网络节点模型，它为数据平面、控制平面以及它们之间的接口提供了可编程性。    <br>
为了提高可扩展性，特别是为了可靠性和鲁棒性，人们已经认识到逻辑集中的控制器必须是物理分布的。</p>
<h3 id="b-软件定义互联网">B 软件定义互联网</h3>
<p>目前许多关于SDN的工作都是在单个管理域的上下文中检查或提出解决方案。然而，那些管理本质上是分散的环境，比如互联网，需要一个逻辑分布的控制平面。</p>
<h3 id="c-控制器服务交互">C 控制器——服务交互</h3>
<p>目前南向接口定义的相当好，但是北向接口却没有统一的标准，一种可能的解释是，北向接口完全是在软件中定义的，而南向接口必须支持硬件实现。     <br>
如果我们认为控制器是一个“网络操作系统”，那么应该有一个明确定义的接口，应用程序可以访问底层硬件（交换机），与其他应用程序共存和交互，并利用系统服务（例如拓扑发现、转发），而不需要应用程序开发人员知道控制器的实现细节。 <br>
此外，北向的API应该允许应用程序对同一流应用不同的策略(例如，通过目的地进行转发和通过源IP进行监控)。</p>
<h3 id="d-虚拟化和云服务">D 虚拟化和云服务</h3>
<h3 id="e-以信息为中心的网络">E 以信息为中心的网络</h3>
<p>信息中心网络(ICN)是针对未来互联网架构提出的一种新的范式，它旨在提高内容交付的效率和内容可用性。他们的驱动动机是，当前的互联网是信息驱动的，但网络技术仍然专注于基于位置的寻址和主机对主机的通信的想法。通过提出一种处理命名数据而不是命名主机的体系结构，内容分发可以直接实现到网络结构中，而不是依赖于目前用于将内容映射到单个位置的复杂映射、可用性和安全机制。    <br>
ICN中信息处理和转发的分离与SDN中数据平面和控制平面的解耦相一致。然后，问题就变成了如何将ICN和SDN结合起来。</p>
<h3 id="f-异构网络支持">F 异构网络支持</h3>
<p>未来网络面临的一个主要挑战是资源的有效利用；在无线多跳自组网中尤其如此，因为可用的无线容量本质上是有限的。这是由于许多因素，包括共享物理介质的使用、无线信道损坏和受管理基础设施的缺乏。自组织网络缺乏专用资源，而且连接性的变化使容量共享变得困难。底层网络的异构特性（例如，物理介质、拓扑结构、稳定性）和节点（例如，缓冲区大小、功率限制、移动性）在考虑路由和资源分配时也增加了另一个重要的因素。   <br>
迄今为止的SDN技术，如OpenFlow，主要针对基于基础设施的网络。它们促进了一种不适合在无基础设施环境中出现的分散、中断和延迟级别的集中控制机制。虽然之前的工作已经研究了SDN在无线环境中的使用，但其范围主要集中在基于基础设施的部署。</p>
<h2 id="7-结束语">7 结束语</h2>
<p>在本文中，我们提供了一个可编程网络的概述，并在此背景下，考察了软件定义网络(SDN)的新兴领域。我们来看看可编程网络的历史，从早期的想法到最近的发展。我们特别详细描述了SDN体系结构以及OpenFlow[2]标准。我们介绍了当前的SDN实现和测试平台，并检查了基于SDN范式开发的网络服务和应用程序。最后，我们讨论了SDN所支持的未来发展方向，从支持异构网络到信息中心网络(ICN)。</p>
<h2 id="语句摘录">语句摘录</h2>
<blockquote>
<p>As a result, network management and performance tuning is quite challenging and thus error-prone.<br>
因此，网络管理和性能调优非常具有挑战性，所以很容易出错。</p>
</blockquote>
<blockquote>
<p>Because of its huge deployment base and the fact it is considered part of our society’s critical infrastructure (just like transportation and power grids), the Internet has become extremely difficult to evolve both in terms of its physical infrastructure as well as its protocols and performance.<br>
由于其庞大的部署基础，且被视为我们社会关键基础设施(就像交通和电网)的一部分，所以互联网在其物理基础设施、协议和性能方面的发展已经变得极其困难。</p>
</blockquote>
<blockquote>
<p>As SDN becomes more widely adopted and protocols such as OpenFlow are further defined, new solutions are proposed and new challenges arise.<br>
随着SDN被广泛采用，并且OpenFlow等协议被进一步定义，新的解决方案被提出，新的挑战出现.</p>
</blockquote>
<blockquote>
<p>The Internet has revolutionized the way we, as individuals and as a society, live, work, conduct business, socialize, get entertainment, etc. As a result, the Internet is now considered part of our society’s critical infrastructure much like the power, water, and transportation grids.<br>
互联网已经彻底改变了我们作为个人和社会、生活、工作、做生意、社交、获得娱乐等方面的方式。因此，互联网现在被认为是我们社会关键基础设施的一部分，就像电力、水和交通电网一样。</p>
</blockquote>
]]></description>
</item>
<item>
    <title>SDN自学习交换机工作原理分析</title>
    <link>https://leeshy-tech.github.io/simple_switch_analyse/</link>
    <pubDate>Mon, 10 Jan 2022 17:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_analyse/</guid>
    <description><![CDATA[<h2 id="自学习交换机">自学习交换机</h2>
<p>交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。</p>
<p>SDN的自学习交换机跟传统交换机不一样的点有：</p>
<ol>
<li>帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。</li>
<li>自学习的过程中可能会有流表的变化。</li>
</ol>
<h2 id="ping命令过程">ping命令过程</h2>
<p>ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。<br>
局域网ping命令的执行过程：<br>
网络模型为：h1  &mdash;-  s1  &mdash;-  h2，两台主机连接到同一个交换机。
假设h1 ping h2</p>
<ul>
<li>首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。</li>
<li>交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。</li>
<li>h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。</li>
<li>h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。</li>
<li>h2收到报文后应答，ping完成。</li>
</ul>
<h2 id="实验分析">实验分析</h2>
<h3 id="实验内容">实验内容</h3>
<ul>
<li>通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a>。</li>
<li>使用OVS搭建网络模型：h1  &mdash;-  s1  &mdash;-  h2，将s1连接到控制器。</li>
<li>h1 ping h2，观察PacketIn消息。</li>
<li>查看s1的流表变化。</li>
</ul>
<p>这里不用mininet平台搭建网络的原因是：mininet主机会定时检查与交换机的连接，导致出现很多的冗余PacketIn消息，不利于观察。</p>
<h3 id="实验结果">实验结果</h3>
<p><br>
当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。<br>
使用<code>ovs-ofctl dump-flows s1</code>命令观察流表，结果如下：  <br>
<br>
执行完ping命令后多了两条流表。</p>
<h3 id="流程分析">流程分析</h3>
<p>日志的输出格式是：packet in &lt;交换机标号&gt; &lt;源mac&gt; &lt;目的mac&gt; &lt;输入端口&gt;<br>
h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 <br>
h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。</p>
<ol>
<li>h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac1--端口1</code>，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。</li>
<li>s1广播，h2收到并学习到h1的mac地址，发送<code>&lt;src = mac2，dst = mac1&gt;</code>的ARP应答报文，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac2--端口2</code>，查找到mac1的对应端口为1，此时下发一条流表<code>in_port=2,output:1</code>，发送PacketOut消息指示s1把这个应答报文转发到端口1。</li>
<li>h1收到应答报文，学习到h2的mac地址，发送<code>&lt;src = mac1，dst = mac2&gt;</code>的ICMP报文。</li>
<li>此时s1中只有一条流表<code>in_port=2,output:1</code>，仍然发送PacketIn消息。</li>
<li>控制器查找到mac2的对应端口为2，下发一条流表<code>in_port=1,output:2</code>，发送PacketOut消息指示s1把这个报文转发到端口2。</li>
<li>之后略</li>
</ol>
<p>所以，整个过程中一共上传了三次PacketIn消息，分别是<code>ma1 ff:ff:ff:ff 1</code>，<code>mac2 mac1 2</code>，<code>mac1 mac2 1</code>。<br>
过程结束s1中有两条流表，分别是<code>in_port=2,src=mac2,dst=mac1,action=output:1</code>,<code>in_port=1,src=mac1,dst=mac2,action=output:2</code>。 
有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。</p>
<h2 id="结束语">结束语</h2>
<h3 id="总结">总结</h3>
<p>要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.51cto.com/wanicy/335207" target="_blank" rel="noopener noreffer">Ping过程 详解 </a><br>
<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a></p>
]]></description>
</item>
<item>
    <title>ryu开发——集线器</title>
    <link>https://leeshy-tech.github.io/simple_hub/</link>
    <pubDate>Sun, 09 Jan 2022 20:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_hub/</guid>
    <description><![CDATA[<h2 id="什么是集线器">什么是集线器</h2>
<p>集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。</p>
<h2 id="实现代码">实现代码</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># simple_hub.py</span>
<span class="kn">from</span> <span class="nn">ryu.base</span> <span class="kn">import</span> <span class="n">app_manager</span>
<span class="kn">from</span> <span class="nn">ryu.controller</span> <span class="kn">import</span> <span class="n">ofp_event</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">MAIN_DISPATCHER</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">set_ev_cls</span>
 
<span class="k">class</span> <span class="nc">L2Switch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2Switch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
 
    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">ofp</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">ofp_parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>
 
        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">ofp</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
            <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
            <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><h2 id="实现逻辑">实现逻辑</h2>
<p>当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。</p>
<h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
]]></description>
</item>
<item>
    <title>ryu源码解读——simple_switch.py</title>
    <link>https://leeshy-tech.github.io/simple_switch_note/</link>
    <pubDate>Sat, 08 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_note/</guid>
    <description><![CDATA[<h2 id="总览">总览</h2>
<p>文件位置：ryu/ryu/app/simple_switch.py
simple_switch.py共110行<br>
1-18：注释<br>
21-29：引库<br>
32-110：继承类RyuApp</p>
<h2 id="32-37">32-37</h2>
<blockquote>
<p>继承类RyuApp，并调用构造函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">SimpleSwitch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="n">OFP_VERSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofproto_v1_0</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">]</span>   <span class="c1"># 声明支持的Open Flow版本</span>
    <span class="c1"># 继承，调用构造函数并添加一个新属性 mac_to_port</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSwitch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div><ul>
<li>编写的程序实际上是Ryu控制器的APP，需要继承类RyuApp。</li>
<li>自学习交换机需要控制器来维护交换机的帧交换表，帧交换便就是mac地址与端口号的对应关系，所以添加一个新属性mac_to_port。</li>
</ul>
<h2 id="39-51">39-51</h2>
<blockquote>
<p>实现一个添加流表的函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># 函数：添加流表</span>
<span class="k">def</span> <span class="nf">add_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span>
        <span class="n">in_port</span><span class="o">=</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">dl_dst</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">dl_src</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="c1"># 源和目的mac地址</span>
        <span class="p">)</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">cookie</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_ADD</span><span class="p">,</span> <span class="c1"># 命令：添加新流表</span>
        <span class="n">idle_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hard_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">priority</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_DEFAULT_PRIORITY</span><span class="p">,</span> <span class="c1"># 优先级：默认</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFF_SEND_FLOW_REM</span><span class="p">,</span> 
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>      <span class="c1">#控制器下发消息</span>
</code></pre></div><h3 id="datapath">datapath</h3>
<p>控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。</p>
<h3 id="协议细节">协议细节</h3>
<dl>
<dt>OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。</dt>
<dt>OFPMatch：流匹配规则。</dt>
<dt>flags：以下三个值之一</dt>
<dd>| OFPFF_SEND_FLOW_REM   当流过期或删除时，发送删除流消息。</dd>
<dd>| OFPFF_CHECK_OVERLAP   首先检查重叠的条目。</dd>
<dd>| OFPFF_EMERG           标记为紧急情况。</dd>
</dl>
<h2 id="53-94">53-94</h2>
<blockquote>
<p>PacketIn消息的处理逻辑：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析数据包</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">pkt</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">Packet</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">eth</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">.</span><span class="n">get_protocol</span><span class="p">(</span><span class="n">ethernet</span><span class="o">.</span><span class="n">ethernet</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eth</span><span class="o">.</span><span class="n">ethertype</span> <span class="o">==</span> <span class="n">ether_types</span><span class="o">.</span><span class="n">ETH_TYPE_LLDP</span><span class="p">:</span>
        <span class="c1"># 忽略LLDP类型的包</span>
        <span class="k">return</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">dst</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">src</span>

    <span class="c1"># 初始化mac_port对应规则</span>
    <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>  

    <span class="c1"># 打印消息</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;packet in </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">dpid</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">)</span> 

    <span class="c1"># 记录此包对应的mac_port对应规则</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span>

    <span class="c1"># 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span>

    <span class="c1"># 封装一个OFPActionOutput类型动作：从out_port端口输出</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">out_port</span><span class="p">)]</span>

    <span class="c1"># 如果已经明确了目的mac的输出端口，那么就下发一条流表</span>
    <span class="k">if</span> <span class="n">out_port</span> <span class="o">!=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

    <span class="c1"># 如果交换机没有缓存该包，那么就把该包还回去</span>
    <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_NO_BUFFER</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># 发送PacketOut消息</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><p>细节分析：</p>
<h3 id="lldp">LLDP</h3>
<h3 id="packetin与packetout">PacketIn与PacketOut</h3>
<p>当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。<br>
所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。<br>
PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。</p>
<h3 id="处理逻辑">处理逻辑</h3>
<ul>
<li>解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。</li>
<li>如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。</li>
<li>如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。</li>
<li>封装PacketOut消息，下发。</li>
</ul>
<h3 id="buffer_id与data">buffer_id与data</h3>
<p>交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。</p>
<ul>
<li>如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。</li>
<li>如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。</li>
</ul>
<h2 id="96-110">96-110</h2>
<blockquote>
<p>如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息。
这个部分不是自学习交换机必需的。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPortStatus</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_port_status_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析消息</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">reason</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">reason</span>
    <span class="n">port_no</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">port_no</span>

    <span class="c1"># 打印</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="k">if</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_ADD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port added </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_DELETE</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port deleted </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_MODIFY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port modified </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;Illeagal port state </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
</code></pre></div><h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
<h3 id="备注">备注</h3>
<p>ryu官方：<a href="https://github.com/faucetsdn/ryu" target="_blank" rel="noopener noreffer">https://github.com/faucetsdn/ryu</a><br>
本人注释版：<a href="https://github.com/leeshy-tech/ryu" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/ryu</a></p>
]]></description>
</item>
<item>
    <title>在树莓派上构建SDWN网络教程</title>
    <link>https://leeshy-tech.github.io/sdn_on_raspberrypi/</link>
    <pubDate>Sat, 08 Jan 2022 16:31:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/sdn_on_raspberrypi/</guid>
    <description><![CDATA[<h2 id="导入">导入</h2>
<p>在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 <br>
OVS：OpenvSwitch的简称，它是一种支持OpenFlow协议的软交换机。 <br>
ryu：基于Python开发的SDN开源控制器。</p>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>树莓派搭载linux操作系统，有无线网卡，利用<code>ifconfig</code>命令查得无线网卡名称。</li>
<li>树莓派之间先组成adhoc网络，参考文章：<a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a></li>
<li>在两台树莓派上安装OVS，参考文章：<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a></li>
<li>在其中一台树莓派上安装ryu控制器。</li>
</ul>
<h2 id="组网步骤">组网步骤</h2>
<p>假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： 
</p>
<h3 id="控制节点-ip--10001">控制节点 IP = 10.0.0.1</h3>
<p>开启控制器（进入ryu/ryu/app/文件夹执行）：</p>
<pre tabindex="0"><code>ryu-manager simple_switch.py
</code></pre><p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.1
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="普通节点-ip--10002">普通节点 IP = 10.0.0.2</h3>
<p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.2
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="关于网卡设置的解释">关于网卡设置的解释</h3>
<blockquote>
<p>将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下：</p>
</blockquote>
<p>无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。</p>
<p>对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。  <br>
创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令：<br>
取消wlan0设置的IP地址：<code>ifconfig wlan0 0</code><br>
设置网卡s1的IP地址为原主机地址：<code>ifconfig s1 10.0.0.1</code><br>
开启网卡s1：<code>ifconfig s1 up</code></p>
<h2 id="测试">测试</h2>
<blockquote>
<p>如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？</p>
</blockquote>
<p>注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。   <br>
查询两个交换机的流表信息：   <br>
<code>ovs-ofctl dump-flows s1</code>    <br>
输出为空，此时交换机中没有流表。 <br>
在控制节点ping普通节点： <br>
<code>ping 10.0.0.2</code><br>
发现可以ping通，同时可以在控制器窗口看到PacketIn消息。<br>
再次查询流表：<code>ovs-ofctl dump-flows s1</code>  <br>
发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。</p>
<h2 id="应用">应用</h2>
<p>模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序：<br>
控制节点：<code>python3 SDN_on_Raspberry_pi/client.py</code><br>
普通节点：<code>python3 SDN_on_Raspberry_pi/sever.py</code> <br>
从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。</p>
<h2 id="结束语">结束语</h2>
<p>因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a><br>
<a href="https://www.sdnlab.com/sdn-guide/14747.html" target="_blank" rel="noopener noreffer">OVS初级教程：使用Open vSwitch构建虚拟网络</a><br>
<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a><br>
<a href="https://www.cnblogs.com/mrwuzs/p/10242737.html" target="_blank" rel="noopener noreffer">ovs之组网实验</a><br>
<a href="https://www.bilibili.com/video/BV1ft4y1a7ip?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">SDN系列学习课程-OpenFlow-Ryu-Mininet</a><br>
<a href="https://www.bilibili.com/video/BV1eg411G7pW?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">TCP/IP网络通信之Socket编程入门</a></p>
<h3 id="备注">备注</h3>
<p>本文依赖代码文件：<a href="https://github.com/leeshy-tech/SDN_on_Raspberry_pi" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/SDN_on_Raspberry_pi</a></p>
]]></description>
</item>
</channel>
</rss>
