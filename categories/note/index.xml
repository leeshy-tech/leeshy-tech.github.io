<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Note - 分类 - Leeshy&#39;s Blog | To be humble</title>
        <link>https://leeshy-tech.github.io/categories/note/</link>
        <description>Note - 分类 - Leeshy&#39;s Blog | To be humble</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>saili@bupt.edu.cn (Leeshy)</managingEditor>
            <webMaster>saili@bupt.edu.cn (Leeshy)</webMaster><lastBuildDate>Tue, 11 Jan 2022 21:46:06 &#43;0800</lastBuildDate><atom:link href="https://leeshy-tech.github.io/categories/note/" rel="self" type="application/rss+xml" /><item>
    <title>论文笔记——A Survey of SDN</title>
    <link>https://leeshy-tech.github.io/a_survey_of_sdn_note/</link>
    <pubDate>Tue, 11 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/a_survey_of_sdn_note/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6739370" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/6739370</a> <br>
IEEE Communications Surveys &amp; Tutorials  <br>
Volume 16 Issue 3</p>
<h2 id="摘要">摘要</h2>
<p>本文综述了可编程网络的最新进展，重点介绍了SDN。我们提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。</p>
<h2 id="1-引言">1 引言</h2>
<p>传统网络出现的问题：网络管理和性能调优困难，网络僵化。
可编程网络具有革命性，比如软件定义网络，网络设备成为简单的包转发设备，可以通过开放的接口进行编程。
第二节：早期可编程网络 <br>
第三节：SDN及其体系结构，以及OpenFlow协议。  <br>
第四节：开发和测试SDN的平台和工具。<br>
第五节：在数据中心和无线网络的应用。 <br>
第六节：面临的挑战和未来发展的方向。</p>
<h2 id="2-早期可编程网络">2 早期可编程网络</h2>
<p>描述了一些SDN和OpenFlow概念的前身，在早期的一些项目中已经有了关于可编程网络和数控平面分离的思想。</p>
<h2 id="3-sdn体系结构">3 SDN体系结构</h2>
<p>路由器和交换机通常是封闭的系统，只有很少的提供给供应商的接口。适配新版本的协议（比如Ipv6）非常困难，更不用说部署全新的协议和服务。网络僵化效应主要是由于设备的数据和控制平面紧密耦合，新的app或功能的部署需要直接实现在物理设施中。解决网络僵化的一个手段是使用中间设备，比如CDN（内容交付网络）。<br>
软件定义网络将转发硬件和控制逻辑分离，可以更容易地部署新协议和应用程序。</p>
<h3 id="a-当前sdn架构">A 当前SDN架构</h3>
<p>目前有两种SDN架构：ForCES和OpenFlow      <br>
</p>
<ul>
<li>ForCES将单个设备中的控制元素与转发元素分开，意图实现在单一网络设备中将转发硬件与第三方控制相结合。它定义了两个逻辑实体，转发元素FE和控制元素CE，它们通过ForCES协议通信，FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能。ForCES还有一个重要功能块LFB（逻辑功能块），它安装在FE上，通过CE进行控制，实现FE的配置和数据包处理。</li>
<li>OpenFlow完全将控制平面从网络设备上剥离，转发设备基于流表进行转发，流表控制着转发规则。没有匹配流表时按照“table-miss”流表项执行相应的动作，比如丢弃、转发给控制器。控制平面与转发平面通过OpenFlow协议进行通信，远程控制器可以添加、删除或更新交换机的流表项。</li>
<li>ForCES和OpenFlow的模型不同，但是可以实现相似的功能。</li>
<li>OpenFlow得到了各界的大力支持，以至于被认为是SDN的官方标准。</li>
</ul>
<h3 id="b-转发设备">B 转发设备</h3>
<p>底层网络中，转发设备有路由器、交换机、无线接入点等。但是在SDN中，控制逻辑和算法都由控制器维护，基本转发硬件均被称为switches——交换机。<br>
规则空间是OpenFlow可扩展性的瓶颈，在尊重网络策略和约束的同时，优化使用规则空间来服务于一定数量的流条目是一个具有挑战性和重要的课题。</p>
<h3 id="c-控制器">C 控制器</h3>
<p>单个控制器能够处理惊人数量的新流请求，并且应该能够管理除最大的网络之外的所有网络。<br>
交换机控制延迟对网络的整体行为有重大影响，因为每个交换机在从控制器收到插入流表中适当规则的消息之前不能转发数据。这个间隔可能会随着链路延迟而增加，并显著影响网络应用程序的性能。 <br>
控制建模对网络的可扩展性影响很大。 <br>
集中式和分布式：软件定义的网络可能具有集中式或分布式的控制平面。OpenFlow允许多个控制器连接到一台交换机上，这将允许备份控制器在出现故障时接管。软件定义的网络还可以具有一定程度的逻辑去中心化，具有多个逻辑控制器。<br>
粒度控制：传统网络的基本元素是包。在软件定义网络中，网络元素是远程控制的，开销是由数据平面和控制平面之间的通信引起的。控制器对每个包做决策会增加额外的延迟，对流的第一个包所做的决策可以应用于该流的所有后续包，通过将流分组可以进一步减少开销。
被动控制和主动控制：这部分没看懂 P1624。</p>
<h3 id="d-南向接口控制器交换机">D 南向接口：控制器——交换机</h3>
<p>OpenFlow本身就是控制器——交换机交互的一种实现。</p>
<h3 id="e-北向接口控制器服务">E 北向接口：控制器——服务</h3>
<p>目前还没有公认的针对北向交互的标准，而且它们更有可能在特定应用程序的特殊基础上实现。</p>
<h3 id="f-标准化工作">F 标准化工作</h3>
<h2 id="重点参考文献">重点参考文献</h2>
<p>[26]：讨论了ForCES和OpenFlow的异同，</p>
<h2 id="语句摘录">语句摘录</h2>
<p>As a result, network management and performance tuning is quite challenging and thus error-prone.<br>
因此，网络管理和性能调优非常具有挑战性，所以很容易出错。 <br>
Because of its huge deployment base and the fact it is considered part of our society’s critical infrastructure (just like transportation and power grids), the Internet has become extremely difficult to evolve both in terms of its physical infrastructure as well as its protocols and performance.<br>
由于其庞大的部署基础，且被视为我们社会关键基础设施(就像交通和电网)的一部分，所以互联网在其物理基础设施、协议和性能方面的发展已经变得极其困难。</p>
]]></description>
</item>
<item>
    <title>OVS命令笔记</title>
    <link>https://leeshy-tech.github.io/ovs_cli/</link>
    <pubDate>Fri, 07 Jan 2022 16:08:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/ovs_cli/</guid>
    <description><![CDATA[<h2 id="查看信息">查看信息</h2>
<p>查看openvswitch的状态：<code>ovs-vsctl show</code><br>
查看openvswitch中的所有网桥：<code>ovs-vsctl list-br</code><br>
查看网桥的信息：<code>ovs-ofctl show br0</code>  <br>
查看网桥中的所有端口：<code>ovs-vsctl list-ports br0</code><br>
查看网桥各端口状态：<code>ovs-ofctl dump-ports br0</code><br>
查看网桥上的流表：<code>ovs-ofctl dump-flows br0</code> <br>
查看网桥故障模式：<code>ovs-vsctl get-fail-mode br0</code>  <br>
查看网桥是否开启stp协议：<code>ovs-vsctl get bridge br0 stp_enable</code><br>
查看网桥所有配置信息：<code>ovs-vsctl list bridge br0</code> <br>
查看端口所有特性信息：<code>ovs-vsctl list port br0 port1 </code></p>
<h2 id="网桥操作">网桥操作</h2>
<p>添加网桥：<code>ovs-vsctl add-br br0</code> <br>
删除网桥：<code>ovs-vsctl del-br br0</code> <br>
将网桥连接到控制器：<code>ovs-vsctl set-controller br0 tcp:&lt;controller IP&gt;:&lt;port&gt;</code><br>
设置网桥的故障模式：<code>ovs-vsctl set-fail-mode br0 &lt;secure or standalone&gt; </code><br>
给网桥开启stp协议：<code>ovs-vsctl set bridge br0 stp_enable=true</code></p>
<h2 id="端口操作">端口操作</h2>
<p>增加端口：<code>ovs-vsctl add-port br0 port1</code><br>
删除端口：<code>ovs-vsctl del-port br0 port1</code> <br>
设置端口号：<code>ovs-vsctl set Interface port1 ofport_request=&lt;number&gt;</code> <br>
设置端口类型：<code>ovs-vsctl set Interface p4 type=&lt;type&gt;</code>    </p>
<table>
<thead>
<tr>
<th>端口类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal</td>
<td>普通端口</td>
</tr>
<tr>
<td>Internal</td>
<td>这个端口相当于一个虚拟网卡</td>
</tr>
<tr>
<td>Patch</td>
<td>用于连接两个网桥的端口</td>
</tr>
<tr>
<td>Tunne</td>
<td>隧道端口是一种虚拟端口，支持使用gre或vxlan等隧道技术与位于网络上其他位置的远程端口通讯。</td>
</tr>
</tbody>
</table>
<h2 id="网卡操作">网卡操作</h2>
<p>将物理网卡挂接到网桥：<code>ovs-vsctl add-port br0 eth0</code><br>
列出所有挂接到网卡的网桥：<code>ovs-vsctl port-to-br eth0</code><br>
删除网桥上已经挂接的网卡：<code>ovs-vsctl del-port br0 eth0</code></p>
<h2 id="流表操作">流表操作</h2>
<p>添加流表：<code>ovs-ofctl add-flow br0 &lt;match&gt;,&lt;action&gt;</code>   <br>
删除流表：<code>ovs-ofctl add-flow br0 &lt;match&gt;</code></p>
<h3 id="流表动作-action">流表动作 action</h3>
<p>从端口转发：<code>actions=output:&lt;number&gt;</code>  <br>
丢弃数据包：<code>actions=drop</code><br>
广播：<code>actions=NORMAL</code></p>
<h3 id="匹配项-match">匹配项 match</h3>
<p>如有多个匹配项，之间用逗号隔开。  </p>
<table>
<thead>
<tr>
<th>匹配项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in_port=port</td>
<td>网桥端口号</td>
</tr>
<tr>
<td>dl_vlan=vlan</td>
<td>数据包的 VLAN Tag 值</td>
</tr>
<tr>
<td>dl_vlan_pcp=priority</td>
<td>VLAN 优先级，改值取值区间为[0-7]。数字越大，优先级越高。</td>
</tr>
<tr>
<td>dl_src=<!-- raw HTML omitted -->,dl_dst=<!-- raw HTML omitted --></td>
<td>匹配源或者目标的 MAC 地址</td>
</tr>
<tr>
<td>dl_type=ethertype</td>
<td>匹配以太网协议类型 ,IPv4:0x0800,IPv6:0x086dd,ARP:0x0806</td>
</tr>
<tr>
<td>nw_src=<!-- raw HTML omitted -->,nw_dst=<!-- raw HTML omitted --></td>
<td>匹配源或目的IP，前提要设定dl_type</td>
</tr>
<tr>
<td>table=number</td>
<td>指定流表编号</td>
</tr>
<tr>
<td>reg<!-- raw HTML omitted -->=value[/mask]</td>
<td>网桥中寄存器的值</td>
</tr>
<tr>
<td>tp_src=number,tp_dst=number</td>
<td>TCP协议源或目的端口</td>
</tr>
</tbody>
</table>
<h2 id="参考文献">参考文献</h2>
<p><a href="https://www.cnblogs.com/goldsunshine/p/11527928.html" target="_blank" rel="noopener noreffer">OpenvSwitch系列</a></p>
]]></description>
</item>
</channel>
</rss>
