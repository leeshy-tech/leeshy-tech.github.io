<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>SDN - 分类 - Leeshy&#39;s Blog | To be humble</title>
        <link>https://leeshy-tech.github.io/categories/sdn/</link>
        <description>SDN - 分类 - Leeshy&#39;s Blog | To be humble</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>saili@bupt.edu.cn (Leeshy)</managingEditor>
            <webMaster>saili@bupt.edu.cn (Leeshy)</webMaster><lastBuildDate>Fri, 06 Jan 2023 17:32:06 &#43;0800</lastBuildDate><atom:link href="https://leeshy-tech.github.io/categories/sdn/" rel="self" type="application/rss+xml" /><item>
    <title>可编程网络前世今生</title>
    <link>https://leeshy-tech.github.io/overview_of_programmable_networks/</link>
    <pubDate>Fri, 06 Jan 2023 17:32:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/overview_of_programmable_networks/</guid>
    <description><![CDATA[<h1 id="可编程网络技术及发展趋势综述">可编程网络技术及发展趋势综述</h1>
<blockquote>
<p>本文为BUPT课程“个人发展规划与创新创业”课程论文，仅在此记录，并不是一篇学术论文。</p>
</blockquote>
<h2 id="1-引言">1 引言</h2>
<p>互联网极大地影响着人们的生活和工作方式，经过 40 多年的发展，已经成为人类社会的重要基础设施和各国的重要战略资源。在互联网过去几十年的发展过程中，涌现出一系列优秀的技术和标准，如 TCP（transmission control protocol）/IP（Internetprotocol）、OSPF（open shortest path first）、BGP （ border gateway protocol ） MPLS（ multi-protocol label switching ） 、 IPv6（ Internet protocol version 6 ） 、 BBR（bottleneck bandwidth and RTT）等，以及移动通信网络领域的 3G/4G/5G 网络相关技术等，这些技术为互联网的发展演进提供了重要支撑，做出了历史性贡献。然而，随着新时代的到来，新型网络应用不断涌现，现有的网络结构已难以满足需要，其弊端暴露的越来越明显。</p>
<p>在技术挑战的角度上，未来互联网在可扩展性、移动性、安全性、服务质量保障、高效服务分发、绿色节能等方面、仍面临巨大挑战[1]。关于未来网络技术的发展，学术界涌现了很多新的思想和尝试，比如内容中心网络（content centric network，CCN）、软件定义网络（software-defined network，SDN）、云网络（Nebula）、命名数据网络（named data network，NDN）、可表述网络（expressive internet architecture，XIA）、可选网络（ChoiceNet）等。</p>
<p>对于新型网络技术，主要有两种研究思路，第一种是对于传统网络的分层设计协议，设计更多的协议补丁（如组播、MPLS）；或者设计全新的未来网络协议（如 CCN、NDN）。第二种则是可编程思想，它认为再好的新协议也不能跟上应用和需求的不断变化。因此，从系统设计的角度，利用灵活定制的思想定制未来的网络。</p>
<h2 id="2-现有网络的问题和挑战">2 现有网络的问题和挑战</h2>
<h3 id="21-部署管理困难">2.1 部署管理困难</h3>
<p>网络中有多种设备，从路由器和交换机到防火墙、网络地址转换器、服务器负载平衡器和入侵检测系统等中间设备。这些专用设备通常是&quot;封闭&quot;系统。具有有限的并且特定于供应商的配置接口。一旦部署并投入生产，当前的网络基础设施很难演进。部署协议的新版本（例如 IPv6）非常困难，更不用说部署全新的协议和服务，几乎是不可完成的任务。</p>
<h3 id="22-分布式架构瓶颈">2.2 分布式架构瓶颈</h3>
<p>传统网络在设计之初就采用分布式的结构，无中心节点，设备之间采用口口相传的方式传递信息，每台设备都有自己的 CPU、独立决定转发逻辑，造成无法从全局的角度进行资源分配和流量调度[2]。同时，为了协调各个设备的相互沟通，诞生了无数的网络协议，带来了新旧兼容、更新缓慢的问题。</p>
<h3 id="23-可扩展性问题">2.3 可扩展性问题</h3>
<p>当前网络规模不断扩大，互联网流量爆炸，网络流量超线性增长，然而芯片处理性能的增长受摩尔定律的限制，硬件处理性能越来越跟不上流量的提升速度，域间路由收敛变慢，网络稳定性下降。根据 APNIC 提供的数据：BGP（边界网关协议）更新频率平均达到 6 次/s，一天累计 50 万次以上，峰值高达 1000 次/s。所以网络可持续发展面临严峻挑战。</p>
<h3 id="24-不可控qos难以保证">2.4 不可控、QoS难以保证</h3>
<p>从需求驱动角度来看，新的业务将对未来网络提出更多的要求。例如，在消费型业务领域，AR（augmented reality）/VR（virtualreality）/3D 通话、全息传送、交互式游戏等沉浸式业务将对网络低时延、大带宽性能提出更高要求；在工业互联网领域，精仪制造、远程工控、数字孪生等生产性业务则要求网络具备更好的低时延、低抖动能力；在车联网领域，自动驾驶、车路协同、无人车、无人机、无人船等新兴业务则会对网络提出低时延、高可靠的双重需求。</p>
<p>而传统 TCP/IP 网络遵循&quot;尽力而为&quot;的转发，网络侧重公平性原则，缺少提供差异性服务的能力，对于新时代对于网络容量、实时性、可靠性的差异化需要，传统网络结构是无能为力的。</p>
<h2 id="3-早期可编程网络">3 早期可编程网络</h2>
<p>软件定义网络以数控分离、可编程等主要特点受到广泛认可，特别是 OpenFlow 被吹捧为&quot;网络中的激进新思想&quot;。然而，科学研究不是一蹴而就的，SDN 也是受早期可编程网络工作的影响，它们是当前 SDN 范式的前身，为当前的许多思想奠定了基础。</p>
<h3 id="31-open-signaling">3.1 Open Signaling</h3>
<p>开放信令 (OPENSIG) 工作组于 1995年开始举办一系列研讨会，致力于&quot;使 ATM、互联网和移动网络更加开放、可扩展和可编程&quot;。 他们认为通信硬件和控制软件之间的分离是必要的，但实现起来具有挑战性；这主要是由于垂直集成的交换机和路由器，其封闭性使得快速部署新的网络服务和环境变得不可能。他们提议的核心是通过开放、可编程的网络接口提供对网络硬件的访问；这将允许通过分布式编程环境部署新服务。</p>
<p>在这些想法的推动下，IETF 工作组应运 而 生 ， 随后导致了通用交换管理协议(GSMP)的诞生，这是一种控制标签交换的通用协议。GSMP 允许控制器在交换机上建立和释放连接、添加和删除多播连接上的叶子、管理交换机端口、请求配置信息、请求和删除交换机资源的预留以及请求统计信息。</p>
<h3 id="32-active-networking">3.2 Active Networking</h3>
<p>同 样 在 1990 年 代 中 期 ， ActiveNetworking 倡议提出了一种网络基础设施的想法，该网络基础设施可以为定制服务进行编程。有两种主要方法正在考虑中，即：(1)用户可编程交换机，具有带内数据传输和带外管理通道；(2)胶囊，可以在用户消息中携带的程序片段；然后程序片段将由路由器解释和执行。尽管它激发了相当多的活动，但 Active Networking 并获得广泛使用和行业部署，主要是由于实际的安全和性能问题。</p>
<h3 id="33-dcan">3.3 DCAN</h3>
<p>1990 年代中期发生的另一项举措是 ATM 网络下放控制 (DCAN)。 该项目的目的是为 ATM 网络的可扩展控制和管理设计和开发必要的基础设施。前提是许多设备的控制和管理功能（ 在 DCAN 的情况下是 ATM 交换机）应该与设备本身分离，并委托给专用的外部实体，这基本上是 SDN 背后的概念。</p>
<h3 id="34-4d-project">3.4 4D Project</h3>
<p>从 2004 年开始，4D 项目提倡一种全新的设计，强调路由决策逻辑和管理网络元素之间交互的协议之间的分离。它建议为&quot;决策&quot;平面提供网络的全局视图，由&quot;传播&quot;和&quot;发现&quot;平面提供服务，以控制用于转发流量的&quot;数据&quot;平面。这些想法为后来的工作提供了直接的灵感 ， 例如 NOX ， 它在支持 OpenFlow 的网络的背景下提出了&quot;网络操作系统&quot;。</p>
<h3 id="35-netconf">3.5 NETCONF</h3>
<p>2006年，IETF网络配置工作组提出 NETCONF作为修改网络设备配置的管理协议。该协议允许网络设备公开一个API，通过该API可以发送和检索可扩展的配置数据。</p>
<p>尽管NETCONF协议实现了简化设备（重新）配置的目标并充当管理的构建块，但数据平面和控制平面之间没有分离。具有NETCONF的网络不应被视为完全可编程，因为任何新功能都必须在网络设备和管理器上实现，以便可以提供任何新功能。</p>
<h3 id="36-ethane">3.6 Ethane</h3>
<p>OpenFlow的直接前身是SANE / Ethane 项目，该项目在 2006 年为企业网络定义了一种新架构。Ethane的重点是使用集中式控制器来管理网络中的策略和安全性。一个值得注意的例子是提供基于身份的访问控制。与SDN类似，Ethane使用两个组件：一个控制器来决定是否应该转发数据包，以及一个由流表和到控制器的安全通道组成的Ethane交换机。</p>
<h2 id="4-软件定义网络">4 软件定义网络</h2>
<p>软件定义网络在可编程网络中无疑是里程碑式的发展。它旨在促进创新并实现对网络数据路径的简单编程控制。如图1所示，转发硬件与控制逻辑的分离允许更轻松地部署新协议和应用程序、直接的网络可视化和管理，以及将各种中间盒整合到软件控制中。网络不是在分散设备的集合上执行策略和运行协议，而是简化为“单一”的转发硬件和决策网络控制器。</p>
<p></p>
<h3 id="41-openflow">4.1 OpenFlow</h3>
<p>OpenFlow[3]项目第一次完整阐述并实践了软件定义网络的思想，它的影响之大以至于许多人几乎将OpenFlow等同于狭义上的SDN。</p>
<p>在OpenFlow架构中，传统转发设备中的控制功能被彻底抽象出来，交换机成为功能单一的转发设备，只按照流表项匹配转发，控制器与交换机通过OpenFlow协议进行安全通信。</p>
<p>交换机中的流表决定了对于一条流的处理动作，当到达交换机的包不能匹配已存在的流表时，交换机将包转发到控制器，由控制器决定转发逻辑并下发流表。并且，控制器开放了北向接口，可以通过编程的方式控制转发逻辑。由此便实现了对网络的灵活控制。</p>
<p></p>
<p>开放网络基金会(ONF)及其SDN提案 OpenFlow 获得了来自工业、研究和学术界的大力支持。来自这些不同部门的支持最终以研究论文、参考软件实现甚至硬件的形式产生了大量可交付成果。以至于有些人认为OpenFlow架构是SDN的事实标准。</p>
<h3 id="42-forces">4.2 ForCES</h3>
<p>IETF ForCES（Forwarding and Control Element Separation，转发和控制元素分离）工作组提出的方法重新定义了控制元素与转发元素分离的网络设备的内部架构。然而，网络设备仍被表示为单个实体。工作组提供的例子在单个网络设备中将新的转发硬件与第三方控制相结合。因此，控制平面和数据平面在物理上非常接近（例如，相同的盒子或房间）。</p>
<p>ForCES定义了两个逻辑实体，分别称为转发元素(FE)和控制元素(CE)，它们都实现了 ForCES 协议进行通信。FE负责使用底层硬件来提供每个数据包的处理。CE执行控制和信令功能，并使用 ForCES 协议来指示 FE 如何处理数据包。该协议基于主从模型工作，其中FE是从站CE是主站。</p>
<p>ForCES架构的一个重要组成部分是 LFB（Logical Function Block，逻辑功能块）。LFB是驻留在FE上的定义明确的功能块，由CE通过 ForCES 协议控制。LFB使CE能够控制FE的配置以及FE如何处理数据包。</p>
<h2 id="5-数据平面可编程">5 数据平面可编程</h2>
<h3 id="51-数据平面功能">5.1 数据平面功能</h3>
<p>设备的数据平面通过执行一系列操作来处理网络数据包，包括解析数据包，确定需要应用的处理操作的顺序，并根据这些操作的结果进行转发。数据包处理需要以下基本功能步骤：解析、分类、修改、解析和转发。除了基本功能之外，大多数数据包处理系统还可以提供附加服务，例如调度、过滤、计量或流量整形[4]。</p>
<p>随着SDN范式的出现和采用，设备功能变得更加灵活和动态。但是，在传统的网络设备中，数据平面功能深深植根于设备硬件和软件中，因此通常在设备的生命周期内无法更改[5]。对于基于软件的数据包处理系统，需要主要供应商软件更新来更改数据平面功能。此固定功能几乎影响所有数据平面操作。可以加载到匹配动作表中的条目的格式和语义是固定的；设备只能理解一组有限的协议头和字段。例如，以太网交换机不处理第3层字段，过时的路由器将不支持IPv6。可以应用的处理操作的类型以及执行这些操作的顺序由设备供应商设置。</p>
<h3 id="52-p4">5.2 P4</h3>
<p>P4（Programming Protocol-independent Packet Processors）[6]即“独立于协议的可编程数据包处理器”。P4的设计目标如下：</p>
<ol>
<li>可重配置。交换机的数据包处理方式能被重新配置，可以通过编程的方式灵活定义数据平面的报文处理流程，在不更换交换机硬件的前提下，适应快速更迭的网络协议。</li>
<li>协议无关性。交换机支持的数据包处理行为不受协议类型局限，并且管理员可以定制交换机本身支持的协议。</li>
<li>平台无关性。网络管理员能够独立于特定的底层平台来描述报文处理功能，类似于C或者C++程序，管理员编程时不用关注底层架构。</li>
</ol>
<p></p>
<p>P4交换机将流水线处理数据的过程进行抽象和重定义，数据处理单元对数据的处理抽象成匹配和执行匹配-动作表的过程，包头的解析抽象成P4中的解析器，数据处理流程抽象成流控制。</p>
<h3 id="53-其他数据平面编程语言">5.3 其他数据平面编程语言</h3>
<p>P4作为数据平面的领域特定语言（Domain Specific Language，DSL），虽然能够显著提升数据平面的可编程能力，实现一些以前未曾实现过的数据平面功能，为网络数据包处理带来很大的便利，但是由于其表达能力有限以及数据平面本身的局限性，P4并不能成为网络问题的万能解决方案。</p>
<p>除了P4语言，其他数据平面DSL也可以描述数据平面的报文处理逻辑，比如POF，P4和POF的目标都是使底层设备可编程性更强，但是POF的语法更贴近于原来的 OpenFlow 协议规范，并使用类似汇编语言的语法对网络设备进行编程，对不同设备的编程目前采用基于解释翻译而并非编译的方式实现[7]。</p>
<h3 id="p4-相关研究的最新进展">P4 相关研究的最新进展</h3>
<p>自定义数据平面报文处理逻辑，增强数据平面可编程能力，使网络设备灵活支持各种新协议和新功能是学术界和工业界的美好愿景与努力的方向[8]，P4语言与可编程数据平面正是朝该目标迈进的一大步．但是，对于如何使硬件平台或者软件平台支持现有的P4语言、如何设计并优化编译器、如何对P4程序进行调试与性能测试等问题，P4语言联盟和P4语言规范并没有给出相应的解决方案，学术界和工业界也纷纷对可编程数据平面的落地和优化做出了一系列相关研究。</p>
<p>在硬件平台和后端编译器上，文献[9]针对P4语言首次为PMT、Intel、Flexpipe以及Cavium XPliant等可编程交换机提出了编译器设计方法，该工作主要解决了可编程交换机芯片中的匹配动作表配置问题。针对FPGA使用低级语言编程、难移植、调试复杂的问题，文献[10]设计了报文解析器生成模型以及相应的转换算法，可以将P4的解析表述图转化为适合在FPGA上部署的合成VHDL代码。</p>
<p>在软件平台与数据平面虚拟化上，文献[]基于如今最流行的软件交换机Open vSwitch（OVS）提出了可编程的，协议无关的软件交换机架构PISCES，使得软件交换机的数据包转发行为可以使用P4语言进行描述。文献[12]利用了预取和批处理两种方式对基于P4程序编译生成的软件交换机性能进行了优化，使得P4软件交换机编译器生成的代码的执行效率能够接近经过手工代码优化的软件交换机。</p>
<p>对P4进行进一步的扩展上，CacheP4[13]从缓存机制的角度出发，加快P4数据平面的数据包转发处理操作，节省了时间和数据平面资源。P4-CoDel[14]利用P4实现最新的AQM（Active Queue Management，主动队列管理）算法，以便通过AQM算法轻易的增强通信效率。</p>
<p>在应用方面，Order P4-66[15]将P4应用于网络安全领域，分析了受损的可编程设备对于网络性能下降的影响，并提出了降低损害的有效建议。MP-HULA[16]通过数据平面编程，实现传输层多路径感知负载平衡。</p>
<h2 id="6-结束语">6 结束语</h2>
<p>传统网络转发设备种类多样但彼此标准不同，网络受到功能固定的分组转发处理硬件和芯片硬件厂商不兼容协议的限制，存在网络设备更新缓慢、运行成本增加等问题。面对快速升级的网络需求和不断更新的网络业务，网络可编程的能力成为未来网络服务和应用的关键。</p>
<p>网络可编程性的概念始于主动网络研究，随着控制平面和数据平面分离等相关研究经历了几个不同的发展阶段。在SDN兴起时，网络可编程主要体现在软件定义网络的控制平面，面对超大规模网络及大流量，基于SDN控制器对网络节点提供的开放接口进行管理，实现对网络功能和行为的按需管控和新业务的快速部署。控制面可编程催生了一些新应用的产生，比如与人工智能技术结合的DDos检测[17]，以及结合深度学习技术的路由优化[18]，移动通信技术的最新发展也应用了SDN，比如基于SDN的5G[19]、6G[20]移动通信网络架构。</p>
<p>随着新一代高性能可编程数据分组处理芯片及数据平面高级编程语言的出现，以软件编程方式设定数据分组的处理流程并在芯片中编译执行成为现实。</p>
<p>当前，随着数据中心、云计算等场景的兴起，服务器端 CPU（central processing unit）的负担逐渐加重，网络接口卡（NIC, network interface card）可编程[21]成为一个新的趋势，智能网络接口卡（即Smart NIC）可以将网络虚拟化、负载均衡等功能从服务器 CPU 中卸载，从而为应用提供更多的处理能力。因此，当前网络可编程主要集中在编程语言、可编程芯片、智能网络接口卡的研究上。</p>
<p>本文回顾了可编程网络的主要发展过程，涉及早期可编程思想的来源、软件定义网络的主要架构、数据平面可编程以及可编程网络的新发展方向，在网络问题日益突出的今天，可编程网络无疑是解决各种问题的利器。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1]	黄韬,刘江,霍如,魏亮,刘韵洁.未来网络体系架构研究综述[J].通信学报,2014,35(08):184-197.</p>
<p>[2]	任高明.软件定义网络研究综述[J].信息与电脑(理论版),2020,32(04):167-169.</p>
<p>[3]	McKeown N, Anderson T, Balakrishnan H, et al. OpenFlow: enabling innovation in campus networks[J]. ACM SIGCOMM computer communication review, 2008, 38(2): 69-74.</p>
<p>[4]	Michel O, Bifulco R, Retvari G, et al. The programmable data plane: abstractions, architectures, algorithms, and applications[J]. ACM Computing Surveys (CSUR), 2021, 54(4): 1-36.</p>
<p>[5]	耿俊杰,颜金尧.基于可编程数据平面的网络体系架构综述[J].中国传媒大学学报(自然科学版),2019,26(05):38-43.DOI:10.16196/j.cnki.issn.1673-4793.2019.05.007.</p>
<p>[6]	Bosshart P, Daly D, Gibb G, et al. P4: Programming protocol-independent packet processors[J]. ACM SIGCOMM Computer Communication Review, 2014, 44(3): 87-95.</p>
<p>[7]	赵敏,田野.P4与POF协议无关可编程网络技术比较研究[J].网络新媒体技术,2018,7(01):54-58.</p>
<p>[8]	林耘森箫,毕军,周禹,张程,吴建平,刘争争,张乙然.基于P4的可编程数据平面研究及其应用[J].计算机学报,2019,42(11):2539-2560.</p>
<p>[9]	Jose L, Yan L, Varghese G, et al. Compiling packet programs to reconfigurable switches[C]//12th USENIX Symposium on Networked Systems Design and Implementation (NSDI 15). 2015: 103-115.</p>
<p>[10]	Benácek P, Pu V, Kubátová H. P4-to-vhdl: Automatic generation of 100 gbps packet parsers[C]//2016 IEEE 24th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM). IEEE, 2016: 148-155.</p>
<p>[11]	Shahbaz M, Choi S, Pfaff B, et al. Pisces: A programmable, protocol-independent software switch[C]//Proceedings of the 2016 ACM SIGCOMM Conference. 2016: 525-538.</p>
<p>[12]	Bhardwaj A, Shree A, Reddy V B, et al. A preliminary performance model for optimizing software packet processing pipelines[C]//Proceedings of the 8th Asia-Pacific Workshop on Systems. 2017: 1-7.</p>
<p>[13]	Ma Z, Bi J, Zhang C, et al. Cachep4: A behavior-level caching mechanism for p4[M]//Proceedings of the SIGCOMM Posters and Demos. 2017: 108-110.</p>
<p>[14]	Kundel R, Blendin J, Viernickel T, et al. P4-CoDel: Active queue management in programmable data planes[C]//2018 IEEE Conference on Network Function Virtualization and Software Defined Networks (NFV-SDN). IEEE, 2018: 1-4.</p>
<p>[15]	Kassing S, Abbas H, Vanbever L, et al. Order P4-66: Characterizing and mitigating surreptitious programmable network device exploitation[J]. arXiv preprint arXiv:2103.16437, 2021.</p>
<p>[16]	Benet C H, Kassler A J, Benson T, et al. Mp-hula: Multipath transport aware load balancing using programmable data planes[C]//Proceedings of the 2018 Morning Workshop on In-Network Computing. 2018: 7-13.</p>
<p>[17]	孙妍姑.SDN下基于人工智能算法的DDoS攻击检测研究[J].淮南师范学院学报,2019,21(05):135-138.</p>
<p>[18]	王桂芝,吕光宏,贾吾财,贾创辉,张建申.机器学习在SDN路由优化中的应用研究综述[J].计算机研究与发展,2020,57(04):688-698.</p>
<p>[19]	范娟.基于SDN的5G移动通信网络架构研究[J].通讯世界,2018(07):118-119.</p>
<p>[20]	王旭亮,全硕,刘增义,章军.面向6G的新型可编程网络架构研究[J].电信科学,2021,37(12):84-92.</p>
<p>[21]	Stephens B, Akella A, Swift M M. Your programmable NIC should be a programmable switch[C]//Proceedings of the 17th ACM Workshop on Hot Topics in Networks. 2018: 36-42.</p>
]]></description>
</item>
<item>
    <title>SDN十篇推荐论文</title>
    <link>https://leeshy-tech.github.io/sdn_paper_recom/</link>
    <pubDate>Mon, 27 Jun 2022 17:31:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/sdn_paper_recom/</guid>
    <description><![CDATA[<h1 id="sdn十篇推荐论文">SDN十篇推荐论文</h1>
<blockquote>
<p>推荐论文来自BUPT课程“软件定义网络”</p>
</blockquote>
<h2 id="1988the-design-philosophy-of-the-darpa-internet-protocols">(1988)The Design Philosophy of the DARPA Internet Protocols</h2>
<p>DARPA互联网协议的设计哲学</p>
<p>​	Internet 协议套件 TCP/IP 于 15 年前首次提出。 它由国防高级研究计划局 (DARPA) 开发，并已广泛用于军事和商业系统。 虽然有描述协议如何工作的论文和规范，但有时很难从中推断出协议为何如此。 例如，Internet 协议基于无连接或数据报服务模式。 这样做的动机被大大误解了。 本文试图捕捉形成 Internet 协议的一些早期推理。</p>
<h2 id="2005overcoming-the-internet-impasse-through-virtualization">(2005)Overcoming the Internet Impasse through Virtualization</h2>
<p>通过虚拟化克服互联网僵化</p>
<p>当前的互联网陷入僵局，因为新架构无法部署，甚至无法进行充分评估。 本文敦促社区正视这一僵局，并提出一种可以使用虚拟化来克服它的方法。 在这个过程中，我们讨论了建筑的本质以及纯粹主义者和多元主义者之间的争论。</p>
<p>提出使用网络虚拟化技术改变互联网技术革新模式。</p>
<h2 id="2005a-clean-slate-4d-approach-to-network-control-and-management">(2005)A Clean Slate 4D Approach to Network Control and Management</h2>
<p>网络控制和管理的全新 4D 方法</p>
<p>​	当今的数据网络异常脆弱且难以管理。我们认为，这些问题的根源在于控制和管理平面的复杂性——协调网络元素的软件和协议——尤其是决策逻辑和分布式系统问题不可避免地交织在一起的方式。我们提倡对功能进行完全重构，并提出三个关键原则——网络级目标、网络范围的视图和直接控制——我们认为这些原则应该是新架构的基础。遵循这些原则，我们在架构的四个平面（决策、传播、发现和数据）之后确定了一个我们称之为“4D”的极端设计点。 4D 架构将 AS 的决策逻辑与管理网络元素之间交互的协议完全分开。 AS 级目标在决策平面中指定，并通过直接配置驱动数据平面如何转发数据包的状态来强制执行。在 4D 架构中，路由器和交换机只是按照决策平面的要求转发数据包，并收集测量数据以帮助决策平面控制网络。尽管 4D 会对当今的控制和管理平面进行重大更改，但数据包的格式不需要更改；这简化了 4D 架构的部署路径，同时仍然实现了网络控制和管理方面的重大创新。我们希望探索一个极端的设计点将有助于将研究和工业界的注意力集中在这个至关重要且具有智力挑战性的领域上。</p>
<ul>
<li>
<p>解决现有互联网问题的最大困难是分布式系统问题和决策逻辑缠绕在一起。</p>
</li>
<li>
<p>4D技术路线的要义就是分离<strong>分布式计算问题(Distributed Computing Issue)</strong></p>
<p>和<strong>组网逻辑问题(Networking Issue)。</strong></p>
</li>
</ul>
<h2 id="2007ethane-taking-control-of-the-enterprise">(2007)Ethane: Taking Control of the Enterprise</h2>
<p>早期SDN原型</p>
<p>本文介绍了 Ethane，一种适用于企业的新网络架构。 Ethane 允许管理人员定义一个单一的网络范围的细粒度策略，然后直接执行它。 Ethane 将极其简单的基于流的以太网交换机与管理流的准入和路由的集中控制器相结合。 虽然激进，但这种设计向后兼容现有的主机和交换机。 我们已经在硬件和软件中实现了 Ethane，支持有线和无线主机。 在过去的四个月里，我们运营的 Ethane 网络在斯坦福大学的网络中支持了 300 多台主机，这种部署经验对 Ethane 的设计产生了重大影响。</p>
<h2 id="2008openflow-enabling-innovation-in-campus-networks">(2008)OpenFlow: Enabling Innovation in Campus Networks</h2>
<p>​	本白皮书提出了 OpenFlow：一种供研究人员在他们每天使用的网络中运行实验协议的方法。 OpenFlow 基于以太网交换机，具有内部流表和用于添加和删除流条目的标准化接口。我们的目标是鼓励网络供应商将 OpenFlow 添加到他们的交换机产品中，以部署在大学校园骨干网和配线间中。我们认为 OpenFlow 是一种务实的折衷方案：一方面，它允许研究人员以统一的方式以线速和高端口密度在异构交换机上运行实验；另一方面，供应商不需要公开其交换机的内部工作原理。除了允许研究人员在现实世界的流量设置中评估他们的想法外，OpenFlow 还可以作为一个有用的校园组件，用于提议的大规模测试平台（如 GENI）。斯坦福大学的两座建筑物将很快使用商用以太网交换机和路由器运行 OpenFlow 网络。我们将努力鼓励在其他学校部署；我们鼓励您也考虑在您的大学网络中部署 OpenFlow。</p>
<h2 id="2013on-scalability-of-software-defined-networking">(2013)On Scalability of Software-Defined Networking</h2>
<p>论软件定义网络的可扩展性</p>
<p>在本文中，我们解构了软件定义网络中的可扩展性问题，并认为它们不是 SDN 独有的。 我们探讨了不同环境中经常出现的问题，讨论了 SDN 设计空间中的可扩展性权衡，并介绍了一些关于 SDN 可扩展性的最新研究。 此外，我们列举了超出常用性能指标的可扩展性方面被忽视但重要的机遇和挑战。</p>
<h2 id="2013improving-network-management-with-software-defined-networking">(2013)Improving Network Management with Software Defined Networking</h2>
<p>使用软件定义网络改进网络管理</p>
<p>​	网络管理具有挑战性。为了操作、维护和保护通信网络，网络运营商必须处理低级别的供应商特定配置，以实施复杂的高级网络策略。尽管之前提出了许多使网络更易于管理的建议，但由于难以改变底层基础设施，许多网络管理问题的解决方案都只是权宜之计。底层基础设施的僵化几乎没有创新或改进的可能性，因为网络设备通常是封闭的、专有的和垂直集成的。一种新的网络范式，软件定义网络（SDN），主张将数据平面和控制平面分离，使数据平面中的网络交换机成为简单的数据包转发设备，并留下一个逻辑集中的软件程序来控制整个网络的行为。 SDN 为网络管理和配置方法引入了新的可能性。在本文中，我们确定了当前最先进的网络配置和管理机制存在的问题，并介绍了改进网络管理各个方面的机制。我们关注网络管理中的三个问题：实现网络条件和状态的频繁更改，以高级语言提供网络配置支持，以及为执行网络诊断和故障排除的任务提供更好的可见性和控制。我们描述的技术使网络运营商能够以高级策略语言实施广泛的网络策略，并轻松确定性能问题的根源。除了系统本身，我们还描述了校园和家庭网络中的各种原型部署，展示了 SDN 如何改进常见的网络管理任务。</p>
<h2 id="2014a-survey-of-software-defined-networking-past-present-and-future-of-programmable-networks">(2014)A Survey of Software-Defined Networking: Past, Present, and Future of Programmable Networks</h2>
<p>软件定义网络调查：可编程网络的过去、现在和未来</p>
<p>综述了可编程网络的最新进展，重点介绍了SDN。提供了可编程网络的历史视角，从早期的想法到最近的发展。然后介绍了SDN网络的体系结构和OpenFlow标准，讨论了当前基于SDN的协议和服务的实现和测试的替代方案，考察了当前和未来的SDN应用，并探讨了基于SDN模式的有前景的研究方向。</p>
<h2 id="2014software-defined-networking-a-comprehensive-survey">(2014)Software-Defined Networking: A Comprehensive Survey</h2>
<p>在本文中，我们对 SDN 进行了全面调查。我们首先介绍 SDN 的动机，解释它的主要概念以及它与传统网络的区别、它的根源以及关于这种新颖范式的标准化活动。接下来，我们使用自下而上的分层方法展示 SDN 基础设施的关键构建块。我们对硬件基础设施、南向和北向 API、网络虚拟化层、网络操作系统（SDN 控制器）、网络编程语言和网络应用程序进行了深入分析。我们还研究了调试和故障排除等跨层问题。为了预测这种新范式的未来发展，我们讨论了 SDN 的主要正在进行的研究工作和挑战。特别是，我们解决了交换机和控制平台的设计——重点关注弹性、可扩展性、性能、安全性和可靠性等方面——以及运营商传输网络和云提供商的新机遇。最后但同样重要的是，我们分析了 SDN 作为软件定义环境的关键推动者的地位。</p>
<h2 id="2014p4-programming-protocol-independent-packet-processors">(2014)P4: Programming Protocol-Independent Packet Processors</h2>
<p>P4：编写协议无关的包处理器</p>
<p>​	P4 是一种用于编程独立于协议的包处理器的高级语言。 P4 与 OpenFlow 等 SDN 控制协议结合使用。 在目前的形式中，OpenFlow 明确指定了它所操作的协议头。 这组在几年内从 12 个字段增长到 41 个字段，增加了规范的复杂性，同时仍然不能提供添加新标头的灵活性。 在本文中，我们提出 P4 作为 OpenFlow 未来应该如何发展的草案建议。 我们有三个目标： (1) 现场可重构性：一旦部署，程序员应该能够改变交换机处理数据包的方式。 (2) 协议独立性：交换机不应与任何特定的网络协议绑定。 (3) 目标独立性：程序员应该能够独立于底层硬件的细节来描述数据包处理功能。 作为示例，我们描述了如何使用 P4 来配置交换机以添加新的分层标签。</p>
]]></description>
</item>
<item>
    <title>SDN自学习交换机工作原理分析</title>
    <link>https://leeshy-tech.github.io/simple_switch_analyse/</link>
    <pubDate>Mon, 10 Jan 2022 17:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_analyse/</guid>
    <description><![CDATA[<h2 id="自学习交换机">自学习交换机</h2>
<p>交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。</p>
<p>SDN的自学习交换机跟传统交换机不一样的点有：</p>
<ol>
<li>帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。</li>
<li>自学习的过程中可能会有流表的变化。</li>
</ol>
<h2 id="ping命令过程">ping命令过程</h2>
<p>ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。<br>
局域网ping命令的执行过程：<br>
网络模型为：h1  &mdash;-  s1  &mdash;-  h2，两台主机连接到同一个交换机。
假设h1 ping h2</p>
<ul>
<li>首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。</li>
<li>交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。</li>
<li>h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。</li>
<li>h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。</li>
<li>h2收到报文后应答，ping完成。</li>
</ul>
<h2 id="实验分析">实验分析</h2>
<h3 id="实验内容">实验内容</h3>
<ul>
<li>通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a>。</li>
<li>使用OVS搭建网络模型：h1  &mdash;-  s1  &mdash;-  h2，将s1连接到控制器。</li>
<li>h1 ping h2，观察PacketIn消息。</li>
<li>查看s1的流表变化。</li>
</ul>
<p>这里不用mininet平台搭建网络的原因是：mininet主机会定时检查与交换机的连接，导致出现很多的冗余PacketIn消息，不利于观察。</p>
<h3 id="实验结果">实验结果</h3>
<p><br>
当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。<br>
使用<code>ovs-ofctl dump-flows s1</code>命令观察流表，结果如下：  <br>
<br>
执行完ping命令后多了两条流表。</p>
<h3 id="流程分析">流程分析</h3>
<p>日志的输出格式是：packet in &lt;交换机标号&gt; &lt;源mac&gt; &lt;目的mac&gt; &lt;输入端口&gt;<br>
h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 <br>
h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。</p>
<ol>
<li>h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac1--端口1</code>，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。</li>
<li>s1广播，h2收到并学习到h1的mac地址，发送<code>&lt;src = mac2，dst = mac1&gt;</code>的ARP应答报文，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac2--端口2</code>，查找到mac1的对应端口为1，此时下发一条流表<code>in_port=2,output:1</code>，发送PacketOut消息指示s1把这个应答报文转发到端口1。</li>
<li>h1收到应答报文，学习到h2的mac地址，发送<code>&lt;src = mac1，dst = mac2&gt;</code>的ICMP报文。</li>
<li>此时s1中只有一条流表<code>in_port=2,output:1</code>，仍然发送PacketIn消息。</li>
<li>控制器查找到mac2的对应端口为2，下发一条流表<code>in_port=1,output:2</code>，发送PacketOut消息指示s1把这个报文转发到端口2。</li>
<li>之后略</li>
</ol>
<p>所以，整个过程中一共上传了三次PacketIn消息，分别是<code>ma1 ff:ff:ff:ff 1</code>，<code>mac2 mac1 2</code>，<code>mac1 mac2 1</code>。<br>
过程结束s1中有两条流表，分别是<code>in_port=2,src=mac2,dst=mac1,action=output:1</code>,<code>in_port=1,src=mac1,dst=mac2,action=output:2</code>。 
有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。</p>
<h2 id="结束语">结束语</h2>
<h3 id="总结">总结</h3>
<p>要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.51cto.com/wanicy/335207" target="_blank" rel="noopener noreffer">Ping过程 详解 </a><br>
<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a></p>
]]></description>
</item>
<item>
    <title>ryu开发——集线器</title>
    <link>https://leeshy-tech.github.io/simple_hub/</link>
    <pubDate>Sun, 09 Jan 2022 20:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_hub/</guid>
    <description><![CDATA[<h2 id="什么是集线器">什么是集线器</h2>
<p>集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。</p>
<h2 id="实现代码">实现代码</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># simple_hub.py</span>
<span class="kn">from</span> <span class="nn">ryu.base</span> <span class="kn">import</span> <span class="n">app_manager</span>
<span class="kn">from</span> <span class="nn">ryu.controller</span> <span class="kn">import</span> <span class="n">ofp_event</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">MAIN_DISPATCHER</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">set_ev_cls</span>
 
<span class="k">class</span> <span class="nc">L2Switch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2Switch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
 
    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">ofp</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">ofp_parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>
 
        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">ofp</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
            <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
            <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><h2 id="实现逻辑">实现逻辑</h2>
<p>当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。</p>
<h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
]]></description>
</item>
<item>
    <title>ryu源码解读——simple_switch.py</title>
    <link>https://leeshy-tech.github.io/simple_switch_note/</link>
    <pubDate>Sat, 08 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_note/</guid>
    <description><![CDATA[<h2 id="总览">总览</h2>
<p>文件位置：ryu/ryu/app/simple_switch.py
simple_switch.py共110行<br>
1-18：注释<br>
21-29：引库<br>
32-110：继承类RyuApp</p>
<h2 id="32-37">32-37</h2>
<blockquote>
<p>继承类RyuApp，并调用构造函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">SimpleSwitch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="n">OFP_VERSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofproto_v1_0</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">]</span>   <span class="c1"># 声明支持的Open Flow版本</span>
    <span class="c1"># 继承，调用构造函数并添加一个新属性 mac_to_port</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSwitch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div><ul>
<li>编写的程序实际上是Ryu控制器的APP，需要继承类RyuApp。</li>
<li>自学习交换机需要控制器来维护交换机的帧交换表，帧交换便就是mac地址与端口号的对应关系，所以添加一个新属性mac_to_port。</li>
</ul>
<h2 id="39-51">39-51</h2>
<blockquote>
<p>实现一个添加流表的函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># 函数：添加流表</span>
<span class="k">def</span> <span class="nf">add_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span>
        <span class="n">in_port</span><span class="o">=</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">dl_dst</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">dl_src</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="c1"># 源和目的mac地址</span>
        <span class="p">)</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">cookie</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_ADD</span><span class="p">,</span> <span class="c1"># 命令：添加新流表</span>
        <span class="n">idle_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hard_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">priority</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_DEFAULT_PRIORITY</span><span class="p">,</span> <span class="c1"># 优先级：默认</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFF_SEND_FLOW_REM</span><span class="p">,</span> 
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>      <span class="c1">#控制器下发消息</span>
</code></pre></div><h3 id="datapath">datapath</h3>
<p>控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。</p>
<h3 id="协议细节">协议细节</h3>
<dl>
<dt>OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。</dt>
<dt>OFPMatch：流匹配规则。</dt>
<dt>flags：以下三个值之一</dt>
<dd>| OFPFF_SEND_FLOW_REM   当流过期或删除时，发送删除流消息。</dd>
<dd>| OFPFF_CHECK_OVERLAP   首先检查重叠的条目。</dd>
<dd>| OFPFF_EMERG           标记为紧急情况。</dd>
</dl>
<h2 id="53-94">53-94</h2>
<blockquote>
<p>PacketIn消息的处理逻辑：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析数据包</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">pkt</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">Packet</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">eth</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">.</span><span class="n">get_protocol</span><span class="p">(</span><span class="n">ethernet</span><span class="o">.</span><span class="n">ethernet</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eth</span><span class="o">.</span><span class="n">ethertype</span> <span class="o">==</span> <span class="n">ether_types</span><span class="o">.</span><span class="n">ETH_TYPE_LLDP</span><span class="p">:</span>
        <span class="c1"># 忽略LLDP类型的包</span>
        <span class="k">return</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">dst</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">src</span>

    <span class="c1"># 初始化mac_port对应规则</span>
    <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>  

    <span class="c1"># 打印消息</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;packet in </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">dpid</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">)</span> 

    <span class="c1"># 记录此包对应的mac_port对应规则</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span>

    <span class="c1"># 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span>

    <span class="c1"># 封装一个OFPActionOutput类型动作：从out_port端口输出</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">out_port</span><span class="p">)]</span>

    <span class="c1"># 如果已经明确了目的mac的输出端口，那么就下发一条流表</span>
    <span class="k">if</span> <span class="n">out_port</span> <span class="o">!=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

    <span class="c1"># 如果交换机没有缓存该包，那么就把该包还回去</span>
    <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_NO_BUFFER</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># 发送PacketOut消息</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><p>细节分析：</p>
<h3 id="lldp">LLDP</h3>
<h3 id="packetin与packetout">PacketIn与PacketOut</h3>
<p>当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。<br>
所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。<br>
PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。</p>
<h3 id="处理逻辑">处理逻辑</h3>
<ul>
<li>解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。</li>
<li>如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。</li>
<li>如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。</li>
<li>封装PacketOut消息，下发。</li>
</ul>
<h3 id="buffer_id与data">buffer_id与data</h3>
<p>交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。</p>
<ul>
<li>如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。</li>
<li>如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。</li>
</ul>
<h2 id="96-110">96-110</h2>
<blockquote>
<p>如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息。
这个部分不是自学习交换机必需的。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPortStatus</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_port_status_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析消息</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">reason</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">reason</span>
    <span class="n">port_no</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">port_no</span>

    <span class="c1"># 打印</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="k">if</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_ADD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port added </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_DELETE</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port deleted </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_MODIFY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port modified </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;Illeagal port state </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
</code></pre></div><h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
<h3 id="备注">备注</h3>
<p>ryu官方：<a href="https://github.com/faucetsdn/ryu" target="_blank" rel="noopener noreffer">https://github.com/faucetsdn/ryu</a><br>
本人注释版：<a href="https://github.com/leeshy-tech/ryu" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/ryu</a></p>
]]></description>
</item>
<item>
    <title>在树莓派上构建SDWN网络教程</title>
    <link>https://leeshy-tech.github.io/sdn_on_raspberrypi/</link>
    <pubDate>Sat, 08 Jan 2022 16:31:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/sdn_on_raspberrypi/</guid>
    <description><![CDATA[<h2 id="导入">导入</h2>
<p>在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 <br>
OVS：OpenvSwitch的简称，它是一种支持OpenFlow协议的软交换机。 <br>
ryu：基于Python开发的SDN开源控制器。</p>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>树莓派搭载linux操作系统，有无线网卡，利用<code>ifconfig</code>命令查得无线网卡名称。</li>
<li>树莓派之间先组成adhoc网络，参考文章：<a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a></li>
<li>在两台树莓派上安装OVS，参考文章：<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a></li>
<li>在其中一台树莓派上安装ryu控制器。</li>
</ul>
<h2 id="组网步骤">组网步骤</h2>
<p>假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： 
</p>
<h3 id="控制节点-ip--10001">控制节点 IP = 10.0.0.1</h3>
<p>开启控制器（进入ryu/ryu/app/文件夹执行）：</p>
<pre tabindex="0"><code>ryu-manager simple_switch.py
</code></pre><p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.1
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="普通节点-ip--10002">普通节点 IP = 10.0.0.2</h3>
<p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.2
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="关于网卡设置的解释">关于网卡设置的解释</h3>
<blockquote>
<p>将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下：</p>
</blockquote>
<p>无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。</p>
<p>对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。  <br>
创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令：<br>
取消wlan0设置的IP地址：<code>ifconfig wlan0 0</code><br>
设置网卡s1的IP地址为原主机地址：<code>ifconfig s1 10.0.0.1</code><br>
开启网卡s1：<code>ifconfig s1 up</code></p>
<h2 id="测试">测试</h2>
<blockquote>
<p>如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？</p>
</blockquote>
<p>注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。   <br>
查询两个交换机的流表信息：   <br>
<code>ovs-ofctl dump-flows s1</code>    <br>
输出为空，此时交换机中没有流表。 <br>
在控制节点ping普通节点： <br>
<code>ping 10.0.0.2</code><br>
发现可以ping通，同时可以在控制器窗口看到PacketIn消息。<br>
再次查询流表：<code>ovs-ofctl dump-flows s1</code>  <br>
发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。</p>
<h2 id="应用">应用</h2>
<p>模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序：<br>
控制节点：<code>python3 SDN_on_Raspberry_pi/client.py</code><br>
普通节点：<code>python3 SDN_on_Raspberry_pi/sever.py</code> <br>
从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。</p>
<h2 id="结束语">结束语</h2>
<p>因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a><br>
<a href="https://www.sdnlab.com/sdn-guide/14747.html" target="_blank" rel="noopener noreffer">OVS初级教程：使用Open vSwitch构建虚拟网络</a><br>
<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a><br>
<a href="https://www.cnblogs.com/mrwuzs/p/10242737.html" target="_blank" rel="noopener noreffer">ovs之组网实验</a><br>
<a href="https://www.bilibili.com/video/BV1ft4y1a7ip?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">SDN系列学习课程-OpenFlow-Ryu-Mininet</a><br>
<a href="https://www.bilibili.com/video/BV1eg411G7pW?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">TCP/IP网络通信之Socket编程入门</a></p>
<h3 id="备注">备注</h3>
<p>本文依赖代码文件：<a href="https://github.com/leeshy-tech/SDN_on_Raspberry_pi" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/SDN_on_Raspberry_pi</a></p>
]]></description>
</item>
</channel>
</rss>
