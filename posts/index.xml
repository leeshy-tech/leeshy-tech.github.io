<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Leeshy&#39;s Blog | To be humble</title>
        <link>https://leeshy-tech.github.io/posts/</link>
        <description>所有文章 | Leeshy&#39;s Blog | To be humble</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>saili@bupt.edu.cn (Leeshy)</managingEditor>
            <webMaster>saili@bupt.edu.cn (Leeshy)</webMaster><lastBuildDate>Mon, 10 Jan 2022 17:56:06 &#43;0800</lastBuildDate><atom:link href="https://leeshy-tech.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>SDN自学习交换机工作原理分析</title>
    <link>https://leeshy-tech.github.io/simple_switch_analyse/</link>
    <pubDate>Mon, 10 Jan 2022 17:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_analyse/</guid>
    <description><![CDATA[<h2 id="自学习交换机">自学习交换机</h2>
<p>交换机上电启动时，帧交换表为空，随着各主机间的通信，通过自学习算法自动逐渐建立帧交换表。帧交换表是mac地址和端口号的对应关系，交换机端口是固定的，连接的设备是可变的，所以只有建立起帧交换表之后才能明确某目的mac地址的数据包该向哪个端口转发。</p>
<p>SDN的自学习交换机跟传统交换机不一样的点有：</p>
<ol>
<li>帧交换表是由控制器来维护的，比如ryu里的数据结构：mac_to_port[dpid][mac] = port，控制器维护所有与之相连的交换机的帧交换表。</li>
<li>自学习的过程中可能会有流表的变化。</li>
</ol>
<h2 id="ping命令过程">ping命令过程</h2>
<p>ping命令使用ICMP传输协议，用于测试两主机之间的网络连通性。<br>
局域网ping命令的执行过程：<br>
网络模型为：h1  &mdash;-  s1  &mdash;-  h2，两台主机连接到同一个交换机。
假设h1 ping h2</p>
<ul>
<li>首先h1查询自己的mac地址表，若有h2对应的mac地址，就直接设为目的mac，否则发送一个ARP广播包，目的mac设为ff:ff:ff:ff。</li>
<li>交换机收到ARP后，如果交换机中有h2对应的mac地址，就返回给h1，否则向所有端口发送ARP广播。</li>
<li>h2收到ARP报文后，返回ARP应答报文，告诉h1自己的mac地址，同时学习到h1的mac地址。</li>
<li>h1收到应答后，学习到h2的mac地址，封装ICMP报文给h2。</li>
<li>h2收到报文后应答，ping完成。</li>
</ul>
<h2 id="实验分析">实验分析</h2>
<h3 id="实验内容">实验内容</h3>
<ul>
<li>通过ryu控制器实现一个SDN自学习交换机simple_switch.py，分析博客：<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a>。</li>
<li>使用OVS搭建网络模型：h1  &mdash;-  s1  &mdash;-  h2，将s1连接到控制器。</li>
<li>h1 ping h2，观察PacketIn消息。</li>
<li>查看s1的流表变化。</li>
</ul>
<p>这里不用mininet平台搭建网络的原因是：mininet交换机会定时检查与控制器的连接，导致出现很多的冗余PacketIn消息，不利于观察。</p>
<h3 id="实验结果">实验结果</h3>
<p><br>
当h1 ping h2时，出现3条PacketIn消息，之后再ping，不再出现PacketIn消息。<br>
使用<code>ovs-ofctl dump-flows s1</code>命令观察流表，结果如下：  <br>
<br>
执行完ping命令后多了两条流表。</p>
<h3 id="流程分析">流程分析</h3>
<p>日志的输出格式是：packet in &lt;交换机标号&gt; &lt;源mac&gt; &lt;目的mac&gt; &lt;输入端口&gt;<br>
h1：mac地址mac1 = 3e:3b:50:01:23:e6，连接到s1的1号端口。 <br>
h2：mac地址mac2 = d6:07:97:03:df:5b，连接到s1的2号端口。</p>
<ol>
<li>h1 ping h2，h1发送一个目的mac为ff:ff:ff:ff的ARP包，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac1--端口1</code>，查找不到h2连接的端口，发送PacketOut消息指示s1广播这个ARP包。</li>
<li>s1广播，h2收到并学习到h1的mac地址，发送<code>&lt;src = mac2，dst = mac1&gt;</code>的ARP应答报文，s1流表为空，发送PacketIn消息。</li>
<li>控制器学习到<code>mac2--端口2</code>，查找到mac1的对应端口为1，此时下发一条流表<code>in_port=2,output:1</code>，发送PacketOut消息指示s1把这个应答报文转发到端口1。</li>
<li>h1收到应答报文，学习到h2的mac地址，发送<code>&lt;src = mac1，dst = mac2&gt;</code>的ICMP报文。</li>
<li>此时s1中只有一条流表<code>in_port=2,output:1</code>，仍然发送PacketIn消息。</li>
<li>控制器查找到mac2的对应端口为2，下发一条流表<code>in_port=1,output:2</code>，发送PacketOut消息指示s1把这个报文转发到端口2。</li>
<li>之后略</li>
</ol>
<p>所以，整个过程中一共上传了三次PacketIn消息，分别是<code>ma1 ff:ff:ff:ff 1</code>，<code>mac2 mac1 2</code>，<code>mac1 mac2 1</code>。<br>
过程结束s1中有两条流表，分别是<code>in_port=2,src=mac2,dst=mac1,action=output:1</code>,<code>in_port=1,src=mac1,dst=mac2,action=output:2</code>。 
有了这两条流表之后，s1完全按照流表转发，不会产生PacketIn消息和新的流表。</p>
<h2 id="结束语">结束语</h2>
<h3 id="总结">总结</h3>
<p>要始终用流表的思想看待整个过程，PacketIn消息产生的原因是没有匹配的流表。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.51cto.com/wanicy/335207" target="_blank" rel="noopener noreffer">Ping过程 详解 </a><br>
<a href="http://localhost:1313/simple_switch_note/" target="_blank" rel="noopener noreffer">ryu源码解读——simple_switch.py</a></p>
]]></description>
</item>
<item>
    <title>ryu开发——集线器</title>
    <link>https://leeshy-tech.github.io/simple_hub/</link>
    <pubDate>Sun, 09 Jan 2022 20:56:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_hub/</guid>
    <description><![CDATA[<h2 id="什么是集线器">什么是集线器</h2>
<p>集线器是运作在OSI模型中的物理层，它将某个端口收到的包向所有端口广播（也叫洪泛，flood）。</p>
<h2 id="实现代码">实现代码</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># simple_hub.py</span>
<span class="kn">from</span> <span class="nn">ryu.base</span> <span class="kn">import</span> <span class="n">app_manager</span>
<span class="kn">from</span> <span class="nn">ryu.controller</span> <span class="kn">import</span> <span class="n">ofp_event</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">MAIN_DISPATCHER</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">set_ev_cls</span>
 
<span class="k">class</span> <span class="nc">L2Switch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2Switch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
 
    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">ofp</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">ofp_parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>
 
        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">ofp</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ofp_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
            <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
            <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><h2 id="实现逻辑">实现逻辑</h2>
<p>当控制器收到PacketIn消息，下发PacketOut消息，指示交换机将该包洪泛（FLOOD）。</p>
<h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
]]></description>
</item>
<item>
    <title>ryu源码解读——simple_switch.py</title>
    <link>https://leeshy-tech.github.io/simple_switch_note/</link>
    <pubDate>Sat, 08 Jan 2022 21:46:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/simple_switch_note/</guid>
    <description><![CDATA[<h2 id="总览">总览</h2>
<p>文件位置：ryu/ryu/app/simple_switch.py
simple_switch.py共110行<br>
1-18：注释<br>
21-29：引库<br>
32-110：继承类RyuApp</p>
<h2 id="32-37">32-37</h2>
<blockquote>
<p>继承类RyuApp，并调用构造函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">SimpleSwitch</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="n">OFP_VERSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofproto_v1_0</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">]</span>   <span class="c1"># 声明支持的Open Flow版本</span>
    <span class="c1"># 继承，调用构造函数并添加一个新属性 mac_to_port</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSwitch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div><h2 id="39-51">39-51</h2>
<blockquote>
<p>实现一个添加流表的函数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># 函数：添加流表</span>
<span class="k">def</span> <span class="nf">add_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
        <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span>
            <span class="n">in_port</span><span class="o">=</span><span class="n">in_port</span><span class="p">,</span>
            <span class="n">dl_dst</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">dl_src</span><span class="o">=</span><span class="n">haddr_to_bin</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="c1"># 源和目的mac地址</span>
            <span class="p">)</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span>
            <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">cookie</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_ADD</span><span class="p">,</span> <span class="c1"># 命令：添加新流表</span>
            <span class="n">idle_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hard_timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_DEFAULT_PRIORITY</span><span class="p">,</span> <span class="c1"># 优先级：默认</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFF_SEND_FLOW_REM</span><span class="p">,</span> 
            <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>      <span class="c1">#控制器下发消息</span>
</code></pre></div><h3 id="datapath">datapath</h3>
<p>控制器与交换机之间是一条Open Flow数据通路，所以控制器通过datapath来区分不同的交换机，datapath具有一个ofproto参数指示OpenFlow协议内容。ofproto的ofproto_parser定义了协议相关的数据结构。</p>
<h3 id="协议细节">协议细节</h3>
<dl>
<dt>OFPFlowMod：修改流表消息，控制器发送此消息来修改流表。</dt>
<dt>OFPMatch：流匹配规则。</dt>
<dt>flags：以下三个值之一</dt>
<dd>| OFPFF_SEND_FLOW_REM   当流过期或删除时，发送删除流消息。</dd>
<dd>| OFPFF_CHECK_OVERLAP   首先检查重叠的条目。</dd>
<dd>| OFPFF_EMERG           标记为紧急情况。</dd>
</dl>
<h2 id="53-94">53-94</h2>
<blockquote>
<p>PacketIn消息的处理逻辑：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析数据包</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>

    <span class="n">pkt</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">Packet</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">eth</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">.</span><span class="n">get_protocol</span><span class="p">(</span><span class="n">ethernet</span><span class="o">.</span><span class="n">ethernet</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eth</span><span class="o">.</span><span class="n">ethertype</span> <span class="o">==</span> <span class="n">ether_types</span><span class="o">.</span><span class="n">ETH_TYPE_LLDP</span><span class="p">:</span>
        <span class="c1"># 忽略LLDP类型的包</span>
        <span class="k">return</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">dst</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">src</span>

    <span class="c1"># 初始化mac_port对应规则</span>
    <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>  

    <span class="c1"># 打印消息</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;packet in </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">dpid</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">)</span> 

    <span class="c1"># 记录此包对应的mac_port对应规则</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span>

    <span class="c1"># 如果目的mac的对应端口已经知道，就直接设置为输出端口，否则就洪泛</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_port</span> <span class="o">=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span>

    <span class="c1"># 封装一个OFPActionOutput类型动作：从out_port端口输出</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">out_port</span><span class="p">)]</span>

    <span class="c1"># 如果已经明确了目的mac的输出端口，那么就下发一条流表</span>
    <span class="k">if</span> <span class="n">out_port</span> <span class="o">!=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

    <span class="c1"># 如果交换机没有缓存该包，那么就把该包还回去</span>
    <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_NO_BUFFER</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># 发送PacketOut消息</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">in_port</span><span class="p">,</span>
        <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</code></pre></div><p>细节分析：</p>
<h3 id="lldp">LLDP</h3>
<h3 id="packetin与packetout">PacketIn与PacketOut</h3>
<p>当交换机收到某个包之后，没有对应的流表，就向控制器发送PacketIn消息，控制器收到之后，进行一些处理，然后发送PacketOut消息给交换机，指示交换机该如何处理这个包。<br>
所以PacketIn消息应当包含这个包，在控制器处理逻辑里面首先就是解析出这个包。<br>
PacketOut消息应当包含一个action，当交换机收到PacketOut时执行这个action。</p>
<h3 id="处理逻辑">处理逻辑</h3>
<ul>
<li>解析出数据包，根据数据包的mac和输入端口，绑定这个mac和交换机端口。</li>
<li>如果目的mac对应的交换机端口已知，那么就把输出端口赋这个值。如果未知，就指示交换机洪泛这个包。</li>
<li>如果输出不是洪泛，那么就可以下发流表，绑定目的mac和源mac的转发关系。</li>
<li>封装PacketOut消息，下发。</li>
</ul>
<h3 id="buffer_id与data">buffer_id与data</h3>
<p>交换机具有缓存，不知道如何处理某个包时，它可以选择是否暂存这个包。</p>
<ul>
<li>如果没有暂存，那么就应当由控制器通过PacketOut消息把该包传回来，通过OFPPacketOut类的data参数。</li>
<li>如果暂存了，data参数就是None，PacketOut消息指示这个包暂存的位置，也就是buffer_id。</li>
</ul>
<h2 id="96-110">96-110</h2>
<blockquote>
<p>如果端口发生了一些变化，比如端口增加或者删除，那就在命令行打印相关的消息</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPortStatus</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_port_status_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="c1"># 解析消息</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">reason</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">reason</span>
    <span class="n">port_no</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">port_no</span>

    <span class="c1"># 打印</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="k">if</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_ADD</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port added </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_DELETE</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port deleted </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reason</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPPR_MODIFY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;port modified </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;Illeagal port state </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">port_no</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
</code></pre></div><h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.sdnlab.com/1785.html" target="_blank" rel="noopener noreffer">RYU入门教程</a></p>
<h3 id="备注">备注</h3>
<p>ryu官方：<a href="https://github.com/faucetsdn/ryu" target="_blank" rel="noopener noreffer">https://github.com/faucetsdn/ryu</a><br>
本人注释版：<a href="https://github.com/leeshy-tech/ryu" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/ryu</a></p>
]]></description>
</item>
<item>
    <title>在树莓派上构建SDWN网络教程</title>
    <link>https://leeshy-tech.github.io/sdn_on_raspberrypi/</link>
    <pubDate>Sat, 08 Jan 2022 16:31:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/sdn_on_raspberrypi/</guid>
    <description><![CDATA[<h2 id="导入">导入</h2>
<p>在SDN领域的学习，几乎所有的入门实践都是以mininet平台为基础，搭配开源控制器进行实验，但这种实验本质上也只是在一台linux设备上进行SDN网络的仿真罢了，实际应用还是要构建一个实际的物理网络。本文以OVS、ryu控制器和树莓派构建一个SDWN物理网络，SDWN是将SDN对于无线场景的应用，实际区别在于底层网络。 <br>
OVS：OpenvSwitch的简称，他是一种支持OpenFlow协议的软交换机。 <br>
ryu：基于Python开发的SDN开源控制器。</p>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>树莓派搭载linux操作系统，有无线网卡，利用<code>ifconfig</code>命令查得无线网卡名称。</li>
<li>树莓派之间先组成adhoc网络，参考文章：<a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a></li>
<li>在两台树莓派上安装OVS，参考文章：<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a></li>
<li>在其中一台树莓派上安装ryu控制器。</li>
</ul>
<h2 id="组网步骤">组网步骤</h2>
<p>假设两台树莓派的IP分别为10.0.0.1和10.0.0.2，两台树莓派的无线网卡名均为wlan0，在10.0.0.1上搭载控制器，则网络结构如下图： 
</p>
<h3 id="控制节点-ip--10001">控制节点 IP = 10.0.0.1</h3>
<p>开启控制器（进入ryu/ryu/app/文件夹执行）：</p>
<pre tabindex="0"><code>ryu-manager simple_switch.py
</code></pre><p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.1
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="普通节点-ip--10002">普通节点 IP = 10.0.0.2</h3>
<p>OVS的相关操作需要进入管理员模式：</p>
<pre tabindex="0"><code>sudo su
</code></pre><p>开启OVS</p>
<pre tabindex="0"><code>export PATH=$PATH:/usr/local/share/openvswitch/scripts
ovs-ctl start 
</code></pre><p>创建交换机：</p>
<pre tabindex="0"><code>ovs-vsctl add-br s1
</code></pre><p>将无线网卡挂接到交换机的一个端口：</p>
<pre tabindex="0"><code>ovs-vsctl add-port s1 wlan0
</code></pre><p>网卡设置，此部分详解见下方解释：</p>
<pre tabindex="0"><code>ifconfig wlan0 0
ifconfig s1 10.0.0.2
ifconfig s1 up
</code></pre><p>交换机连接控制器：</p>
<pre tabindex="0"><code>ovs-vsctl set-controller s1 tcp:10.0.0.1:6653
</code></pre><h3 id="关于网卡设置的解释">关于网卡设置的解释</h3>
<blockquote>
<p>将网卡wlan0接到OVS上之后，两主机会ping不通，原因如下：</p>
</blockquote>
<p>无线网卡连接到OVS后成为了交换机的一个普通端口，交换机端口只有mac地址没有IP地址，原主机的IP会失效。</p>
<p>对于一般的adhoc网络，主机产生的数据包直接交给无线网卡进行发送。  <br>
创建OVS交换机之后，主机产生的数据包通过交换机的同名端口进入交换机，这个同名端口是Internal类型，类似于一个虚拟网卡，所以我们要将主机的IP地址转移到该虚拟网卡上，就有了以下三条命令：<br>
取消wlan0设置的IP地址：<code>ifconfig wlan0 0</code><br>
设置网卡s1的IP地址为原主机地址：<code>ifconfig s1 10.0.0.1</code><br>
开启网卡s1：<code>ifconfig s1 up</code></p>
<h2 id="测试">测试</h2>
<blockquote>
<p>如何证明我们成功搭载了SDN网络，而不是之前的adhoc网络呢？</p>
</blockquote>
<p>注意我们开启的控制器是simple_switch.py，这个文件是一个实现自学习功能的控制器应用。   <br>
查询两个交换机的流表信息：   <br>
<code>ovs-ofctl dump-flows s1</code>    <br>
输出为空，此时交换机中没有流表。 <br>
在控制节点ping普通节点： <br>
<code>ping 10.0.0.2</code><br>
发现可以ping通，同时可以在控制器窗口看到PacketIn消息。<br>
再次查询流表：<code>ovs-ofctl dump-flows s1</code>  <br>
发现多了两条流表，说明此时交换机已经明确了两台主机的IP地址所对应的端口号。</p>
<h2 id="应用">应用</h2>
<p>模拟控制节点向普通节点分发命令，在两台树莓派上分别运行socket通信程序：<br>
控制节点：<code>python3 SDN_on_Raspberry_pi/client.py</code><br>
普通节点：<code>python3 SDN_on_Raspberry_pi/sever.py</code> <br>
从程序中我们可以看出，这与adhoc网络或者有线网络的socket编程是一模一样的，因为应用层编程不需要考虑网络层架构，只要能ping通即可。</p>
<h2 id="结束语">结束语</h2>
<p>因财力有限，本文只用了两台树莓派进行组网，多台组网操作也是一样的。</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.csdn.net/lby0910/article/details/53420459" target="_blank" rel="noopener noreffer">在树莓派上搭建ad-hoc网络教程</a><br>
<a href="https://www.sdnlab.com/sdn-guide/14747.html" target="_blank" rel="noopener noreffer">OVS初级教程：使用Open vSwitch构建虚拟网络</a><br>
<a href="https://www.cnblogs.com/goldsunshine/p/10331606.html" target="_blank" rel="noopener noreffer">Open vSwitch系列之二 安装指定版本ovs</a><br>
<a href="https://www.cnblogs.com/mrwuzs/p/10242737.html" target="_blank" rel="noopener noreffer">ovs之组网实验</a><br>
<a href="https://www.bilibili.com/video/BV1ft4y1a7ip?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">SDN系列学习课程-OpenFlow-Ryu-Mininet</a><br>
<a href="https://www.bilibili.com/video/BV1eg411G7pW?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click" target="_blank" rel="noopener noreffer">TCP/IP网络通信之Socket编程入门</a></p>
<h3 id="备注">备注</h3>
<p>本文依赖代码文件：<a href="https://github.com/leeshy-tech/SDN_on_Raspberry_pi" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/SDN_on_Raspberry_pi</a></p>
]]></description>
</item>
<item>
    <title>OVS命令笔记</title>
    <link>https://leeshy-tech.github.io/ovs_cli/</link>
    <pubDate>Fri, 07 Jan 2022 16:08:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/ovs_cli/</guid>
    <description><![CDATA[<h2 id="查看信息">查看信息</h2>
<p>查看openvswitch的状态：<code>ovs-vsctl show</code><br>
查看openvswitch中的所有网桥：<code>ovs-vsctl list-br</code><br>
查看网桥的信息：<code>ovs-ofctl show br0</code>  <br>
查看网桥中的所有端口：<code>ovs-vsctl list-ports br0</code><br>
查看网桥各端口状态：<code>ovs-ofctl dump-ports br0</code><br>
查看网桥上的流表：<code>ovs-ofctl dump-flows br0</code> <br>
查看网桥故障模式：<code>ovs-vsctl get-fail-mode br0</code>  <br>
查看网桥是否开启stp协议：<code>ovs-vsctl get bridge br0 stp_enable</code><br>
查看网桥所有配置信息：<code>ovs-vsctl list bridge br0</code> <br>
查看端口所有特性信息：<code>ovs-vsctl list port br0 port1 </code></p>
<h2 id="网桥操作">网桥操作</h2>
<p>添加网桥：<code>ovs-vsctl add-br br0</code> <br>
删除网桥：<code>ovs-vsctl del-br br0</code> <br>
将网桥连接到控制器：<code>ovs-vsctl set-controller br0 tcp:&lt;controller IP&gt;:&lt;port&gt;</code><br>
设置网桥的故障模式：<code>ovs-vsctl set-fail-mode br0 &lt;secure or standalone&gt; </code><br>
给网桥开启stp协议：<code>ovs-vsctl set bridge br0 stp_enable=true</code></p>
<h2 id="端口操作">端口操作</h2>
<p>增加端口：<code>ovs-vsctl add-port br0 port1</code><br>
删除端口：<code>ovs-vsctl del-port br0 port1</code> <br>
设置端口号：<code>ovs-vsctl set Interface port1 ofport_request=&lt;number&gt;</code> <br>
设置端口类型：<code>ovs-vsctl set Interface p4 type=&lt;type&gt;</code>    </p>
<table>
<thead>
<tr>
<th>端口类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal</td>
<td>普通端口</td>
</tr>
<tr>
<td>Internal</td>
<td>这个端口相当于一个虚拟网卡</td>
</tr>
<tr>
<td>Patch</td>
<td>用于连接两个网桥的端口</td>
</tr>
<tr>
<td>Tunne</td>
<td>隧道端口是一种虚拟端口，支持使用gre或vxlan等隧道技术与位于网络上其他位置的远程端口通讯。</td>
</tr>
</tbody>
</table>
<h2 id="网卡操作">网卡操作</h2>
<p>将物理网卡挂接到网桥：<code>ovs-vsctl add-port br0 eth0</code><br>
列出所有挂接到网卡的网桥：<code>ovs-vsctl port-to-br eth0</code><br>
删除网桥上已经挂接的网卡：<code>ovs-vsctl del-port br0 eth0</code></p>
<h2 id="流表操作">流表操作</h2>
<p>添加流表：<code>ovs-ofctl add-flow br0 &lt;match&gt;,&lt;action&gt;</code>   <br>
删除流表：<code>ovs-ofctl add-flow br0 &lt;match&gt;</code></p>
<h3 id="流表动作-action">流表动作 action</h3>
<p>从端口转发：<code>actions=output:&lt;number&gt;</code>  <br>
丢弃数据包：<code>actions=drop</code><br>
广播：<code>actions=NORMAL</code></p>
<h3 id="匹配项-match">匹配项 match</h3>
<p>如有多个匹配项，之间用逗号隔开。  </p>
<table>
<thead>
<tr>
<th>匹配项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in_port=port</td>
<td>网桥端口号</td>
</tr>
<tr>
<td>dl_vlan=vlan</td>
<td>数据包的 VLAN Tag 值</td>
</tr>
<tr>
<td>dl_vlan_pcp=priority</td>
<td>VLAN 优先级，改值取值区间为[0-7]。数字越大，优先级越高。</td>
</tr>
<tr>
<td>dl_src=<!-- raw HTML omitted -->,dl_dst=<!-- raw HTML omitted --></td>
<td>匹配源或者目标的 MAC 地址</td>
</tr>
<tr>
<td>dl_type=ethertype</td>
<td>匹配以太网协议类型 ,IPv4:0x0800,IPv6:0x086dd,ARP:0x0806</td>
</tr>
<tr>
<td>nw_src=<!-- raw HTML omitted -->,nw_dst=<!-- raw HTML omitted --></td>
<td>匹配源或目的IP，前提要设定dl_type</td>
</tr>
<tr>
<td>table=number</td>
<td>指定流表编号</td>
</tr>
<tr>
<td>reg<!-- raw HTML omitted -->=value[/mask]</td>
<td>网桥中寄存器的值</td>
</tr>
<tr>
<td>tp_src=number,tp_dst=number</td>
<td>TCP协议源或目的端口</td>
</tr>
</tbody>
</table>
<h2 id="参考文献">参考文献</h2>
<p><a href="https://www.cnblogs.com/goldsunshine/p/11527928.html" target="_blank" rel="noopener noreffer">OpenvSwitch系列</a></p>
]]></description>
</item>
<item>
    <title>三控电子狗原理分析——光控、磁控、声控</title>
    <link>https://leeshy-tech.github.io/electronic_dog/</link>
    <pubDate>Tue, 04 Jan 2022 21:29:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/electronic_dog/</guid>
    <description><![CDATA[<blockquote>
<p>注：本项目来自BUPT课程《电子工艺实习》</p>
</blockquote>
<h2 id="导入">导入</h2>
<p>电子狗是声控、光控、磁控机电一体化电动玩具。主要工作原理：利用555构成的单稳态触发器，在三种不同的控制方法下，均给以低电平触发，促使电机转动，从而达到了机器狗停走的目的。即：拍手即走、光照即走、磁铁靠近即走，但都只是持续一段时间后就停会下，再满足其中一条件时将继续行走。<br>
原理图如下：
</p>
<p>整个系统可分为<strong>信号转化</strong>、<strong>单稳态触发器</strong>以及<strong>电机驱动</strong>三个部分。</p>
<h2 id="单稳态触发器">单稳态触发器</h2>
<blockquote>
<p>这部分的功能是：将持续时间很短的低电平信号转换为固定时间间隔（1.1RC）的高电平信号以控制电子狗走路持续时间（控制R和C的数值）。</p>
</blockquote>
<p>关于单稳态触发器的原理分析可参考以下文章： 
<a href="https://leeshy-tech.github.io/555timer/" target="_blank" rel="noopener noreffer">555定时器</a></p>
<h2 id="信号转换">信号转换</h2>
<blockquote>
<p>这部分的功能是将磁、光、声信号转换为低电平电信号。</p>
</blockquote>
<h3 id="磁信号">磁信号</h3>
<p></p>
<ul>
<li>磁信号向电信号的转换通过<strong>干簧管</strong>传感器实现，干簧管的电路模型类似于一个磁控开关，外加磁场时开关闭合，常态开关断开（也有常态是闭合的干簧管），详细原理如下：</li>
<li>干簧片相当于一个磁通导体，在尚未操作时，两片簧片并未接触；在通过永久磁铁或电磁线圈产生的磁场时，外加的磁场使两片簧片端点位置附近产生不同的极性, 当磁力超过簧片本身的弹力时，这两片簧片会吸合导通电路；当磁场减弱或消失后,干簧片由于本身的弹性而释放，触面就会分开从而打开电路。</li>
<li>接上拉电阻即可实现常驻高电平，外加磁场时开关闭合输出低电平。<br>
</li>
</ul>
<h3 id="光信号">光信号</h3>
<p></p>
<ul>
<li>光信号向电信号的转变通过<strong>光敏三极管</strong>实现，电路模型相当于光控开关，光照相当于开关闭合，详细原理如下：</li>
<li>光敏三极管的发射极具有光敏特性。它的集电极则与普通晶体管一样，可以获得电流增益，基极一般没有引线。当受到光照时CE两极导通，相当于开关闭合。</li>
<li>同样使用上拉电阻，不再赘述。</li>
</ul>
<h3 id="声信号">声信号</h3>
<p></p>
<ul>
<li>声信号向电信号的转变通过<strong>麦克风</strong>实现，目前常用的麦克风有驻极体电容麦克风（ECM）和微机电麦克风（MEMS Micphone）。在电子狗实验中使用的是ECM，声波压力推动极板后退使得电容两极电压升高，从而将声信号转换为了电压信号。</li>
<li>因需要对电压放大，驻极体麦克风内部有一个场效应管，正常工作需要加一个直流偏置，其驱动电路之一为：<br>
 <br>
电容的作用是隔直流。</li>
<li>应用于电子狗的电路设计如下：<br>
 <br>
左侧为驱动电路，中间加一级共射放大器，右侧是二极管反相器，当麦克风接收到声音信号时，产生交流电压，放大到二级管基极，二极管截止，输出接地，即输出低电平。</li>
</ul>
<h3 id="仿真">仿真</h3>
<p>干簧管和光敏二极管的电路模型都很简单，没有仿真的必要，以电阻分压的瞬间变化模拟麦克风输出的交流电压，仿真电路如下： <br>
 <br>
仿真结果显示，开关闭合产生的电压波动输出了约50ms左右的低电平，这是非常不合适的，因为实际的麦克风产生的电压波动情况远远复杂于我们的模拟，会产生持续时间更长的低电平信号，而后级的单稳态触发器，当输入低电平信号持续时间大于1.1RC时，输出高电平的时间会相应的延长，我们想要的应当是一个持续时间很短的电平信号。<br>
 <br>
解决方法是加入<strong>负反馈</strong>：<br>
<br>
图中绿色部分为增加的负反馈电路，当555定时器输出高电平时，C5充电将Q2 B极电位拉高，使其截止，相当于开关闭合，从而将Q3的B极电位拉低，使得Q3的C极低电位只持续很短的时间。<br>
重新仿真结果如下：<br>
<br>
低电平的持续时间变为500us左右。</p>
<h2 id="电机驱动">电机驱动</h2>
<blockquote>
<p>此部分的功能是利用555定时器输出的高电平信号驱动电机转动</p>
</blockquote>
<p>电动机是怎么驱动的？非常简单，电池分别接正负极即可。 <br>
但是，在已有的场景下，不能使用这种方式，即把555定时器的输出端3号管脚接到电动机正极，地接电动机负极。 <br>
原因是：555定时器的<strong>驱动能力不足</strong>。<br>
<br>
查询555定时器（NE555P）的数据手册可知，输出电流最大只有225mA左右，常见的电动玩具马达空载驱动电流在600mA左右，555定时器是远不足以驱动马达的。 <br>
<br>
最简单的放大电流的方法就是晶体管反相器，所以电机驱动的电路原理图如下：<br>
<br>
并联两个三极管增大放大倍数，二极管是防止电机反转，注意这是一个反相器，所以要接到电动机的负极。<br>
用灯泡代替电动机，简单仿真如下： <br>
<br>
注意此处输入端用单刀双掷开关，单开关断开是悬空状态，不是输入低电平。 <br>
电源两端并联电容是为了稳压和滤波。</p>
<h2 id="总体仿真">总体仿真</h2>
<p>将以上模块合并，仿真图如下（光敏二极管用光耦合器代替）： <br>
<br>
仿真结果：<br>
<br>
电路启动时触发一次电子狗，三种信号各触发一次，注意这里光信号和磁信号使用的是回弹式开关，为下文埋下了伏笔。</p>
<h2 id="改进">改进</h2>
<p>学校提供的原理图的分析就到这里了，但实际做实验的时候有一些不方便的地方，比如实验室是常亮状态，光照就会一直触发电子狗，必须遮住光，暴露一下就要马上再遮住，在仿真中使用回弹式开关也是这个原因，还是在于单稳态触发器的输入信号不能持续太长时间，我提出的改进方法如下：</p>
<h3 id="改为黑暗触发">改为黑暗触发</h3>
<p>这种改进方案很简单，在光信号转化模块后面加一个二极管反相器就可以。</p>
<h3 id="改为边沿触发">改为边沿触发</h3>
<p>改进方案与仿真结果如图所示：<br>
 <br>
开关关闭和开启会被转化为一个短暂的低电平信号，这个信号的持续时间可以通过调整R和C的值来改变。<br>
原理：利用一阶RC电路将原输入信号做一个短暂延时，再与原信号做同或运算，延时的部分就被计算为了0，其他时刻为1。 <br>
</p>
<blockquote>
<p>当初写实验报告的时候只简单写了一个“用边沿触发器实现即可”，现在想想还真不是这么回事。</p>
</blockquote>
<h2 id="结束语">结束语</h2>
<h3 id="体会">体会</h3>
<p>这门课我还是学到了很多东西的。<del>但是我看了看实验报告的标题“电子狗<strong>组装</strong>”，实在是很让人难蚌。</del></p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://leeshy-tech.github.io/555timer/" target="_blank" rel="noopener noreffer">555定时器_Leeshy&rsquo;s Blog</a><br>
<a href="https://www.taobao.com/list/item/625943357428.htm?spm=a21wu.10013406-cat.taglist-content.5.36c01e2eQtFCB2" target="_blank" rel="noopener noreffer">小马达电机_淘宝网</a>   <br>
<a href="http://www.chinahuaren.com/shen-me-shi-gan-huang-guan-yi/582.html" target="_blank" rel="noopener noreffer">干簧管_华壬电子</a> <br>
<a href="https://baike.baidu.com/item/%E5%85%89%E7%94%B5%E4%B8%89%E6%9E%81%E7%AE%A1/9483833" target="_blank" rel="noopener noreffer">光电三极管_百度百科</a><br>
<a href="https://blog.csdn.net/weixin_36489344/article/details/113014008" target="_blank" rel="noopener noreffer">一文看懂咪头的工作原理及结构（驻极体话筒）</a></p>
<h3 id="备注">备注</h3>
<p>本文仿真使用的是Multisim，原理图绘制使用的是立创EDA。<br>
本文依赖文件：<a href="https://github.com/leeshy-tech/Electronic-Design/tree/main/e-dog" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/Electronic-Design/tree/main/e-dog</a><br>
NE555P数据手册：<a href="https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer</a></p>
]]></description>
</item>
<item>
    <title>555定时器</title>
    <link>https://leeshy-tech.github.io/555timer/</link>
    <pubDate>Sun, 02 Jan 2022 22:07:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/555timer/</guid>
    <description><![CDATA[<h2 id="什么是555定时器">什么是555定时器</h2>
<p>555定时器是一种集成电路芯片，常被用于定时器、脉冲产生器和振荡电路。555可被作为电路中的延时器件、触发器或起振元件。<br>
</p>
<p>内部组成如下：由比较器C1C2、RS触发器、缓冲非门G、放电二极管T组成</p>
<p></p>
<h2 id="芯片分析">芯片分析</h2>
<p>电压比较器：一种模拟输入、数字输出的接口电路，输出特性如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">in</th>
<th style="text-align:center">out</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Vp &gt; Vn</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">Vp &lt; Vn</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>在555定时器内部，左侧是纯电阻分压电路，将比较器阈值设置为</p>
<p>$$
V_{P1}=\frac{2}{3} V_{cc}, V_{N2}=\frac{1}{3} V_{cc}
$$</p>
<p>C1C2的输出特性如下：   </p>
<table>
<thead>
<tr>
<th style="text-align:left">C1</th>
<th style="text-align:center"></th>
<th style="text-align:left">C2</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:center">out</td>
<td style="text-align:left">in</td>
<td style="text-align:center">out</td>
</tr>
<tr>
<td style="text-align:left">Vp &gt; 2/3Vcc</td>
<td style="text-align:center">0</td>
<td style="text-align:left">Vn &gt; 1/3Vcc</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">Vp &gt; 2/3Vcc</td>
<td style="text-align:center">1</td>
<td style="text-align:left">Vn &lt; 1/3Vcc</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>结合RS触发器的真值表可得555定时器的真值表如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Ui1</th>
<th style="text-align:center">Ui2</th>
<th style="text-align:left">复位Rd</th>
<th style="text-align:center">Uo</th>
<th style="text-align:center">放电管T</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:center">x</td>
<td style="text-align:left">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">导通</td>
</tr>
<tr>
<td style="text-align:left">&lt;2/3Vcc</td>
<td style="text-align:center">&lt;1/3Vcc</td>
<td style="text-align:left">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">截止</td>
</tr>
<tr>
<td style="text-align:left">&gt;2/3Vcc</td>
<td style="text-align:center">&gt;1/3Vcc</td>
<td style="text-align:left">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">导通</td>
</tr>
<tr>
<td style="text-align:left">&lt;2/3Vcc</td>
<td style="text-align:center">&gt;1/3Vcc</td>
<td style="text-align:left">1</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">不变</td>
</tr>
</tbody>
</table>
<h2 id="典型应用">典型应用</h2>
<ul>
<li>单稳态电路</li>
<li>多谐振荡器</li>
<li>施密特触发器</li>
</ul>
<h2 id="555定时器为核心的单稳态电路">555定时器为核心的单稳态电路</h2>
<h3 id="理论分析">理论分析</h3>
<p>应用电路如下：<br>
</p>
<ul>
<li>稳定状态时，管脚2输入信号为高电平，管脚6跨电容与地相连，相当于输入低电平，复位引脚4接高电平，故输出保持低电平不变，放电二极管保持导通不变。</li>
<li>当输入信号的下降沿到来，输出变为高电平，放电二极管截止，管脚7向外放电，电容C开始充电，直到$
u_C=\frac{2}{3} V_{cc}$
若忽略晶体管的饱和压降，则充电时间为
$t_w=RCln \frac{\mathrm{Vcc}}{Vcc-\frac{2}{3} Vcc} =RCln 3 \approx 1.1 RC$</li>
<li>当输入信号回到高电平且电容充电完毕后，输出回到低电平，放电二极管截止。</li>
</ul>
<h3 id="仿真验证">仿真验证</h3>
<p>使用Multisim仿真，电路如下：</p>
<p></p>
<p>选用回弹式开关使输入信号在电容充电完毕之前回到高电平，以便于从示波器图形上测得充电时间。 <br>
仿真结果：</p>
<p><br>
电路行为与理论分析一致，根据理论分析公式
$\mathrm{t}_{\mathrm{w}}=1.1 \times 10 \mathrm{k} \times 4.7 \mathrm{u}=51.7 \mathrm{~ms} $,仿真测得充电时间为50.94ms，且充满后电压为2.985V，与理论分析相符的很好。</p>
<h3 id="总结">总结</h3>
<p>该单稳态触发器的功能总结为：将低电平脉冲信号（持续时间小于1.1RC）转化为持续时间为1.1RC的高电平信号，持续时间大于1.1RC的话，就只是由低电平转化为高电平。</p>
<h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.csdn.net/acslsr/article/details/105730908" target="_blank" rel="noopener noreffer">555定时器及应用</a><br>
<a href="https://baike.baidu.com/item/%E7%94%B5%E5%8E%8B%E6%AF%94%E8%BE%83%E5%99%A8/775444" target="_blank" rel="noopener noreffer">电压比较器_百度百科</a> <br>
<a href="https://baike.baidu.com/item/555%E5%AE%9A%E6%97%B6%E5%99%A8/6740686" target="_blank" rel="noopener noreffer">555定时器_百度百科</a><br>
<a href="https://item.szlcsc.com/47753.html" target="_blank" rel="noopener noreffer">NE555P_立创商城</a></p>
<h3 id="备注">备注</h3>
<p>仿真文件及数据手册：<a href="https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/Electronic-Design/tree/main/555timer</a></p>
]]></description>
</item>
</channel>
</rss>
