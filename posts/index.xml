<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Leeshy&#39;s Blog | To be humble</title>
        <link>https://leeshy-tech.github.io/posts/</link>
        <description>所有文章 | Leeshy&#39;s Blog | To be humble</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>saili@bupt.edu.cn (Leeshy)</managingEditor>
            <webMaster>saili@bupt.edu.cn (Leeshy)</webMaster><lastBuildDate>Tue, 24 May 2022 17:41:06 &#43;0800</lastBuildDate><atom:link href="https://leeshy-tech.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>论文笔记——AMM: Attentive Multi-field Matching for News Recommendation Matching</title>
    <link>https://leeshy-tech.github.io/ammattentive_multi-field_matching/</link>
    <pubDate>Tue, 24 May 2022 17:41:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/ammattentive_multi-field_matching/</guid>
    <description><![CDATA[<h1 id="amm-attentive-multi-field-matching-for-news-recommendation">AMM: Attentive Multi-field Matching for News Recommendation</h1>
<h2 id="论文概况">论文概况</h2>
<p><a href="https://dl.acm.org/doi/abs/10.1145/3404835.3463232" target="_blank" rel="noopener noreffer">https://dl.acm.org/doi/abs/10.1145/3404835.3463232</a></p>
<p>SIGIR &lsquo;21: Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval</p>
<p>July 2021 Pages 1588–1592</p>
<p><a href="https://doi.org/10.1145/3404835.3463232" target="_blank" rel="noopener noreffer">https://doi.org/10.1145/3404835.3463232</a></p>
<p>自翻：<a href="https://github.com/leeshy-tech/PaperTranslate/blob/main/AMMAttentive_Multi-field_Matching.md" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/PaperTranslate/blob/main/AMMAttentive_Multi-field_Matching.md</a></p>
<h2 id="引言">引言</h2>
<p>​		用户兴趣与候选新闻的准确匹配是准确的个性化新闻推荐的前提。现有的方法主要是通过顺序或注意力模型聚合用户之前浏览过的新闻来学习用户的兴趣向量，然后将其与候选新闻向量进行匹配，取得了相当大的进展。例如，NPA [12] 根据候选新闻和之前点击的新闻之间的相似性来学习用户表示。 LSTUR [1] 使用 GRU 网络从点击的新闻中模拟短期和长期的用户兴趣。 NAML [11] 和 NRMS [13] 应用注意力网络从点击的新闻中学习用户表示。 FIM [9] 为每个新闻提取多级表示，并通过卷积执行细粒度匹配。然而，这些方法中的大多数将每个用户和新闻表示为单个向量，这可能会丢失文本匹配信号（例如，词级关系）。因此，我们的方法不是简单地将用户浏览的新闻建模为一个整体，而是关注每个浏览的候选新闻对之间的关系，以捕获细粒度的语义匹配表示。此外，这种对设计是在线服务友好的，匹配的表示可以离线存储，以避免重复计算。在这里，我们首先使用 BERT 来学习每个浏览候选新闻对在不同语义级别的匹配表示，然后将它们聚合到最终的用户新闻匹配信号。</p>
<p>​	此外，上述方法基于单视图新闻信息[1,9,13]或多视图信息[11]学习新闻之间的语义相关性，它们仅利用字段内语义相关性（例如，标题-标题，正文-正文）。 但有时，跨领域信息（例如标题-摘要、标题-正文）可能有利于新闻匹配。 比如新闻𝑎的标题信息丰富，而新闻𝑏的标题很吸引人，新闻𝑎的标题和新闻𝑏的正文匹配可能更好。 因此，与每条新闻相关的多个字段可能包含互补信息，这些信息促使我们学习多字段（字段内和跨字段）匹配表示。</p>
<p>​	在本文中，我们提出了一种注意力多字段匹配（AMM）框架，该框架捕获每个浏览候选新闻对的多字段语义匹配表示，然后将这些表示聚合为最终的用户新闻匹配信号，用于新闻推荐。 这项工作的主要贡献总结如下：</p>
<ul>
<li>我们提出了一种新的方法，专注于分离的浏览候选新闻对的匹配，以捕获文本语义匹配信号，这对在线服务很友好。</li>
<li>我们设计了 AMM 框架，以在领域内和跨领域的方式中提取多领域匹配表示，以深入探索用户的兴趣。</li>
<li>我们对两个公共基准数据集进行了实验，以证明我们方法的有效性。</li>
</ul>
<h2 id="我们的方法">我们的方法</h2>
<p>图 1 显示了 AMM 的整体架构。 首先，我们为每个浏览的候选新闻构建多字段对输入。 然后，匹配编码器用于提取每对输入的匹配表示。 最后，我们将所有对的匹配表示聚合到用户新闻信号以估计点击概率。</p>
<p></p>
<h3 id="21-多头部匹配">2.1 多头部匹配</h3>
<p>​	不同的新闻字段通常可以相互补充。 为了更好地编码浏览-候选匹配，我们利用字段内和跨字段匹配作为多字段信息来增强匹配表示。</p>
<p>​	给定用户浏览的新闻$\left[N_{1}, N_{2}, \ldots, N_{i}\right]$和候选新闻$N_x$，对于每个浏览-候选对$\left(N_{i}, N_{c}\right)$，我们建立多头部对输入$\left[N_{i}^{m}, N_{c}^{n}\right]$，其中$m \in{t, a, b},n \in{t, a, b}$，t、a、b分别是新闻的标题、摘要、主体。我们将新闻标题$N^t$表示为词向量$\left[w_{1}^{t}, w_{2}^{t}, \ldots, w_{\left|N^{t}\right|}^{t}\right]$，新闻摘要$N^a$表示为$\left[w_{1}^{a}, w_{2}^{a}, \ldots, w_{|N a|}^{a}\right]$，新闻主体$N^b$表示为$\left[w_{1}^{b}, w_{2}^{b}, \ldots, w_{\left|N^{\prime}\right|}^{b}\right]$，其中$\left|N^{t}\right|\left|N^{a}\right|$和$\left|N^{b}\right|$分别表示标题、摘要、主体的长度。</p>
<p>​	在这项研究中，如图 1 所示，不仅像$\left[N_{i}^{t}, N_{c}^{t}\right]$（标题和标题）这样的字段内对输入，而且像$\left[N_{i}^{t}, N_{c}^{b}\right]$（标题和正文）这样的跨字段对输入都被获得 ，这些输入对中的每一个都被馈送到匹配编码器以获得其匹配表示。 我们最终将这些表示串接为浏览候选新闻对的多字段匹配表示。</p>
<h3 id="22-匹配编码器">2.2 匹配编码器</h3>
<p>该模块用于学习每个浏览过的新闻和候选新闻之间的语义匹配。 我们将来自多字段匹配的浏览-候选多字段对作为输入，然后将其输入到来自 Transformers (BERT) [4] 的双向编码器表示中，以进行匹配表示学习。</p>
<ul>
<li>
<p>多头部自注意层</p>
<p>该子层旨在捕获句子的上下文感知语义匹配。 使用多头，来自不同位置的不同语义子空间的信息是可联合学习的，这对于捕获不同标记之间的匹配信号非常有帮助。</p>
</li>
<li>
<p>位置智慧型前馈网络</p>
<p>这个子层的目的是赋予模型非线性和不同维度之间的相互作用，这是一个完全连接的前馈网络(FFN)，它由两个线性变换组成，中间有一个ReLU激活。</p>
</li>
</ul>
<p>另外，对每个子层进行残差连接和层归一化处理。最后，我们可以通过该匹配编码器得到每个浏览-候选新闻的多字段对的匹配表示。</p>
<h3 id="23-匹配聚合器">2.3 匹配聚合器</h3>
<p>​	匹配聚合器用于聚合每个浏览新闻和候选新闻的匹配表示，以获得最终的用户新闻匹配信号。我们使用以下三种类型的聚合器获得最终的用户新闻匹配表示$\tilde{M}$：</p>
<ul>
<li>
<p>最大/平均聚合器：对的匹配嵌入直接取最大或平均作为用户-新闻匹配嵌入。
$$
\tilde{M}=\text { Aggregate }(M)=\max / \operatorname{mean}(M)\tag 5
$$</p>
</li>
<li>
<p>注意力聚合器：使用门限注意网络 [2] 来学习 𝑀 的组合权重，它应用具有$W_h$和$b_h$的全连接神经网络，使用 tanh 作为第一层激活函数，然后使用$W_o$和$b_o$构造第二个全连接神经网络来学习在等式（6）中定义的组合权重 𝑟 ，最后在等式（7）中计算词向量的线性组合。
$$
\tilde{M}=\text { Aggregate }(M)=\mathbf{r}^{\top} M\tag 6
$$</p>
<p>$$
r=\operatorname{softmax}\left(\tanh \left(\tilde{E} W_{h}+b_{h}\right) W_{o}+b_{o}\right)\tag 7
$$</p>
</li>
</ul>
<h3 id="24-点击预测">2.4 点击预测</h3>
<p>最后，我们介绍点击预测模块。 将<strong>用户-新闻匹配表示</strong>表示为$\tilde{M}$，点击概率 𝑦 通过应用全连接层计算：
$$
y=\operatorname{softmax}\left(\tilde{M} W^{o}+b^{o}\right)\tag 8
$$
其中$W^{o} \in \mathbb{R}^{d^{\prime} \times 1}$和$b^{o} \in \mathbb{R}^{1}$是可学习参数。</p>
<h2 id="3-实验">3 实验</h2>
<h3 id="31-实验设置">3.1 实验设置</h3>
<h4 id="数据集">数据集</h4>
<ul>
<li>MIND</li>
<li>Adressa</li>
</ul>
<h4 id="评价指标">评价指标</h4>
<p>​	我们使用 AUC、MRR、nDCG@𝐾，其中𝐾 = 5, 10 用于 MIND，𝐾 = 1, 3 用于 Adressa，作为我们的评估指标。 性能是所有展示日志中这些指标的平均值。</p>
<h3 id="32-性能评估">3.2 性能评估</h3>
<p>​	我们通过将 AMM 与几种基准方法进行比较来评估 AMM 的性能，</p>
<ul>
<li>LibFM [8]，分解机（FM）；</li>
<li>DeepFM[6]：一种结合了FM和神经网络的深度分解机；</li>
<li>DKN[10]，一种基于知识感知CNN的深度新闻推荐方法；</li>
<li>NPA[12]，引入注意力机制来选择重要的词和新闻；</li>
<li>NAML [11]，一种具有注意力多视图学习的神经新闻推荐方法；</li>
<li>LSTUR [1]，它使用 GRU 从点击历史中对短期和长期兴趣进行建模；</li>
<li>NRMS [13]，它使用多头自注意力来学习用户和新闻表示；</li>
<li>FIM[9]，一种用于神经新闻推荐的细粒度兴趣匹配方法；</li>
<li>AMM，我们的方法。</li>
</ul>
<p></p>
<ul>
<li>使用深度神经网络提取新闻语义表示的方法（3-8）比基于特征的方法（1-2）表现更好。这种性能改进应归功于更好的新闻表示方法。</li>
<li>在方法（3-8）中，NAML 在 MIND 中表现最好，NRMS 在 Adressa 中表现最好，这是因为 NAML 使用了不同种类的新闻信息，而 NRMS 应用了多头自注意力来进一步捕捉单词和点击新闻互动。 FIM 在所有基线中的 Adressa 中表现最好，因为它可以捕获更细粒度的兴趣匹配信号。</li>
<li>我们提出的 AMM 通过考虑分离的浏览候选新闻对和跨字段匹配来捕获多字段的更好的文本语义匹配，在所有指标方面在两个数据集上实现了最佳性能。</li>
</ul>
<h3 id="33-消融实验">3.3 消融实验</h3>
<p></p>
<ul>
<li>比较了AMM与三个单一字段(标题、摘要、正文)在MIND上的性能。
<ul>
<li>带有标题和正文的AMM的表现优于带有摘要的AMM，这表明标题和正文比摘要更有利于新闻表征。</li>
<li>此外，单个标题或正文的AMM的性能优于最佳基准，表明了分离策略引入文本语义匹配的必要性。</li>
</ul>
</li>
<li>通过实验验证了多领域匹配的有效性。
<ul>
<li>AMM多字段比AMM内字段性能更好，这可能是因为通过跨字段匹配可以融合更多的互补信息，字段内和多字段信息的集成可以提高用户新闻匹配，捕捉细粒度用户的兴趣。</li>
</ul>
</li>
<li>探讨了不同匹配聚合器的有效性。
<ul>
<li>我们可以看到带有注意力聚合器的 AMM 的性能略好于带有最大+平均池化的 AMM。 而且，最大+平均池化的表现也比 最佳基准方法好很多，验证了多字段语义匹配的有效性，这些简单的操作让在线服务更有可能。</li>
</ul>
</li>
</ul>
<h2 id="结论">结论</h2>
<p>​	在本文中，我们提出了一种新颖的注意力多领域匹配（AMM）新闻推荐框架。 我们建议以新闻分离的方式学习用户-新闻匹配表示，捕获每对浏览候选新闻的匹配表示，然后将这些表示聚合为最终匹配信号，从而获得细粒度的语义匹配信息以及它是在线服务友好的。 此外，我们的方法同时考虑了字段内和跨字段作为多字段匹配，利用了字段间的互补信息，提高了新闻对的匹配表示。 两个公共基准数据集的实验结果证明了 AMM 的最新性能。</p>
]]></description>
</item>
<item>
    <title>论文笔记——Personalized News Recommendation with Knowledge-aware Interactive Matching</title>
    <link>https://leeshy-tech.github.io/personalized_news_recommendation/</link>
    <pubDate>Mon, 23 May 2022 15:03:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/personalized_news_recommendation/</guid>
    <description><![CDATA[<h1 id="personalized-news-recommendation-with-knowledge-aware-interactive-matching">Personalized News Recommendation with Knowledge-aware Interactive Matching</h1>
<p>基于知识感知交互匹配的个性化新闻推荐</p>
<h2 id="论文概况">论文概况</h2>
<p><a href="https://dl.acm.org/doi/abs/10.1145/3404835.3462861" target="_blank" rel="noopener noreffer">https://dl.acm.org/doi/abs/10.1145/3404835.3462861</a></p>
<p>SIGIR &lsquo;21: Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval</p>
<p>July 2021 Pages 61–70</p>
<p><a href="https://doi.org/10.1145/3404835.3462861" target="_blank" rel="noopener noreffer">https://doi.org/10.1145/3404835.3462861</a></p>
<p>自翻：<a href="https://github.com/leeshy-tech/PaperTranslate/blob/main/Personalized_news_recommendation_with_%20Knowledge-aware_Interactive_Matching.md" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/PaperTranslate/blob/main/Personalized_news_recommendation.md</a></p>
<h2 id="摘要">摘要</h2>
<p>​	在本文中，我们提出了一种用于新闻推荐的知识感知交互式匹配方法。我们的方法以交互方式对候选新闻和用户兴趣进行建模，以促进它们的准确匹配。我们设计了一个知识感知新闻协同编码器，在知识图谱的帮助下捕获它们在语义和实体中的相关性，交互式地学习点击新闻和候选新闻的表示。我们还设计了一个用户新闻协同编码器来学习候选新闻感知用户兴趣表示和用户感知候选新闻表示，以实现更好的兴趣匹配。在两个真实世界数据集上的实验验证了，我们的方法可以有效地提高新闻推荐的性能。</p>
<h2 id="1-引言">1 引言</h2>
<p>​	现有方法通常根据其文本信息对候选新闻进行建模，并以独立的方式从用户的点击历史中推断出用户兴趣[21, 37]。 候选新闻文章可能包含多个方面和实体 [18、33]，并且用户可能有多个兴趣 [32]。 因此，候选新闻和用户兴趣的独立建模可能不如兴趣匹配[31]。</p>
<p>​	在本文中，我们探索更好地模拟候选新闻和用户兴趣之间的相关性，以实现准确的兴趣匹配。 我们的论文受到以下观察的启发。</p>
<p></p>
<ol>
<li>
<p>候选新闻可能涵盖不同的方面和实体，并且用户可能有多种兴趣。</p>
<p>例如，图中 候选新闻2 与篮球明星和政治家有关，含有多个实体（库里和特朗普）。示例用户对车、音乐、体育等领域感兴趣，第二个候选新闻只能匹配特定的用户兴趣即“体育”，但是用户可能只对实体“库里”感兴趣。所以如果独立建模，用候选新闻匹配用户兴趣的效果是较差的。</p>
</li>
<li>
<p>候选新闻和点击新闻的语义匹配有助于更准确地进行兴趣匹配。</p>
<p>例如，第二条点击新闻也与第一条候选新闻有语义相关性，因为它们提到了相同的事件。基于这些语义相关性，我们可以推断用户可能对第一个候选新闻感兴趣。</p>
</li>
<li>
<p>借助知识图谱，点击新闻和候选新闻中实体之间的知识匹配也有助于了解用户对候选新闻的兴趣。</p>
<p>例如，第 4 条点击新闻中的实体“史蒂夫·科尔”与第 2 条候选新闻中的实体“斯蒂芬·库里”具有内在关联，因为前者和后者分别是“NBA”勇士队的球员和教练。根据知识匹配，我们可以推断出用户可能对第二个候选新闻感兴趣。因此，在语义和知识层面利用点击新闻和候选新闻之间的相关性有利于兴趣匹配。</p>
</li>
</ol>
<p>​	在本文中，我们提出了一种用于个性化新闻推荐的知识感知交互式匹配框架（命名为KIM）。我们的方法可以交互地对候选新闻和用户兴趣进行建模，以学习候选新闻感知的用户兴趣表示和用户感知的候选新闻表示，从而更准确地匹配用户兴趣和候选新闻。在该框架中，我们提出了一种知识协同编码器，借助知识图谱从点击新闻中的实体与候选新闻中的实体之间的相关性来建模用户对候选新闻的兴趣。</p>
<p>​	更具体地说，我们</p>
<ol>
<li>
<p>首先提出了一个<strong>图协同注意网络（ graph co-attention network）</strong>：</p>
<p>它通过选择和聚合对兴趣匹配有用的邻居，从知识图谱中学习实体的表示。</p>
</li>
<li>
<p>进一步提出了使用<strong>实体协同注意力网络（ entity co-attention network）</strong>：</p>
<p>它通过捕获实体之间的相关性来交互式地学习点击新闻和候选新闻的基于知识的表示。</p>
</li>
<li>
<p>提出了一种<strong>语义协同编码器（ semantic coencoder）</strong>：</p>
<p>通过对文本之间的语义相关性进行建模，交互式地学习用户点击新闻和候选新闻的基于语义的表示。新闻的统一表示被表述为基于知识和语义的表示的聚合。</p>
</li>
<li>
<p>进一步提出了一种<strong>用户新闻联合编码器（ user-news co-encoder）</strong>：</p>
<p>用于从点击新闻和候选新闻的表示中构建候选<em>新闻感知的用户兴趣表示</em>和<em>用户感知的候选新闻表示</em>，以更好地模拟用户对候选新闻的兴趣。最后，根据候选新闻的表示与用户兴趣之间的相关性对候选新闻进行排名。</p>
</li>
</ol>
<p>我们对两个真实的数据集进行了广泛的实验，并表明我们的方法可以有效地提高新闻推荐的性能并优于其他基准方法。</p>
<h2 id="2-相关的工作">2 相关的工作</h2>
<p>​	现有方法通常通过内容对候选新闻进行建模，并根据点击新闻独立建模用户兴趣，然后根据候选新闻和用户兴趣的相关性进行匹配。 只有一部分候选新方面和用户兴趣对匹配用户兴趣和候选新闻有用。然而，这些方法独立地对候选新闻和用户兴趣进行建模，这对于进一步的兴趣匹配可能较差。与这些方法不同的是，在 KIM 方法中，我们提出了一个知识感知的交互式匹配框架，在考虑相关性的情况下对候选新闻和用户兴趣进行交互建模，可以更好地将用户兴趣与候选新闻进行匹配。</p>
<p>​	一些方法以候选感知的方式模拟用户兴趣。事实上，候选新闻可能包含多个方面和实体，其中只有一部分可能与用户兴趣相匹配。然而，这些方法在没有考虑目标用户的情况下对候选新闻进行建模，这对于进一步将用户兴趣与候选新闻进行匹配可能较差。与这些方法不同，我们的 KIM 方法在考虑目标用户的情况下对候选新闻进行建模。此外，这些方法在没有考虑相关性的情况下对点击新闻和候选新闻进行建模，这对于进一步衡量候选新闻和从点击新闻推断出的用户兴趣之间的相关性也可能不是最优的。与这些方法不同，KIM 可以交互地学习点击新闻和候选新闻的表示，以实现更好的兴趣匹配。</p>
<h2 id="3-方法论">3 方法论</h2>
<h3 id="问题表述">问题表述</h3>
<p>​	给定一个用户𝑢和一个候选新闻$n^c$，我们需要计算相关性分数𝑧来衡量用户𝑢对候选新闻内容$n^c$的兴趣。 然后根据相关性得分对不同的候选新闻进行排名并推荐给用户𝑢。 用户𝑢与他/她点击的新闻集相关联。 每个新闻 𝑛 都与其文本 𝑇 和文本中的实体 𝐸 相关联。 此外，还有一个知识图 G 用于提供实体之间的相关性。 它包含实体和实体之间的关系。 G 中的每个实体 𝑒 与其嵌入相关联，e 基于知识图进行预训练。</p>
<p></p>
<h3 id="kim-knowledge-aware-interactive-matching的框架">KIM（ Knowledge-aware Interactive Matching）的框架</h3>
<p>​	KIM 包含两个主要模块。：</p>
<ol>
<li>
<p>第一个是知识感知新闻协同编码器（knowledge-aware news co-encoder），它通过捕获语义和知识层面的相关性，交互式地学习用户<strong>点击新闻</strong>和<strong>候选新闻</strong>的<strong>知识感知表示</strong>（ knowledge-aware representations）。</p>
</li>
<li>
<p>第二个是用户新闻协同编码器（user-news co-encoder），它从上个模块生成的用户<strong>点击新闻的表征</strong>和<strong>候选新闻表征</strong>中交互学习候选新闻感知的用户兴趣表征（ candidate news-aware user interest representation）u和用户感知的候选新闻表征（ user-aware candidate news representation）。</p>
</li>
</ol>
<h3 id="知识感知新闻协同编码器knowledge-aware-news-co-encoder">知识感知新闻协同编码器（knowledge-aware news co-encoder）</h3>
<p>​	它从文本和文本中的实体中交互式地学习用户点击的新闻$n_u$和候选新闻$n_c$的表示，它包含三个子模块。</p>
<p></p>
<ol>
<li>
<p>第一个是知识协同编码器（Knowledge co-encoder）</p>
<p>对于点击新闻$n_u$和候选新闻$n_c$，它基于知识图谱从<strong>实体</strong>之间的相关性中交互式地学习基于知识的表示${k}^{u}$$和 $${k}^{c}$。</p>
<p>它包含三个组件：</p>
<ul>
<li>图注意网络（ graph attention network）</li>
<li>图协同注意网络（ graph co-attention network）</li>
<li>实体协同注意网络（ entity co-attention network）</li>
</ul>
<p></p>
</li>
<li>
<p>第二个是语义协同编码器（semantic co-encoder）</p>
<p>对于点击新闻$n_u$和候选新闻$n_c$，它交互式地学习基于语义的表示${t}^{u}$和${t}^{c}$，以根据<strong>文本</strong>之间的语义相关性来模拟用户对候选新闻的兴趣。</p>
<p></p>
</li>
<li>
<p>最后，对于点击新闻$n_u$或候选新闻$n_c$，我们投影其基于<strong>知识</strong>和<strong>语义</strong>的表示来学习统一的新闻表示${n}^{u}$或${n}^{c}$。</p>
</li>
</ol>
<h3 id="用户-新闻-协同编码器">用户-新闻 协同编码器</h3>
<p>​	它从用户点击的新闻和候选新闻的表示中学习候选新闻感知的用户兴趣表示和用户感知的候选新闻表示。</p>
<p>​	通常，用户的兴趣是多样的，只有一部分可以与候选新闻匹配[20]。因此，学习候选<strong>新闻感知的</strong>用户兴趣表示可以更好地建模用户兴趣以匹配候选新闻。</p>
<p>​	类似地，候选新闻可能涵盖多个方面，用户可能只对其中的一部分感兴趣 [33, 34]。因此，学习<strong>用户感知的</strong>候选新闻表示也有利于兴趣匹配。</p>
<p>​	因此，我们应用新闻协同注意网络来学习候选新闻感知用户表示和用户感知候选新闻表示。</p>
<h2 id="实验">实验</h2>
<h3 id="数据集">数据集</h3>
<ul>
<li>MIND2</li>
<li>Feeds</li>
</ul>
<p>此外，我们在实验中使用了 WikiData 作为知识图谱。</p>
<h3 id="性能评估">性能评估</h3>
<p>​	我们将 KIM 与几种最先进的个性化新闻推荐方法进行比较，如下所示：</p>
<ul>
<li>EBNR [21]：通过 GRU 网络从用户的点击历史中表示用户兴趣。</li>
<li>DKN [32]：将多通道 CNN 网络 [15] 应用于新闻标题中对齐的单词和实体的嵌入，以学习新闻表示。</li>
<li>DAN [47]：通过 CNN 网络从新闻标题的单词和实体中学习新闻表示，并通过细心的 LSTM 网络 [8] 学习用户兴趣表示。</li>
<li>NAML [33]：通过多个注意力集中的 CNN 网络从新闻标题、正文、类别和子类别中学习新闻表示。</li>
<li>NPA [34]：使用具有个性化注意查询的注意网络来学习新闻和用户表示。</li>
<li>LSTUR [1]：通过 GRU 网络从用户最近点击的新闻中建模短期用户兴趣，并通过用户 ID 嵌入建模长期用户兴趣。</li>
<li>NRMS [37]：通过多头自注意力网络对新闻内容和用户点击行为进行建模。</li>
<li>FIM [31]：通过CNN网络从用户点击新闻和候选新闻的文本中匹配用户和新闻。</li>
<li>KRED [18]：通过图注意力网络从新闻中的实体及其在知识图中的邻居中学习新闻的表示。</li>
</ul>
<p></p>
<p>​	我们重复了五次不同的实验，并在表 2 中列出了不同方法的平均性能和相应的标准差。</p>
<ul>
<li>
<p>KIM 明显优于其他基准方法。</p>
<p>LSTUR、NRMS和KRED这些方法独立地对候选新闻和用户兴趣进行建模，而不考虑它们的相关性。这是因为用户可能对多个领域感兴趣，并且候选新闻也可能包含多个方面和实体。因此，这些方法很难准确匹配用户兴趣和候选新闻，因为它们是在这些方法中独立建模的。</p>
</li>
<li>
<p>KIM 还优于通过考虑候选新闻来建模用户兴趣的基线方法。</p>
<p>例如 DKN、DAN。这是因为候选新闻可能涵盖多个方面，而用户可能只对其中的一部分感兴趣[33、34]。然而，这些方法在没有考虑目标用户的情况下对候选新闻进行建模，这对于进一步将候选新闻与用户兴趣匹配可能较差。</p>
</li>
</ul>
<h3 id="消融实验">消融实验</h3>
<p>​	进行了两项消融研究来评估 KIM 的有效性。首先评估不同信息（即文本和知识）对新闻内容建模的有效性。</p>
<p></p>
<ul>
<li>首先，删除语义信息（即新闻文本）会严重损害 KIM 的性能。这是因为文本通常包含有关新闻内容的丰富信息，对于新闻内容的理解至关重要 [45]。去除语义信息会使新闻表示失去很多重要信息，并且不能准确地对新闻内容进行建模。</li>
<li>其次，在新闻内容建模中去除知识图谱（即知识知识图谱中的实体及其邻居）也会使 KIM 的性能显著下降。这是因为文本信息通常不足以理解新闻内容 [18, 32]。幸运的是，知识图谱包含不同实体之间的丰富关联。此外，用户点击新闻中的实体与候选新闻之间的相关性可以提供语义信息之外的丰富信息，以了解用户对候选新闻的兴趣。因此，将实体信息纳入个性化新闻推荐有可能提高推荐的准确性。</li>
</ul>
<p>​	接下来，我们通过分别用注意力网络替换它们来评估 KIM 中几个重要的注意力网络的有效性。</p>
<ul>
<li>首先，在用户新闻协同编码器中去除<strong>新闻关注网络</strong>后，KIM 的性能变得更差。这是因为用户兴趣可能是多样的，并且只有一部分用户点击的新闻对于建模用户兴趣和候选新闻之间的相关性是有用的[32]。此外，候选新闻内容可能包含多个方面，用户可能只对其中的一部分感兴趣。因此，通过新闻共同关注网络学习候选新闻感知用户兴趣和用户感知候选新闻表示可以更好地捕捉用户对候选新闻的兴趣。</li>
<li>其次，去除<strong>语义协同注意网络</strong>也会损害 KIM 的性能。这是因为点击新闻和候选新闻之间的语义相关性可以帮助理解用户对候选新闻的兴趣。此外，一条候选新闻或一条点击新闻通常包含多个方面，其中只有一部分对兴趣匹配有用。如果它们的语义信息是独立建模的，则很难在语义级别有效地捕捉点击新闻和候选新闻的相关性。因此，通过语义共同注意网络交互式学习点击新闻和候选新闻的基于语义的表示可以更好地捕捉它们之间的相关性，以便将用户兴趣与候选新闻匹配。</li>
<li>同时去除<strong>图协同注意力网络</strong>和<strong>实体协同注意力网络</strong>会导致 KIM 的性能下降。这是因为实体级别的点击新闻和候选新闻之间的相关性对于兴趣匹配也非常有用。此外，如果该方法独立地表示来自其实体的点击新闻和候选新闻，则对于兴趣匹配也是次优的。在KIM方法中，图协同注意力网络和实体协同注意力网络都用于以交互方式捕捉点击新闻和候选新闻实体之间的相关性，可以将丰富的信息融入KIM模型进行兴趣匹配。</li>
</ul>
<h2 id="结论">结论</h2>
<p>​	在本文中，我们提出了一种用于个性化新闻推荐的知识感知交互式匹配框架（命名为 KIM）。该框架旨在对候选新闻和用户兴趣进行交互建模，以实现更准确的兴趣匹配。更具体地说，我们首先提出了一个图协同注意网络，通过选择和聚合它们的邻居的信息来基于知识图对实体进行建模，这些信息为兴趣匹配提供了丰富的信息。我们还提出使用实体协同注意网络从实体之间的相关性中交互式地对点击新闻和候选新闻进行建模。此外，我们建议使用语义共同注意网络从文本之间的语义相关性中交互式地对点击新闻和候选新闻进行建模。此外，我们提出了一种用户新闻协同编码器来学习候选新闻感知用户表示和用户感知候选新闻表示，以更好地捕捉用户兴趣和候选新闻之间的相关性。我们对两个真实世界的数据集进行了广泛的实验。实验结果表明，我们的 KIM 方法显著优于其他基准方法。</p>
]]></description>
</item>
<item>
    <title>网络实验——在linux平台安装OLSR协议</title>
    <link>https://leeshy-tech.github.io/network_olsr_with_mininet-wifi/</link>
    <pubDate>Sun, 27 Mar 2022 22:26:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/network_olsr_with_mininet-wifi/</guid>
    <description><![CDATA[<h1 id="在linux平台安装olsr协议">在linux平台安装OLSR协议</h1>
<h2 id="前言">前言</h2>
<p>因为要做一个OLSR和SDN自定义控制面的对比实验，所以要利用mininet-wifi平台自定义拓扑跑一下OLSR协议。</p>
<p>平台：ubuntu20.04</p>
<h2 id="安装">安装</h2>
<ul>
<li>
<p>官网：<a href="www.olsr.org/" rel="">www.olsr.org/</a></p>
</li>
<li>
<p>github：<a href="https://github.com/OLSR/olsrd" target="_blank" rel="noopener noreffer">https://github.com/OLSR/olsrd</a></p>
</li>
</ul>
<h3 id="通过mininet-wifi安装">通过mininet-wifi安装</h3>
<ul>
<li>进入mininet-wifi目录<code>sudo ./install.sh -o</code></li>
</ul>
<h3 id="从git安装没有亲自试来自网络">从git安装(没有亲自试，来自网络)</h3>
<ul>
<li>
<p>安装语法分析器：<code>sudo apt install bison flex</code></p>
</li>
<li>
<p>下载源码：<code>git clone https://github.com/OLSR/olsrd</code></p>
</li>
<li>
<p>编译：<code>cd olsrd;make</code></p>
</li>
<li>
<p>安装：<code>sudo make install</code></p>
</li>
</ul>
<h2 id="mininet-wifi拓扑构建">mininet-wifi拓扑构建</h2>
<blockquote>
<p>构造一个网络拓扑来测试OLSR协议。</p>
</blockquote>
<p>拓扑文件（参考example/adhoc.py）：</p>
<p><a href="https://github.com/leeshy-tech/mininet-wifi/blob/master/examples/OLSR/olsr_test.py" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/mininet-wifi/blob/master/examples/OLSR/olsr_test.py</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="ch">#!/usr/bin/python</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">This example use four motionless station to test the OLSR protocol in adhoc network.
</span><span class="s2">It&#39;s almost the same as example/adhoc.py.
</span><span class="s2">use &#34;sudo python olsr_test.py olsrd&#34; in terminal to run it.
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">mininet.log</span> <span class="kn">import</span> <span class="n">setLogLevel</span><span class="p">,</span> <span class="n">info</span>
<span class="kn">from</span> <span class="nn">mn_wifi.link</span> <span class="kn">import</span> <span class="n">wmediumd</span><span class="p">,</span> <span class="n">adhoc</span>
<span class="kn">from</span> <span class="nn">mn_wifi.manetRoutingProtocols</span> <span class="kn">import</span> <span class="n">olsrd</span>
<span class="kn">from</span> <span class="nn">mn_wifi.cli</span> <span class="kn">import</span> <span class="n">CLI</span>
<span class="kn">from</span> <span class="nn">mn_wifi.net</span> <span class="kn">import</span> <span class="n">Mininet_wifi</span>
<span class="kn">from</span> <span class="nn">mn_wifi.wmediumdConnector</span> <span class="kn">import</span> <span class="n">interference</span>


<span class="k">def</span> <span class="nf">topology</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="s2">&#34;Create a network.&#34;</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">Mininet_wifi</span><span class="p">(</span><span class="n">link</span><span class="o">=</span><span class="n">wmediumd</span><span class="p">,</span> <span class="n">wmediumd_mode</span><span class="o">=</span><span class="n">interference</span><span class="p">)</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;*** Creating nodes</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;-a&#39;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="n">sta1</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addStation</span><span class="p">(</span><span class="s1">&#39;sta1&#39;</span><span class="p">,</span> <span class="n">ip6</span><span class="o">=</span><span class="s1">&#39;fe80::1&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s1">&#39;25,50,0&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sta2</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addStation</span><span class="p">(</span><span class="s1">&#39;sta2&#39;</span><span class="p">,</span> <span class="n">ip6</span><span class="o">=</span><span class="s1">&#39;fe80::2&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s1">&#39;75,10,0&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sta3</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addStation</span><span class="p">(</span><span class="s1">&#39;sta3&#39;</span><span class="p">,</span> <span class="n">ip6</span><span class="o">=</span><span class="s1">&#39;fe80::3&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s1">&#39;75,90,0&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sta4</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addStation</span><span class="p">(</span><span class="s1">&#39;sta4&#39;</span><span class="p">,</span> <span class="n">ip6</span><span class="o">=</span><span class="s1">&#39;fe80::4&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s1">&#39;125,50,0&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">net</span><span class="o">.</span><span class="n">setPropagationModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&#34;logDistance&#34;</span><span class="p">,</span> <span class="n">exp</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;*** Configuring wifi nodes</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">configureWifiNodes</span><span class="p">()</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;*** Creating links</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="c1"># MANET routing protocols supported by proto:</span>
    <span class="c1"># babel, batman_adv, batmand and olsr</span>
    <span class="c1"># WARNING: we may need to stop Network Manager if you want</span>
    <span class="c1"># to work with babel</span>
    <span class="n">protocols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;babel&#39;</span><span class="p">,</span> <span class="s1">&#39;batman_adv&#39;</span><span class="p">,</span> <span class="s1">&#39;batmand&#39;</span><span class="p">,</span> <span class="s1">&#39;olsrd&#39;</span><span class="p">,</span> <span class="s1">&#39;olsrd2&#39;</span><span class="p">]</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">proto</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">proto</span> <span class="ow">in</span> <span class="n">protocols</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;proto&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proto</span>

    <span class="n">net</span><span class="o">.</span><span class="n">addLink</span><span class="p">(</span><span class="n">sta1</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">adhoc</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s1">&#39;sta1-wlan0&#39;</span><span class="p">,</span>
                <span class="n">ssid</span><span class="o">=</span><span class="s1">&#39;adhocNet&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">ht_cap</span><span class="o">=</span><span class="s1">&#39;HT40+&#39;</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">addLink</span><span class="p">(</span><span class="n">sta2</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">adhoc</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s1">&#39;sta2-wlan0&#39;</span><span class="p">,</span>
                <span class="n">ssid</span><span class="o">=</span><span class="s1">&#39;adhocNet&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">ht_cap</span><span class="o">=</span><span class="s1">&#39;HT40+&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">addLink</span><span class="p">(</span><span class="n">sta3</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">adhoc</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s1">&#39;sta3-wlan0&#39;</span><span class="p">,</span>
                <span class="n">ssid</span><span class="o">=</span><span class="s1">&#39;adhocNet&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">ht_cap</span><span class="o">=</span><span class="s1">&#39;HT40+&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">addLink</span><span class="p">(</span><span class="n">sta4</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">adhoc</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s1">&#39;sta4-wlan0&#39;</span><span class="p">,</span>
                <span class="n">ssid</span><span class="o">=</span><span class="s1">&#39;adhocNet&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">ht_cap</span><span class="o">=</span><span class="s1">&#39;HT40+&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">net</span><span class="o">.</span><span class="n">plotGraph</span><span class="p">(</span><span class="n">max_x</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">max_y</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;*** Starting network</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">*** Addressing...</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;proto&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">sta1</span><span class="o">.</span><span class="n">setIP6</span><span class="p">(</span><span class="s1">&#39;2001::1/64&#39;</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s2">&#34;sta1-wlan0&#34;</span><span class="p">)</span>
        <span class="n">sta2</span><span class="o">.</span><span class="n">setIP6</span><span class="p">(</span><span class="s1">&#39;2001::2/64&#39;</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s2">&#34;sta2-wlan0&#34;</span><span class="p">)</span>
        <span class="n">sta3</span><span class="o">.</span><span class="n">setIP6</span><span class="p">(</span><span class="s1">&#39;2001::3/64&#39;</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s2">&#34;sta3-wlan0&#34;</span><span class="p">)</span>
        <span class="n">sta4</span><span class="o">.</span><span class="n">setIP6</span><span class="p">(</span><span class="s1">&#39;2001::4/64&#39;</span><span class="p">,</span> <span class="n">intf</span><span class="o">=</span><span class="s2">&#34;sta4-wlan0&#34;</span><span class="p">)</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;*** Running CLI</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="n">CLI</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

    <span class="n">info</span><span class="p">(</span><span class="s2">&#34;*** Stopping network</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">setLogLevel</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">)</span>
    <span class="n">topology</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
</code></pre></div><p>可视化：</p>
<p></p>
<p>解读：</p>
<p>从图中可以看出，sta1只能与sta2和sta3进行单跳通信，如果要与sta4通信，就需要sta2或者sta3进行中继。如果没有OLSR协议，节点在收到目的IP不是本节点的包之后就会丢掉，无法完成中继。OLSR协议会在网络中的节点维护整个网络拓扑，就能完成中继。</p>
<h2 id="实验测试">实验测试</h2>
<h3 id="关闭networkmanager">关闭NetworkManager</h3>
<p><code>sudo systemctl stop NetworkManager</code></p>
<p>NetworkManager是linux的自动网络配置工具，我们希望自己配置网络，所以要把它关掉。</p>
<p>查看节点的网络状态<code>ip addr</code>，没有图中的<code>NO-CARRIER</code>说明NetworkManager已经被关闭。（这个命令可以在本机运行，也可以在mininet虚拟主机运行。）</p>
<p></p>
<h3 id="配置olsr">配置OLSR</h3>
<p>编辑配置文件：<code>vim /etc/olsrd/olsrd.conf</code></p>
<p>添加所有节点的网卡：</p>
<p></p>
<p>退出、保存</p>
<h3 id="运行拓扑文件">运行拓扑文件</h3>
<p><code>sudo python olsr_test.py olsrd</code></p>
<p></p>
<h3 id="网络测试">网络测试</h3>
<p><code>sta1 ping sta4</code></p>
<p></p>
<p>能ping通，说明OLSR协议运行正常。</p>
<p>查看路由：<code>sta3 route</code></p>
<p></p>
<p>多了三条路由，这是OLSR协议运行的结果。</p>
<h2 id="结束">结束</h2>
<h3 id="恢复系统">恢复系统</h3>
<p>开启NetworkManager：<code>sudo systemctl start NetworkManager</code></p>
<p>退出mininet-wifi：<code>exit</code></p>
<p>清理系统：<code>sudo mn -c</code></p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://blog.csdn.net/whatday/article/details/106096127" target="_blank" rel="noopener noreffer">centos7 开启 关闭 NetworkManager</a></p>
<p><a href="https://blog.csdn.net/qq_35109869/article/details/79839357" target="_blank" rel="noopener noreffer">Linux虚拟机下OLSR协议的安装</a></p>
<p><a href="https://github.com/intrig-unicamp/mininet-wifi/issues/342" target="_blank" rel="noopener noreffer">Unable to create IPv6 multi hop mesh network in ad hoc mode #342</a>这个issue救了大命了</p>
<p><a href="https://blog.csdn.net/weixin_29279047/article/details/116832580" target="_blank" rel="noopener noreffer">Linux卸载olsrd,olsrd路由协议移植到嵌入式linux中使用</a></p>
<p><a href="www.olsr.org/" rel="">www.olsr.org/</a>官网写的说明太少了，根本看不懂，麻了。</p>
<p><a href="https://github.com/OLSR/olsrd" target="_blank" rel="noopener noreffer">https://github.com/OLSR/olsrd</a></p>
]]></description>
</item>
<item>
    <title>Linux——图片url生成</title>
    <link>https://leeshy-tech.github.io/linux_image_url/</link>
    <pubDate>Thu, 17 Mar 2022 20:45:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/linux_image_url/</guid>
    <description><![CDATA[<h1 id="图片url生成">图片url生成</h1>
<h2 id="准备">准备</h2>
<h3 id="安装jdkjre">安装JDK，JRE</h3>
<ul>
<li>
<p>下载linux的jdk，jre压缩包：</p>
<ul>
<li><a href="https://www.oracle.com/java/technologies/downloads/#java8" target="_blank" rel="noopener noreffer">https://www.oracle.com/java/technologies/downloads/#java8</a></li>
<li>用xftp传到服务器上。</li>
<li>解压<code>tar -zxvf jdk-17_linux-x64_bin.tar.gz jre-8u321-linux-x64.tar.gz</code>，记住此时所在的路径（pwd命令可查）。</li>
</ul>
</li>
<li>
<p>配置环境变量：</p>
<ul>
<li>
<p><code>cd /etc</code></p>
</li>
<li>
<p><code>vim profile</code></p>
</li>
<li>
<p>i进入编辑模式</p>
</li>
<li>
<p>文件末尾加上如下代码，JAVA_HOME,JRE_HOME分别为解压的文件夹的路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">JAVA_HOME</span><span class="o">=</span>/home/ubuntu/jdk-17.0.2
<span class="nb">export</span> <span class="nv">JRE_HOME</span><span class="o">=</span>/home/ubuntu/jre1.8.0_321
<span class="nb">export</span> <span class="nv">CLASSPATH</span><span class="o">=</span>.:<span class="nv">$JAVA_HOME</span>/lib:<span class="nv">$JRE_HOME</span>/lib
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$JAVA_HOME</span>/bin:<span class="nv">$PATH</span>
</code></pre></div></li>
<li>
<p><code>Esc</code>退出，输入<code>:wq</code>保存退出。</p>
</li>
</ul>
</li>
<li>
<p>使能配置：<code>source /etc/profile</code></p>
</li>
<li>
<p>检验：<code>java -version</code>，输出版本信息，安装成功。</p>
</li>
</ul>
<h3 id="安装tomcat">安装tomcat</h3>
<ul>
<li>
<p>下载安装包：</p>
<ul>
<li>
<p><a href="https://tomcat.apache.org/download-10.cgi" target="_blank" rel="noopener noreffer">https://tomcat.apache.org/download-10.cgi</a></p>
<p></p>
</li>
<li>
<p>用xftp传到服务器上，解压<code>tar -zxvf apache-tomcat-10.0.18.tar.gz</code></p>
</li>
</ul>
</li>
<li>
<p>进入bin目录，启动tomcat</p>
<ul>
<li>
<p><code>cd apache-tomcat-10.0.18/bin</code></p>
</li>
<li>
<p><code>./startup.sh</code></p>
<p></p>
</li>
</ul>
</li>
</ul>
<h3 id="防火墙设置">防火墙设置</h3>
<p>到服务器控制台，开启8080端口：</p>
<p></p>
<p>浏览器访问<code>服务器IP:8080</code>地址，看到tomcat默认页说明tomcat安装运行成功。</p>
<p></p>
<h2 id="生成图片url">生成图片url</h2>
<ul>
<li>
<p>假设图片存放在服务器路径：<code>/home/ubuntu/image</code></p>
</li>
<li>
<p>进入tomcat文件夹的conf路径，编辑server.xml：</p>
<ul>
<li>
<p><code>cd conf</code></p>
</li>
<li>
<p><code>vim server.xml</code></p>
</li>
<li>
<p>结尾处插入此代码<code>&lt;Context docBase=&quot;/home/ubuntu/image&quot; path=&quot;/pictures&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;/&gt;</code></p>
<p></p>
</li>
</ul>
</li>
</ul>
<p>则可以通过<code>url=http://ip:8080/path/图片名+后缀</code>访问该图片。</p>
<p></p>
<h2 id="结束语">结束语</h2>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.bilibili.com/video/BV1uh411a7Jg?p=268" target="_blank" rel="noopener noreffer">https://www.bilibili.com/video/BV1uh411a7Jg?p=268</a></p>
<p><a href="https://blog.csdn.net/dyt443733328/article/details/102587168" target="_blank" rel="noopener noreffer">tomcat启动“成功”，但是浏览器无法访问</a></p>
<p><a href="https://blog.csdn.net/Wyx_wx/article/details/89117746" target="_blank" rel="noopener noreffer">访问 Linux 服务器上的文件（以图片为例</a></p>
]]></description>
</item>
<item>
    <title>Ryu——安装</title>
    <link>https://leeshy-tech.github.io/ryu_install/</link>
    <pubDate>Mon, 07 Mar 2022 21:41:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/ryu_install/</guid>
    <description><![CDATA[<h1 id="ryu安装">Ryu安装</h1>
<h2 id="安装git">安装git</h2>
<p><code>sudo apt install git</code></p>
<h2 id="安装python3">安装python3</h2>
<blockquote>
<p>时代变了，不装不行。</p>
</blockquote>
<ul>
<li>
<p>下载</p>
<p><code>sudo apt install python3</code></p>
</li>
<li>
<p>查看python3的位置和版本号，用于第四步</p>
<p><code>whereis python3</code></p>
</li>
<li>
<p>删除原来python2的软连接</p>
<p><code>sudo rm /usr/bin/python</code></p>
</li>
<li>
<p>建立新的软连接</p>
<p><code>sudo ln -s /usr/bin/python3.9 /usr/bin/python</code></p>
</li>
<li>
<p>查看版本</p>
<p><code>python --version</code></p>
</li>
</ul>
<h2 id="安装ryu">安装Ryu</h2>
<ul>
<li>
<p>更新pip</p>
<p><code>sudo pip install --upgrade pip</code></p>
</li>
<li>
<p>克隆源代码</p>
<p><code>git clone git://github.com/faucetsdn/ryu.git</code></p>
</li>
<li>
<p>进入ryu目录</p>
<p><code>cd ryu</code></p>
</li>
<li>
<p>安装依赖</p>
<p><code>sudo pip install -r tools/pip-requires</code></p>
</li>
<li>
<p>安装ryu</p>
<p><code>sudo python setup.py install</code></p>
</li>
</ul>
<h2 id="测试">测试</h2>
<ul>
<li>
<p>进入ryu/ryu/app目录</p>
<p><code>cd ryu/ryu/app</code></p>
</li>
<li>
<p>运行simple_switch.py</p>
<p><code>ryu-manager app/simple_switch.py</code></p>
<p>出现以下输出为正常：</p>
<pre tabindex="0"><code>loading app app/simple_switch.py
loading app ryu.controller.ofp_handler
instantiating app app/simple_switch.py of SimpleSwitch
instantiating app ryu.controller.ofp_handler of OFPHandler
</code></pre></li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p><a href="https://blog.csdn.net/sexyluna/article/details/105740519" target="_blank" rel="noopener noreffer">Ubuntu将默认python版本改为python3</a></p>
<p><a href="https://github.com/leeshy-tech/ryu" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/ryu</a></p>
]]></description>
</item>
<item>
    <title>install mysql on linux</title>
    <link>https://leeshy-tech.github.io/mysql_install/</link>
    <pubDate>Mon, 07 Mar 2022 20:53:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/mysql_install/</guid>
    <description><![CDATA[<h1 id="install-mysql-on-linux">install mysql on linux</h1>
<h2 id="安装">安装：</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo apt update
sudo apt install mysql-server
</code></pre></div><h2 id="配置root密码为123456">配置root密码为123456：</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo mysql
use mysql<span class="p">;</span>
update user <span class="nb">set</span> <span class="nv">authentication_string</span><span class="o">=</span><span class="s1">&#39;&#39;</span> where <span class="nv">user</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">;</span>
alter user <span class="s1">&#39;root&#39;</span>@<span class="s1">&#39;localhost&#39;</span> identified with mysql_native_password by <span class="s1">&#39;123456&#39;</span><span class="p">;</span>
</code></pre></div><h2 id="参考文献">参考文献：</h2>
<p><a href="https://blog.csdn.net/qq_26164609/article/details/106881079" target="_blank" rel="noopener noreffer">Ubunto20.04安装MySQL并修改root用户密码</a></p>
<p><a href="https://developer.aliyun.com/article/758177" target="_blank" rel="noopener noreffer">如何在 Ubuntu 20.04 上安装 MySQL</a></p>
]]></description>
</item>
<item>
    <title>mininet-wifi——安装</title>
    <link>https://leeshy-tech.github.io/mininet-wifi_install/</link>
    <pubDate>Mon, 07 Mar 2022 20:53:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/mininet-wifi_install/</guid>
    <description><![CDATA[<h1 id="安装mininet-wifi">安装mininet-wifi</h1>
<p>mininet学了快半年了，还是安装七八次才能装上，人麻了，怒写一篇博客。平台：Ubuntu20.04。</p>
<h2 id="安装git">安装git</h2>
<p><code>sudo apt install git</code></p>
<h2 id="安装python3">安装python3</h2>
<p>mininet在python2和python3环境下都是能正常运行的，但是，apt中一些python2的包已经升级到3了，比如python-matplotlib，你不升级python3，mininet-wifi就会安装它，但是apt里又没有，只会一直报错。你再怎么更新源，也找不到这个玩意，因为它已经变成python3-matplotlib了。所以还是要安装python3。</p>
<ul>
<li>
<p>下载</p>
<p><code>sudo apt install python3</code></p>
</li>
<li>
<p>查看python3的位置和版本号，用于第四步</p>
<p><code>whereis python3</code></p>
</li>
<li>
<p>删除原来python2的软连接</p>
<p><code>sudo rm /usr/bin/python</code></p>
</li>
<li>
<p>建立新的软连接</p>
<p><code>sudo ln -s /usr/bin/python3.9 /usr/bin/python</code></p>
</li>
<li>
<p>查看版本</p>
<p><code>python --version</code></p>
</li>
</ul>
<h2 id="安装mininet-wifi-1">安装mininet-wifi</h2>
<h3 id="有梯子或者有git代理">有梯子，或者有git代理</h3>
<ul>
<li>
<p>克隆源代码</p>
<p><code>git clone https://github.com/intrig-unicamp/mininet-wifi</code></p>
</li>
<li>
<p>查看安装可选项</p>
<p><code>sudo mininet-wifi/util/install.sh -h</code></p>
</li>
<li>
<p>选择一些项安装（默认就按这个）</p>
<p><code>sudo mininet-wifi/util/install.sh -Wlnfv</code></p>
</li>
</ul>
<h3 id="无代理">无代理</h3>
<p>这里主要是指以https无法正常访问github的情况，需要把所有的git网址改为git://开头，因为install.sh里会有下载其他库的git命令，所以直接运行install.sh会报git超时，需要提前把相关库下好。</p>
<ul>
<li>
<p>克隆</p>
<p><code>git clone git://github.com/intrig-unicamp/mininet-wifi</code></p>
<p><code>git clone git://github.com/ramonfontes/mac80211_hwsim_mgmt</code></p>
<p><code>git clone git://github.com/mininet/mininet</code></p>
<p><code>git clone git://github.com/vchakour/wmediumd</code></p>
</li>
<li>
<p>选择一些项安装（默认就按这个）</p>
<p><code>sudo mininet-wifi/util/install.sh -Wlnfv</code></p>
</li>
</ul>
<h2 id="运行">运行</h2>
<ul>
<li>
<p>运行，这句正常运行就说明下载成功。</p>
<p><code>sudo mn --wifi</code></p>
</li>
<li>
<p>退出</p>
<p><code>exit</code></p>
</li>
<li>
<p>清理</p>
<p><code>sudo mn -c</code></p>
</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p><a href="https://github.com/intrig-unicamp/mininet-wifi" target="_blank" rel="noopener noreffer">https://github.com/intrig-unicamp/mininet-wifi</a></p>
<p><a href="https://blog.csdn.net/sexyluna/article/details/105740519" target="_blank" rel="noopener noreffer">Ubuntu将默认python版本改为python3</a></p>
]]></description>
</item>
<item>
    <title>论文笔记——Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.</title>
    <link>https://leeshy-tech.github.io/paper_wireless_sdn_mobile/</link>
    <pubDate>Thu, 03 Mar 2022 14:18:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/paper_wireless_sdn_mobile/</guid>
    <description><![CDATA[<h1 id="wireless-sdn-mobile-ad-hoc-networkfrom-theory-to-practice">Wireless SDN Mobile Ad Hoc Network:from Theory to Practice.</h1>
<h2 id="论文概况">论文概况</h2>
<p><a href="https://ieeexplore.ieee.org/abstract/document/7996340" target="_blank" rel="noopener noreffer">https://ieeexplore.ieee.org/abstract/document/7996340</a></p>
<p><a href="https://ieeexplore.ieee.org/xpl/conhome/7985734/proceeding" target="_blank" rel="noopener noreffer">2017 IEEE International Conference on Communications (ICC)</a></p>
<p>自翻：<a href="https://github.com/leeshy-tech/PaperTranslate/blob/main/wireless_SDN_mobile.md" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/PaperTranslate/blob/main/wireless_SDN_mobile.md</a></p>
<h2 id="重要的名词">重要的名词</h2>
<p>D2D （device to device） MANET （移动自组织网络）   VANET（车辆自组织网络）</p>
<p>本地流量：信息流的源和目的距离很近的数据连接。</p>
<h2 id="引言">引言</h2>
<p>根据思科[1]最近的一份报告，通过无线网络传输的数据流量正在不断增加，不久将超过有线流量。在未来的5G场景中，无线流量的模式将对本地流量产生越来越大的需求。</p>
<p>使用当前的网络标准，即使是本地数据也要通过蜂窝网络传输到一个集中的实体，然后再重新分发。对于本地流量的交换来说，这种方法显然不是最优的。一种更有前途的方法依赖于设备到设备(D2D)技术[4]，其中设备可以在MANET或者VANET[6]中以分布式方式组织。</p>
<p>在没有集中控制的情况下，每个节点必须独立行动，做出路由决策，并在移动网络中动态地适应快速变化的拓扑结构。前人提出了一些解决方案：</p>
<ul>
<li>按需距离矢量(AODV)协议，它仅在需要时才寻找路由路径，适合流量偶发的场景。</li>
<li>优化的链路状态路由（OLSR）协议，当几个源-目的对之间的流量比较正常的情况下，预先定义网络中每个可能的节点对之间的路由的主动协议。</li>
<li>区域路由（ZRP）协议，将网络划分为多个集群，如果源节点和目的节点在同一个集群中，则使用OLSR等主动路由策略;否则，采用反应性策略，如AODV。</li>
</ul>
<p>OLSR的主要问题：它需要节点之间频繁的控制消息交换，以维护每个节点上更新的网络拓扑。ZRP能够显著减少控制消息的数量，因为更新的拓扑信息只需要在每个集群中的节点之间进行维护，但是当一个包被发送到一个属于不同集群的节点时，会引入显著的延迟，因为新的路径应该以响应式的方式搜索。</p>
<p>在节点具有移动性的条件下，必须在减少开销（网络中交换的控制信息）和完全掌握网络拓扑之间做出权衡，如果要设计更好的传输路线，则要更频繁地交换控制信息，不仅耗费了更多的带宽资源，而且也增加了设备的处理压力。</p>
<p>为了适应这种网络不断变化的移动特性，我们参考SDN范例，将数据平面（包括节点之间本地交换的所有数据流量）与控制平面（包括所有的控制报文和本地路由决策）隔开。他们实现的结构是，设备中有两个用于 DP （data plane）和 CP（control plane） 的无线接口，设备以星形拓扑结构与集中式单元CU连接，CU以集中的方式做出路由决策，几乎实时地了解拓扑。这个框架的两个主要优点：</p>
<ul>
<li>ad hoc网络中引入的开销是最小的,每个节点只需要知道它的邻居并且把该信息传给CU。</li>
<li>根本上减少了每个节点的复杂性,因为路由算法运行在CU。</li>
</ul>
<h2 id="sdn-manet的结构">SDN MANET的结构</h2>
<ul>
<li>
<p>DP MAC协议：采用了ieee802.11的P2P模式独立基本服务集(IBSS)[16]，这是ieee802.11的特设模式标准，根据我们的方法的需要，将交换能力完全控制给上层。</p>
</li>
<li>
<p>SDN协议：OpenFlow。</p>
</li>
<li>
<p>无线交换机：Open vSwitch (OVS)。</p>
</li>
<li>
<p>控制器：ON开发的Open Network Operating System (ONOS)。</p>
</li>
<li>
<p>平台：Rasp berry Pi(树莓派)Model B+，Linux操作系统</p>
</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="修改mac头">修改MAC头</h3>
<p>为了实现SDN架构，需要修改交换机设备的Linux内核，允许CU直接控制节点的路由。</p>
<p></p>
<p>图中左侧为标准 Linux 内核协议栈中从物理层 (PHY) 到应用层 (APP) 的逻辑数据流，</p>
<p>以太网帧通过铜缆（在 PHY 层）到达设备，并被发送到以太网驱动程序（在 MAC 层），在删除 PHY 标头并将它们发送到以太网堆栈之前检查它们的完整性。 在以太网堆栈中，在将数据包发送到路由所在的 NET 层之前，MAC 标头也被删除。</p>
<p>如果从无线接口接收到 Wi-Fi 数据包，则数据包首先被发送到 Wi-Fi 驱动程序，在那里去除 PHY 包头，然后由特定模块处理，将 Wi-Fi 数据包转换为以太网数据包，随后被发送到以太网堆栈。</p>
<p>在 SDN 块中，数据报可以根据从 SDN 控制器接收到的规则进行修改。 特别是，为了控制路由路径，SDN控制器强加的规则涉及修改相应数据报的MAC头。 在这些修改之后，数据报将被发送回 SDN 网桥，并转发到以太网堆栈进行与左侧情况相同的处理。</p>
<h3 id="多跳过程分析">多跳过程分析</h3>
<p>如图所示，涉及从源节点（S）到目的地 (D)的两跳传输。 数据包由 S 生成。它首先传输到辅助节点 (H)，然后由 H 中继到 D。</p>
<p></p>
<ul>
<li>数据包由主机 S (hS) 生成，它在 IP 报头和 MAC 报头中指定目标主机 D (hD) 的地址。 hS 不知道到达 hD 所需的任何路由信息。 它只是通过有线信道将数据包传输到节点 S (sS) 的交换机，该交换机负责无线传输它。</li>
<li>sS 正在运行 SDN 模块，该模块根据从 SDN 控制器接收到的指令修改 MAC 层的源地址和目标地址。 MAC头中的源和目的地分别变成sS和sH（节点H的交换机）。 然后，数据包可以被 sS 发送，也可以被 sH 接收。</li>
<li>由于数据包中的目的MAC地址为sH，因此数据包由sH进一步处理，并向sS发回确认（ACK）。sH 执行类似的过程，修改目的MAC地址，数据包可以被转发到目的节点（sD）的交换机。</li>
<li>最后，sD 根据来自 SDN 控制器的另一条规则，将源 MAC 地址和目标 MAC 地址分别修改为 hS 和 hD。 这个过程，称为 MAC 恢复，是必要的，以便 hD 识别数据包是由 hS 发送的，而不需要来自 SDN 框架的任何进一步信息。</li>
</ul>
<blockquote>
<p>对于大多数 Wi-Fi 适配器，如果 固件的MAC 和目的地不匹配，则固件中会丢弃数据包，因此修改 MAC 地址是多跳传送数据包的必要步骤。</p>
</blockquote>
<h2 id="平台测试性能比较">平台测试：性能比较</h2>
<h3 id="网络设置">网络设置</h3>
<p></p>
<p>实验场景由具有三个 SDN 节点的 SDN MANET 组成，标记为 S、H 和 D，如上一节所示，部署如图所示。每个节点由一个 RPi Model B+ 和一个 Wi -Fi 适配器（Ralink RT5370 USB）组成，DP 中的传输使用 IEEE 802.11g ad-hoc 模式。 三个 SDN 节点配备了 OVS-2.4.0，并连接到运行 ONOS 控制器的 CU 和我们的 MANET 应用程序 [12]。</p>
<p>第二个网络名为 OLSR MANET，它使用相同位置和相同拓扑的相同三个节点（S、H 和 D）进行比较。 实际上，在第二个网络中，节点没有配备我们的 SDN 框架，但它们正在运行分布式路由策略 OLSR。</p>
<p>在这两个网络中，数据流量都是在节点 S 使用流量生成器 iPerf3 [35] 生成的，该流量生成器会创建一个随机 TCP 流，流向目的地节点 D。实验时间为 N 秒，时间间隔为 1秒。 对于每个间隔 τn，n = 1,&hellip;,N，端到端吞吐量以每秒比特 (bps) 为单位测量为：
$$
T\left(\tau_{n}\right)=\frac{\text { TCP } \text { RWND } \times 8}{\text { RTT }}
$$
其中 TCP RWND 是间隔 τi 期间 TCP 会话的平均接收窗口大小，RTT 是平均往返时间，即从发送的 TCP 段的第一个比特传输到接收到该 TCP 段的 TCP ACK的最后一个比特所经过的时间。</p>
<p>为了比较 SDN MANET 和 OLSR MANET 在拓扑突然变化的情况下的行为，我们改变了图a的全连接拓扑为图b的多跳拓扑（S和D之间没有直接连接）。实现的方法是，在节点的 MAC 层设计一个模块来模拟 S 和 D 之间的链路故障，该模块可以拒绝来自 S 的所有数据包（对于 节点 D），或来自 D（对于节点 S）。 这样，我们可以在我们的实验中完美地控制 S 和 D 之间的链路何时发生故障，或者何时重新启动。</p>
<p>对于 SDN MANET 和 OLSR MANET，每个实验重复 M = 20 次。 结果中显示的平均吞吐量为：
$$
\bar{T}\left(\tau_{n}\right)=\frac{\sum_{m=1}^{M} T_{m}\left(\tau_{n}\right)}{M}
$$
其中 Tm(τn) 是第 m 次实验在时间间隔 τn 期间获得的吞吐量。</p>
<h3 id="链路断开实验">链路断开实验</h3>
<p></p>
<p>在时间 t = 10，S 和 D 之间的直接链路发生故障。 SDN控制器立即收到此事件的通知，并迅速做出反应，将新的SDN规则强加给节点S和H。这样，节点S将所有发往D的数据包发送给H，H将这些数据包转发给D。 SDN MANET 的吞吐量立即恢复到初始吞吐量的一半，因为从 S 到 D 的新路径现在有两跳。</p>
<p>OLSR MANET 能够识别链路故障并通过仅在 t = 25 时将路径更改为 D 来对其做出反应，延迟约 15 秒，从而导致严重的吞吐量中断。 这个结果是意料之中的，因为 OLSR 有一个完全分布式的路由算法，它需要大量时间来更新。</p>
<h3 id="连接实验">连接实验</h3>
<p></p>
<p>在第二个实验中，我们观察了当初始拓扑是图b中的拓扑时，SDN MANET 和 OLSR MANET 经历的平均吞吐量，即 S 和 D 之间的两跳路径。 在 t = 10 时，S 和 D 之间的直接链接也被激活，如图a所示。 正如预期的那样，我们观察到，在 SDN MANET 的情况下，网络能够迅速对拓扑的变化做出反应，并且吞吐量在 t &gt; 10 时几乎翻了一番。另一方面，OLSR MANET 的延迟约为 20 秒。</p>
<h3 id="快速变化拓扑实验">快速变化拓扑实验</h3>
<p></p>
<p>在第三个实验中，有一系列连续的拓扑变化。 在 t = 0 时，拓扑是图a中的拓扑（S 和 D 之间有直接链路），然后在 t = 30 时，拓扑变为图b中的拓扑（两跳） ，然后在 t = 60 时再次切换到图a，最后在 t = 90 时切换到图b。</p>
<p>同样在这种情况下，实验重复 20 次，结果取所有试验的平均值。 对于每个拓扑变化，我们观察到 SDN MANET 如何能够几乎立即对拓扑变化做出反应，而 OLSR MANET 对变化的反应有一定的延迟，正如预期的那样，会导致显著的吞吐量损失。</p>
<h2 id="结论">结论</h2>
<p>在这项工作中，我们提出了一个 SDN MANET 的实际实现，它提供了 D2D 数据传输的所有优点，同时具有集中网络管理的灵活性。</p>
<p>为了展示 SDN MANET 的优势以及所提供的所有软件的有效性，我们将我们的 SDN MANET 与以分布式方式管理的 ad hoc 网络进行了比较。 我们用几个简单的例子强调了我们方法的显着优势，特别是对于快速变化的网络拓扑。</p>
<p>在未来的工作中，我们计划处理大规模的 SDN MANET，解决可能出现的可扩展性问题。</p>
]]></description>
</item>
<item>
    <title>鸿蒙开发实践——用户登陆及个人主页</title>
    <link>https://leeshy-tech.github.io/harmonyos_userlogin/</link>
    <pubDate>Sun, 20 Feb 2022 21:57:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/harmonyos_userlogin/</guid>
    <description><![CDATA[<h1 id="用户登录">用户登录</h1>
<h2 id="项目简介">项目简介</h2>
<h3 id="项目结构">项目结构</h3>
<pre tabindex="0"><code>└─ entry
	├─src.main
        ├─ java.com.example.users
            ├─beans
                ├─ Account				API请求体
                └─ LoginMsg				API返回体
            ├─slice
                ├─ UserInfoAbilitySlice		个人主页Slice
                └─ MainAbilitySlice			主页面Slice
            ├─utils
                ├─ DataBaseUtil				数据库操作类
                ├─ HttpRequestUtil			API调用类
                └─ LoadImageUtil			网络图片加载到image组件
            ├─ LocalDBAbility			本地数据库的DataAbility
            ├─ MainAbility
            └─ MyApplication
        └─ resources.base.layout
        	├─ ability_userinfo.xml			个人页面布局文件
            └─ ability_main.xml				主页面布局文件
 	└─ build.gradle							添加外部依赖
</code></pre><h3 id="效果">效果</h3>
<p></p>
<h2 id="项目逻辑">项目逻辑</h2>
<p>此项目的重点是token，它存储在本地数据库，扮演类似浏览器中cookie的角色。</p>
<h3 id="登陆页">登陆页</h3>
<ul>
<li>首页获取用户的账号和密码，点击按钮向后端发送http请求。</li>
<li>登陆成功，则将后端返回的token存入本地数据库，并导航到个人页面。</li>
<li>登陆不成功，则使用ToastDialog组件显示提示信息，账号错误或密码错误。</li>
</ul>
<h3 id="个人页">个人页</h3>
<p>个人页面高度精简，只显示用户头像。</p>
<ul>
<li>导航到此页，说明用户一定已经登陆。</li>
<li>查询本地数据库，获得token。</li>
<li>向后端发送请求，获取用户头像的url。</li>
<li>将url加载到image组件。</li>
</ul>
<p>当用户退出APP，清理后台后，仍然能记住登陆状态，导航回个人主页，不用重新登陆。</p>
<h2 id="后端接口">后端接口</h2>
<p>代码：<a href="https://github.com/leeshy-tech/API_userLogin/blob/main/user_login_token.py" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/API_userLogin/blob/main/user_login_token.py</a></p>
<p>博客：<a href="https://leeshy-tech.github.io/pythonapi_simplelogin2/" target="_blank" rel="noopener noreffer">Python实践——后端接口实现(2)</a></p>
<h2 id="准备">准备</h2>
<p>这些都是之前的博客详细说过的部分，不再赘述。</p>
<h3 id="添加依赖">添加依赖</h3>
<p><code>implementation ('com.alibaba:fastjson:1.2.47')</code></p>
<h3 id="本地数据库的dataabilitylocaldbability">本地数据库的DataAbility——LocalDBAbility</h3>
<p>把之前写过的照抄过来，改一下数据库名、表名、建表sql语句即可。</p>
<h3 id="请求体和返回体类accountloginmsg">请求体和返回体类——Account，LoginMsg</h3>
<p>根据后端接口的格式建立的类。</p>
<h3 id="网络图片加载loadimageutil">网络图片加载——LoadImageUtil</h3>
<p>将网络图片加载到image组件，copy之前的项目。</p>
<h3 id="api调用类httprequestutil">API调用类——HttpRequestUtil</h3>
<p>发送HTTP请求的封装类，这个之前没讲过，照抄会用即可。</p>
<h2 id="databaseutil">DataBaseUtil</h2>
<p>为了尽可能的简化主体代码，把从数据库里查询token，和插入token的操作封装成这个类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="c1">//数据库查询、插入 帮助类
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataBaseUtil</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Uri</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">Uri</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;dataability:///com.example.users.LocalDBAbility/user_info&#34;</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getToken</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">){</span>
        <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="n">DataAbilityHelper</span> <span class="n">dataAbilityHelper</span> <span class="o">=</span> <span class="n">DataAbilityHelper</span><span class="o">.</span><span class="na">creator</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">colums</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;token&#34;</span><span class="o">};</span>
        <span class="n">DataAbilityPredicates</span> <span class="n">predicates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataAbilityPredicates</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">dataAbilityHelper</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">colums</span><span class="o">,</span> <span class="n">predicates</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getRowCount</span><span class="o">()</span> <span class="o">&gt;</span><span class="n">0</span><span class="o">){</span>
                <span class="n">rs</span><span class="o">.</span><span class="na">goToFirstRow</span><span class="o">();</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">DataAbilityRemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">setToken</span><span class="o">(</span><span class="n">String</span> <span class="n">token</span><span class="o">,</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">ValuesBucket</span> <span class="n">valuesBucket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValuesBucket</span><span class="o">();</span>
        <span class="n">valuesBucket</span><span class="o">.</span><span class="na">putString</span><span class="o">(</span><span class="s">&#34;token&#34;</span><span class="o">,</span><span class="n">token</span><span class="o">);</span>
        <span class="n">DataAbilityHelper</span> <span class="n">dataAbilityHelper</span> <span class="o">=</span> <span class="n">DataAbilityHelper</span><span class="o">.</span><span class="na">creator</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">dataAbilityHelper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">valuesBucket</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">DataAbilityRemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="mainabilityslice">MainAbilitySlice</h2>
<p>onStart方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">super</span><span class="o">.</span><span class="na">onStart</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>
<span class="kd">super</span><span class="o">.</span><span class="na">setUIContent</span><span class="o">(</span><span class="n">ResourceTable</span><span class="o">.</span><span class="na">Layout_ability_main</span><span class="o">);</span>

<span class="n">String</span> <span class="n">token_s</span> <span class="o">=</span>  <span class="n">DataBaseUtil</span><span class="o">.</span><span class="na">getToken</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="c1">//如果本地数据库没有token，说明用户还没有登陆
</span><span class="c1"></span><span class="k">if</span> <span class="o">(</span><span class="n">token_s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Button</span> <span class="n">btn_login</span> <span class="o">=</span> <span class="n">findComponentById</span><span class="o">(</span><span class="n">ResourceTable</span><span class="o">.</span><span class="na">Id_login_btn</span><span class="o">);</span>
    <span class="n">TextField</span> <span class="n">tf_userid</span> <span class="o">=</span> <span class="n">findComponentById</span><span class="o">(</span><span class="n">ResourceTable</span><span class="o">.</span><span class="na">Id_login_id_textfield</span><span class="o">);</span>
    <span class="n">TextField</span> <span class="n">tf_userPwd</span> <span class="o">=</span> <span class="n">findComponentById</span><span class="o">(</span><span class="n">ResourceTable</span><span class="o">.</span><span class="na">Id_login_pwd_textfield</span><span class="o">);</span>

    <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;http://8.136.83.196:8899/users/login&#34;</span><span class="o">;</span>
    <span class="n">btn_login</span><span class="o">.</span><span class="na">setClickedListener</span><span class="o">(</span><span class="n">component</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">//开新线程
</span><span class="c1"></span>        <span class="n">TaskDispatcher</span> <span class="n">globalTaskDispatcher</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getGlobalTaskDispatcher</span><span class="o">(</span><span class="n">TaskPriority</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">);</span>
        <span class="c1">//异步
</span><span class="c1"></span>        <span class="n">globalTaskDispatcher</span><span class="o">.</span><span class="na">asyncDispatch</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">user_id</span> <span class="o">=</span> <span class="n">tf_userid</span><span class="o">.</span><span class="na">getText</span><span class="o">();</span>
            <span class="n">String</span> <span class="n">user_pwd</span> <span class="o">=</span> <span class="n">tf_userPwd</span><span class="o">.</span><span class="na">getText</span><span class="o">();</span>
            <span class="c1">//发送http请求，并获得数据
</span><span class="c1"></span>            <span class="n">Account</span> <span class="n">account</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Account</span><span class="o">(</span><span class="n">user_id</span><span class="o">,</span> <span class="n">user_pwd</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">account_json</span> <span class="o">=</span> <span class="n">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">account</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">login_msg</span> <span class="o">=</span> <span class="n">HttpRequestUtil</span><span class="o">.</span><span class="na">sendPostRequest</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="n">account_json</span><span class="o">);</span>
            <span class="n">LoginMsg</span> <span class="n">login_msg_obj</span> <span class="o">=</span> <span class="n">JSON</span><span class="o">.</span><span class="na">parseObject</span><span class="o">(</span><span class="n">login_msg</span><span class="o">,</span> <span class="n">LoginMsg</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">token</span> <span class="o">=</span> <span class="n">login_msg_obj</span><span class="o">.</span><span class="na">getToken</span><span class="o">();</span>
            <span class="n">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">login_msg_obj</span><span class="o">.</span><span class="na">getMsg</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">token</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//将token存入本地数据库，并跳到个人页
</span><span class="c1"></span>                <span class="n">DataBaseUtil</span><span class="o">.</span><span class="na">setToken</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
                <span class="n">present</span><span class="o">(</span><span class="k">new</span> <span class="n">UserInfoAbilitySlice</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">//返回主线程进行UI重绘，原因是show方法不能在子线程中运行
</span><span class="c1"></span>                <span class="n">getUITaskDispatcher</span><span class="o">().</span><span class="na">asyncDispatch</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                        <span class="k">new</span> <span class="n">ToastDialog</span><span class="o">(</span><span class="n">getContext</span><span class="o">()).</span><span class="na">setText</span><span class="o">(</span><span class="n">msg</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">});</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">});</span>
<span class="o">}</span>
<span class="c1">//如果本地数据库有token，说明已经登陆，就跳到个人页
</span><span class="c1"></span><span class="k">else</span><span class="o">{</span>
    <span class="n">present</span><span class="o">(</span><span class="k">new</span> <span class="n">UserInfoAbilitySlice</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>进来先进行一个判断，若本地数据库里有token，则直接跳转到个人页，为了应对APP被杀死后重启的情况。</li>
<li>按钮监听，获取输入框的信息，向后端发送请求，获得token和msg。</li>
<li>若token不为空，则存到本地数据库，并跳转到个人页。</li>
<li>若token为空，则建立一个ToastDialog组件，显示msg。ToastDialog组件专门用于显示提示信息，它存在几秒后自动消失。</li>
</ul>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">建立Toast Dialog组件这里，重绘UI的操作只能在主线程里运行，在这里指show方法，如果直接写<code>new ToastDialog(getContext()).setText(msg).show();</code>是不行的，因为此时我们正在新建的线程里，这个任务要扔回到主线程，所以才有了以下的代码块。</div>
        </div>
    </div>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">getUITaskDispatcher</span><span class="o">().</span><span class="na">asyncDispatch</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">new</span> <span class="n">ToastDialog</span><span class="o">(</span><span class="n">getContext</span><span class="o">()).</span><span class="na">setText</span><span class="o">(</span><span class="n">msg</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div><p>onActive方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">super</span><span class="o">.</span><span class="na">onActive</span><span class="o">();</span>
<span class="c1">//程序重新返回前台调用
</span><span class="c1">//若已经登陆，则导航到个人页
</span><span class="c1"></span><span class="n">String</span> <span class="n">token_s</span> <span class="o">=</span>  <span class="n">DataBaseUtil</span><span class="o">.</span><span class="na">getToken</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">token_s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">present</span><span class="o">(</span><span class="k">new</span> <span class="n">UserInfoAbilitySlice</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div><p>当页面从后台返回前台时，调用的是onActive方法，比如用户在导航到个人页之后，点了一下退出键，就会返回默认页，我们不想让他再发一次http请求，检查token，若存在，直接将其导航回个人页。</p>
<h2 id="userinfoabilityslice">UserInfoAbilitySlice</h2>
<p>onStart方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">super</span><span class="o">.</span><span class="na">onStart</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>
<span class="kd">super</span><span class="o">.</span><span class="na">setUIContent</span><span class="o">(</span><span class="n">ResourceTable</span><span class="o">.</span><span class="na">Layout_ability_userinfo</span><span class="o">);</span>
<span class="c1">//能导航到此页说明用户已经登陆，向服务器请求用户的头像
</span><span class="c1"></span><span class="n">String</span> <span class="n">token</span> <span class="o">=</span> <span class="n">DataBaseUtil</span><span class="o">.</span><span class="na">getToken</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="n">Image</span> <span class="n">image</span> <span class="o">=</span> <span class="n">findComponentById</span><span class="o">(</span><span class="n">ResourceTable</span><span class="o">.</span><span class="na">Id_image</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">token</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="c1">//建新线程
</span><span class="c1"></span>    <span class="n">TaskDispatcher</span> <span class="n">globalTaskDispatcher</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getGlobalTaskDispatcher</span><span class="o">(</span><span class="n">TaskPriority</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">);</span>
    <span class="c1">//异步
</span><span class="c1"></span>    <span class="n">globalTaskDispatcher</span><span class="o">.</span><span class="na">asyncDispatch</span><span class="o">(()-&gt;{</span>
        <span class="c1">//发送请求，更新image组件
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;http://8.136.83.196:8899/users/info&#34;</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">img_url</span> <span class="o">=</span> <span class="n">HttpRequestUtil</span><span class="o">.</span><span class="na">sendPostRequestWithToken</span><span class="o">(</span><span class="k">this</span><span class="o">,</span><span class="n">url</span><span class="o">,</span><span class="n">token</span><span class="o">);</span>
        <span class="n">LoadImageUtil</span><span class="o">.</span><span class="na">loadImg</span><span class="o">(</span><span class="k">this</span><span class="o">,</span><span class="n">img_url</span><span class="o">,</span><span class="n">image</span><span class="o">);</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>导航到此页时，从本地数据库中取出token，向后端发送。</li>
<li>后端返回头像的url。</li>
<li>将url显示到image组件。</li>
</ul>
<h2 id="一些瑕疵">一些瑕疵</h2>
<ol>
<li>没有退出登陆键，这个很容易实现，点击按钮，把token删掉即可，我懒得写了。</li>
<li>个人页太简单，懒就一个字。</li>
</ol>
<h2 id="结束语">结束语</h2>
<h3 id="源码">源码</h3>
<p><a href="https://github.com/leeshy-tech/HarmonyOS_example/tree/main/Users" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/HarmonyOS_example/tree/main/Users</a></p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.bilibili.com/video/BV1DM4y1G7MN" target="_blank" rel="noopener noreffer">HarmonyOS 2.0应用开发实战教程丨锋迷商城项目</a></p>
<p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184" target="_blank" rel="noopener noreffer">HarmonyOS文档</a></p>
]]></description>
</item>
<item>
    <title>Python实践——后端接口实现(2)</title>
    <link>https://leeshy-tech.github.io/pythonapi_simplelogin2/</link>
    <pubDate>Sun, 20 Feb 2022 20:11:06 &#43;0800</pubDate><author>saili@bupt.edu.cn (Leeshy)</author><guid>https://leeshy-tech.github.io/pythonapi_simplelogin2/</guid>
    <description><![CDATA[<h1 id="增加token验证">增加token验证</h1>
<p>书接上文</p>
<h2 id="token是什么">token是什么</h2>
<p>简单来说，token可以认为是身份令牌，当用户登陆成功之后，获得这个令牌，当需要向服务器请求一些私密资源时，便可以提交这个令牌，以证明自己是合法用户。</p>
<h2 id="token生成及解析">token生成及解析</h2>
<p>使用pyjwt这个库：<code>pip install pyjwt</code></p>
<h3 id="核心代码">核心代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">jwt</span>
<span class="c1"># 加密算法</span>
<span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&#34;alg&#34;</span><span class="p">:</span><span class="s2">&#34;HS256&#34;</span><span class="p">,</span>
    <span class="s2">&#34;typ&#34;</span><span class="p">:</span><span class="s2">&#34;JWT&#34;</span>
<span class="p">}</span>
<span class="c1"># 密钥</span>
<span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="s2">&#34;leeshy&#34;</span>
<span class="s1">&#39;&#39;&#39;生成一个token&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">token_encode</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">user_id</span><span class="p">:</span>
        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&#34;user_id&#34;</span><span class="p">:</span><span class="n">user_id</span>
        <span class="p">}</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">payload</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">SECRET_KEY</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;HS256&#39;</span><span class="p">,</span><span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">token</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

<span class="s1">&#39;&#39;&#39;解码token&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">token_decode</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">jwt</span><span class="o">=</span><span class="n">token</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="n">SECRET_KEY</span><span class="p">,</span><span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">algorithms</span><span class="o">=</span><span class="s1">&#39;HS256&#39;</span><span class="p">)</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="s2">&#34;user_id&#34;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">info</span>
</code></pre></div><ul>
<li>headers声明加密算法</li>
<li>SECRET_KEY密钥是编码解码的关键</li>
<li>payload项中，有一些官方声明项，除官方声明项外还可以存一些自定义信息。</li>
</ul>
<h2 id="用户登陆">用户登陆</h2>
<p>如果登陆成功，就返回信息和token，如果不成功，就只返回提示信息。</p>
<p>较上一个版本只有一点改变，核心代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="s1">&#39;&#39;&#39;生成一个返回体&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">response_body_login</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="n">user_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">response_msg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&#34;msg&#34;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
        <span class="s2">&#34;token&#34;</span><span class="p">:</span><span class="n">token_encode</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">response_msg</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/users/login&#39;</span><span class="p">,</span><span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">users_login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&#34;POST&#34;</span><span class="p">:</span>
        <span class="n">user_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;user_id&#34;</span><span class="p">)</span>
        <span class="n">user_password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;user_password&#34;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">user_dict</span> <span class="ow">in</span> <span class="n">users_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_dict</span><span class="p">[</span><span class="s2">&#34;user_id&#34;</span><span class="p">]</span> <span class="o">==</span> <span class="n">user_id</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">user_dict</span><span class="p">[</span><span class="s2">&#34;user_password&#34;</span><span class="p">]</span> <span class="o">==</span> <span class="n">user_password</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">response_body_login</span><span class="p">(</span><span class="s2">&#34;success&#34;</span><span class="p">,</span><span class="n">user_id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">response_body_login</span><span class="p">(</span><span class="s2">&#34;password error&#34;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response_body_login</span><span class="p">(</span><span class="s2">&#34;id not exist&#34;</span><span class="p">)</span>
</code></pre></div><ul>
<li>规定的请求体格式是application/json</li>
</ul>
<h2 id="请求用户信息">请求用户信息</h2>
<p>用户向服务端提供token，验证成功则返回用户头像的url。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/users/info&#39;</span><span class="p">,</span><span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">users_info</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&#34;POST&#34;</span><span class="p">:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s2">&#34;token&#34;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">user_id</span> <span class="o">=</span> <span class="n">token_decode</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&#34;token error&#34;</span>

        <span class="k">for</span> <span class="n">user_dict</span> <span class="ow">in</span> <span class="n">users_headphotos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_dict</span><span class="p">[</span><span class="s2">&#34;user_id&#34;</span><span class="p">]</span> <span class="o">==</span> <span class="n">user_id</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">user_dict</span><span class="p">[</span><span class="s2">&#34;user_headphoto&#34;</span><span class="p">]</span>

        <span class="k">return</span> <span class="s2">&#34;no headphoto&#34;</span>
</code></pre></div><ul>
<li>token要放在请求头里，所以通过request.headers取得。</li>
</ul>
<h2 id="请求体格式">请求体格式</h2>
<p>在前端向后端发送请求时，必须在请求头部分声明请求体格式。</p>
<p>例如：<code>connection.setRequestProperty(&quot;Content-Type&quot;,&quot;application/json;charset=utf-8&quot;);</code></p>
<p>这个格式是由后端决定的，否则后端无法取到对应的信息。</p>
<h3 id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h3>
<p>这是最常见的 POST 提交数据的方式，提交时按照键值对<code>key1=val1&amp;key2=val2</code>的方式进行编码。</p>
<p>版本1时，就使用了这种方法调试，所以后端代码对应的是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">user_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;user_id&#34;</span><span class="p">)</span>
<span class="n">user_password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;user_password&#34;</span><span class="p">)</span>
</code></pre></div><h3 id="applicationjson">application/json</h3>
<p>指示服务端消息主体是序列化的JSON字符串。</p>
<p>本次使用的调试方式是json，所以后端代码对应：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">user_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;user_id&#34;</span><span class="p">)</span>
<span class="n">user_password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;user_password&#34;</span><span class="p">)</span>
</code></pre></div><h2 id="调试">调试</h2>
<p></p>
<p></p>
<h2 id="结束语">结束语</h2>
<h3 id="源码">源码</h3>
<p><a href="https://github.com/leeshy-tech/API_userLogin" target="_blank" rel="noopener noreffer">https://github.com/leeshy-tech/API_userLogin</a></p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://www.cnblogs.com/wbl001/p/12050751.html" target="_blank" rel="noopener noreffer">【记录】form-data与x-www-form-urlencoded的区别 </a></p>
]]></description>
</item>
</channel>
</rss>
